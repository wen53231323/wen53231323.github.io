<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>Redis笔记 | 远方の博客</title><meta name="author" content="wen"><meta name="copyright" content="wen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Redis基础Redis简介Redis是一个开源的高性能键值对存储系统，其使用了单线程加多路IO复用的技术来提供快速且高效的数据处理能力 Redis应用场景   应用场景 描述    缓存 Redis 可以作为高性能缓存系统使用，将常用的数据缓存在内存中，提供快速的读写操作。   会话存储 用于存储用户会话数据，例如登录状态、购物车信息等，在分布式环境下可以提供共享会话功能。   计数器 Redi"><meta property="og:type" content="article"><meta property="og:title" content="Redis笔记"><meta property="og:url" content="https://w_e_n.gitee.io/blog/2021/08/15/Redis/index.html"><meta property="og:site_name" content="远方の博客"><meta property="og:description" content="Redis基础Redis简介Redis是一个开源的高性能键值对存储系统，其使用了单线程加多路IO复用的技术来提供快速且高效的数据处理能力 Redis应用场景   应用场景 描述    缓存 Redis 可以作为高性能缓存系统使用，将常用的数据缓存在内存中，提供快速的读写操作。   会话存储 用于存储用户会话数据，例如登录状态、购物车信息等，在分布式环境下可以提供共享会话功能。   计数器 Redi"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://w_e_n.gitee.io/blog/2021/08/15/Redis/Redis.png"><meta property="article:published_time" content="2021-08-14T16:00:00.000Z"><meta property="article:modified_time" content="2023-08-13T09:23:51.583Z"><meta property="article:author" content="wen"><meta property="article:tag" content="Redis"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://w_e_n.gitee.io/blog/2021/08/15/Redis/Redis.png"><link rel="shortcut icon" href="/blog/img/favicon.png"><link rel="canonical" href="https://w_e_n.gitee.io/blog/2021/08/15/Redis/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//static.cloudflareinsights.com"><link rel="preconnect" href="//www.clarity.ms"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?[object Object]";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=[object Object]"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","[object Object]")</script><script defer data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;[object Object]&quot;}"></script><script>!function(t,e,c,n,a,r){t[c]=t[c]||function(){(t[c].q=t[c].q||[]).push(arguments)},(a=e.createElement(n)).async=1,a.src="https://www.clarity.ms/tag/[object Object]",(r=e.getElementsByTagName(n)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><script>const GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: {"path":"/blog/search.xml","preload":true,"top_n_per_article":5,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Redis笔记",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-08-13 17:23:51"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/img/%E5%A4%B4%E5%83%8F.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/picture/"><i class="fa-fw fas fa-images"></i><span> 图片库</span></a></li><li><a class="site-page child" href="/blog/music/"><i class="fa-fw fas fa-music"></i><span> 音乐库</span></a></li><li><a class="site-page child" href="/blog/movies/"><i class="fa-fw fas fa-video"></i><span> 视频库</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/link/"><span>导航链接</span></a></li><li><a class="site-page child" href="/blog/comment_loading/"><span>评论管理</span></a></li><li><a class="site-page child" href="/blog/custom/"><span>自定义页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/blog/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/blog/2021/08/15/Redis/Redis.png)"><nav id="nav"><span id="blog-info"><a href="/blog/" title="远方の博客"><span class="site-name">远方の博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/picture/"><i class="fa-fw fas fa-images"></i><span> 图片库</span></a></li><li><a class="site-page child" href="/blog/music/"><i class="fa-fw fas fa-music"></i><span> 音乐库</span></a></li><li><a class="site-page child" href="/blog/movies/"><i class="fa-fw fas fa-video"></i><span> 视频库</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/link/"><span>导航链接</span></a></li><li><a class="site-page child" href="/blog/comment_loading/"><span>评论管理</span></a></li><li><a class="site-page child" href="/blog/custom/"><span>自定义页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/blog/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-08-14T16:00:00.000Z" title="发表于 2021-08-15 00:00:00">2021-08-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-13T09:23:51.583Z" title="更新于 2023-08-13 17:23:51">2023-08-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="Redis笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p><a target="_blank" rel="noopener" href="http://redis.cn/">Redis</a>是一个开源的高性能键值对存储系统，其使用了单线程加多路IO复用的技术来提供快速且高效的数据处理能力</p><h2 id="Redis应用场景"><a href="#Redis应用场景" class="headerlink" title="Redis应用场景"></a>Redis应用场景</h2><table><thead><tr><th>应用场景</th><th>描述</th></tr></thead><tbody><tr><td>缓存</td><td>Redis 可以作为高性能缓存系统使用，将常用的数据缓存在内存中，提供快速的读写操作。</td></tr><tr><td>会话存储</td><td>用于存储用户会话数据，例如登录状态、购物车信息等，在分布式环境下可以提供共享会话功能。</td></tr><tr><td>计数器</td><td>Redis支持原子操作，可以用来实现计数器功能，如网站访问量统计、文章点赞数、粉丝数等</td></tr><tr><td>排行榜</td><td>Redis 的有序集合（Sorted Set）可以实现排行榜功能，有序集合可以存储多个元素，并且每个元素都关联一个分数，通过分数来进行排序，如热门文章排行、用户积分排行等。</td></tr><tr><td>分布式锁</td><td>Redis 可以用于实现分布式锁，确保在分布式环境下对共享资源的互斥访问，避免并发冲突。</td></tr><tr><td>分布式缓存</td><td>Redis 可以作为分布式缓存系统使用，通过多个节点组成集群，提供高可用性和扩展性。</td></tr><tr><td>消息队列</td><td>Redis 提供 List 和 Pub&#x2F;Sub 功能，可以实现简单的消息队列系统，用于异步任务处理、事件驱动等场景。</td></tr><tr><td>实时消息推送</td><td>利用 Redis 的发布订阅功能，可以将实时的消息推送给订阅者，适用于聊天室、即时通讯等场景。</td></tr><tr><td>地理位置信息存储</td><td>Redis 的地理位置特性（Geo）可以存储和查询地理位置信息，如附近的人、地点搜索等功能。</td></tr></tbody></table><h2 id="Redis安装与配置"><a href="#Redis安装与配置" class="headerlink" title="Redis安装与配置"></a>Redis安装与配置</h2><h3 id="Linux操作系统安装"><a href="#Linux操作系统安装" class="headerlink" title="Linux操作系统安装"></a>Linux操作系统安装</h3><h4 id="安装包下载"><a href="#安装包下载" class="headerlink" title="安装包下载"></a>安装包下载</h4><p>在linux系统有两种下载方式，一种是通过官网下载，一种是在命令行使用wget下载</p><table><thead><tr><th>下载方式</th><th>简介</th></tr></thead><tbody><tr><td>官网下载</td><td>打开官网下载：<a target="_blank" rel="noopener" href="http://redis.io/">http://redis.io</a></td></tr><tr><td>命令行下载</td><td>执行命令下载：wget <a target="_blank" rel="noopener" href="http://download.redis.io/releases/redisvi">http://download.redis.io/releases/redisvi</a> &#x2F;etc&#x2F;profilevi &#x2F;etc&#x2F;profile</td></tr></tbody></table><h4 id="Linux准备工作"><a href="#Linux准备工作" class="headerlink" title="Linux准备工作"></a>Linux准备工作</h4><p>配置网络、关闭防火墙、下载安装gcc编译器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置开机禁用防火墙（永久关闭防火墙）</span></span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br><span class="line"><span class="comment"># 安装gcc编译器</span></span><br><span class="line">yum -y install gcc</span><br><span class="line"><span class="comment"># 测试gcc编译器是否安装</span></span><br><span class="line">gcc --version</span><br><span class="line"><span class="comment"># 进入安装目录，并上传压缩包</span></span><br><span class="line"><span class="built_in">cd</span> /opt/software/</span><br><span class="line"><span class="comment"># 解压到指定目录</span></span><br><span class="line">tar -zxvf /opt/software/redis-6.2.1.tar.gz -C /opt/module/</span><br></pre></td></tr></table></figure><h4 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h4><p>（1）编译Redis</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建安装目录/usr/local/redis</span></span><br><span class="line">sudo <span class="built_in">mkdir</span> /usr/local/redis</span><br><span class="line"><span class="comment"># 进入redis解压目录</span></span><br><span class="line"><span class="built_in">cd</span> /opt/module/redis-6.2.1/</span><br><span class="line"><span class="comment"># 执行make命令进行编译</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>如果没有准备好C语言编译环境gcc，执行make命令进行编译时会报错—Jemalloc&#x2F;jemalloc.h：没有那个文件</p><p>需要先安装C语言编译环境gcc，然后执行make distclean清理后，再次执行make编译</p><p>（2）安装Redis可以选择指定目录或不指定</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定目录安装redis</span></span><br><span class="line">make PREFIX=/usr/local/redis install</span><br><span class="line"><span class="comment"># 不指定目录安装redis，默认为/usr/local/bin</span></span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>（3）配置环境变量</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># REDIS HOME</span></span><br><span class="line"><span class="built_in">export</span> REDIS_HOME=/usr/local/redis</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$REDIS_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>（4）执行生效</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h3 id="Windows操作系统安装"><a href="#Windows操作系统安装" class="headerlink" title="Windows操作系统安装"></a>Windows操作系统安装</h3><h4 id="安装包下载-1"><a href="#安装包下载-1" class="headerlink" title="安装包下载"></a>安装包下载</h4><p>github上可以下载Windows Redis5.0终版，有安装包形式和zip两种，下载zip包</p><p><a target="_blank" rel="noopener" href="https://github.com/tporadowski/redis/releases">https://github.com/tporadowski/redis/releases</a></p><h4 id="安装与配置-1"><a href="#安装与配置-1" class="headerlink" title="安装与配置"></a>安装与配置</h4><p>（1）新建一个文件夹，将zip包解压到新建文件夹中</p><table><thead><tr><th>文件</th><th>简介</th></tr></thead><tbody><tr><td>redis.windows.conf<br>redis.windows-service.conf</td><td>redis配置文件</td></tr><tr><td>redis-cli</td><td>redis命令行工具，可以启动redis命令行，执行redis命令</td></tr><tr><td>redis-service.exe</td><td>redis 服务，用于启动redis服务</td></tr></tbody></table><p>（2）配置环境变量：【此电脑】-【属性】，找到【高级系统设置】，点击【环境变量】</p><p>（3）打开cmd窗口进行测试</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看是否安装成功</span></span><br><span class="line">redis-cli -v</span><br><span class="line"><span class="comment"># 启动redis服务，启动成功后不能关闭改cmd窗口，如果关了，则redis服务就关掉了</span></span><br><span class="line">redis-server</span><br></pre></td></tr></table></figure><p>（4）启动一个新的cmd窗口，连接Redis，测试存入数据</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动客户端</span></span><br><span class="line">redis-cli</span><br><span class="line"><span class="comment"># 存入数据</span></span><br><span class="line"><span class="built_in">set</span> k v</span><br><span class="line"><span class="comment"># 查看指定key的数据</span></span><br><span class="line">get k</span><br><span class="line"><span class="comment"># 查看所有key</span></span><br><span class="line">keys *</span><br><span class="line"><span class="comment"># 数据清除，通杀全部库</span></span><br><span class="line">flushall</span><br></pre></td></tr></table></figure><h3 id="免安装在线Redis"><a href="#免安装在线Redis" class="headerlink" title="免安装在线Redis"></a>免安装在线Redis</h3><p><a target="_blank" rel="noopener" href="https://try.redis.io/">https://try.redis.io/</a></p><h3 id="Redis安装目录简介"><a href="#Redis安装目录简介" class="headerlink" title="Redis安装目录简介"></a>Redis安装目录简介</h3><table><thead><tr><th>目录</th><th>简介</th></tr></thead><tbody><tr><td>redis-server</td><td>Redis服务端启动脚本</td></tr><tr><td>redis-cli</td><td>Redis提供的命令行客户端</td></tr><tr><td>redis-benchmark</td><td>性能测试工具，可以在自己本子运行，看看自己本子性能如何</td></tr><tr><td>redis-check-aof</td><td>修复有问题的AOF文件</td></tr><tr><td>redis-check-dump</td><td>修复有问题的dump.rdb文件</td></tr><tr><td>redis-sentinel</td><td>Redis哨兵启动脚本</td></tr></tbody></table><h2 id="Redis连接与关闭"><a href="#Redis连接与关闭" class="headerlink" title="Redis连接与关闭"></a>Redis连接与关闭</h2><h3 id="Redis服务启动"><a href="#Redis服务启动" class="headerlink" title="Redis服务启动"></a>Redis服务启动</h3><h4 id="前台启动（不推荐）"><a href="#前台启动（不推荐）" class="headerlink" title="前台启动（不推荐）"></a>前台启动（不推荐）</h4><p>在前台启动的Redis命令行窗口不能关闭，否则服务器停止，命令如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/redis/bin/redis-server</span><br></pre></td></tr></table></figure><h4 id="后台启动（推荐）"><a href="#后台启动（推荐）" class="headerlink" title="后台启动（推荐）"></a>后台启动（推荐）</h4><p>（1）拷贝一份redis.conf到其他目录（备份redis.conf）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /opt/redis-6.2.1/redis.conf /opt</span><br></pre></td></tr></table></figure><p>（2）修改redis.conf(128行)文件，将里面的后台启动设置<code>daemonize</code>，将no改成<code>yes</code>，让服务在后台启动</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 允许访问的地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0</span></span><br><span class="line"><span class="attr">bind</span> <span class="string">0.0.0.0</span></span><br><span class="line"><span class="comment"># 守护进程，修改为yes后即可后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> <span class="string">yes </span></span><br><span class="line"><span class="comment"># 密码，设置后访问Redis必须输入密码</span></span><br><span class="line"><span class="attr">requirepass</span> <span class="string">123321</span></span><br></pre></td></tr></table></figure><p>（3）指定配置文件启动Redis</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定配置文件启动Redis</span></span><br><span class="line">redis-server /opt/redis.conf</span><br><span class="line"><span class="comment"># 查看Redis进程</span></span><br><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure><h4 id="设置开机自启（推荐）"><a href="#设置开机自启（推荐）" class="headerlink" title="设置开机自启（推荐）"></a>设置开机自启（推荐）</h4><p>新建一个系统服务文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/systemd/system/redis.service</span><br></pre></td></tr></table></figure><p>内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=redis-server</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf</span><br><span class="line">PrivateTmp=true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>重载系统服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>使用命令操作Redis</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start redis</span><br><span class="line"><span class="comment"># 停止</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">systemctl restart redis</span><br><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">systemctl status redis</span><br><span class="line"><span class="comment"># 设置开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> redis</span><br></pre></td></tr></table></figure><h3 id="Redis客户端连接"><a href="#Redis客户端连接" class="headerlink" title="Redis客户端连接"></a>Redis客户端连接</h3><h4 id="使用自带redis-cli"><a href="#使用自带redis-cli" class="headerlink" title="使用自带redis-cli"></a>使用自带redis-cli</h4><p>方式一：连接时输入密码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用redis-cli连接Redis，启动Redis客户端（-h 主机地址 -a 密码 -p 端口号 -c 采用集群策略连接）</span></span><br><span class="line">/usr/local/redis/bin/redis-cli -h 主机地址 -a 密码</span><br></pre></td></tr></table></figure><p>方式二：先连接再输入密码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用redis-cli连接上redis</span></span><br><span class="line">redis-cli</span><br><span class="line"><span class="comment"># 输入密码</span></span><br><span class="line">auth 密码</span><br><span class="line"><span class="comment"># 查看密码</span></span><br><span class="line">config get requirepass</span><br></pre></td></tr></table></figure><h4 id="使用使用图形化工具"><a href="#使用使用图形化工具" class="headerlink" title="使用使用图形化工具"></a>使用使用图形化工具</h4><p>下载<a target="_blank" rel="noopener" href="https://gitcode.net/mirrors/qishibo/anotherredisdesktopmanager?utm_source=csdn_github_accelerator">AnotherRedisDeskTopManager</a>图形化工具并安装使用</p><p>下载<a target="_blank" rel="noopener" href="https://resp.app/">Redis Desktop Manager</a>图形化工具并安装使用</p><h3 id="Redis设置密码"><a href="#Redis设置密码" class="headerlink" title="Redis设置密码"></a>Redis设置密码</h3><h4 id="配置文件（推荐）"><a href="#配置文件（推荐）" class="headerlink" title="配置文件（推荐）"></a>配置文件（推荐）</h4><p>在配置文件设置的密码为永久设置，只需要修改<code>requirepass</code> 参数配置密码即可</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass 密码</span><br></pre></td></tr></table></figure><h4 id="客户端命令（不推荐）"><a href="#客户端命令（不推荐）" class="headerlink" title="客户端命令（不推荐）"></a>客户端命令（不推荐）</h4><p>使用客户端命令设置密码只是临时设置，重启redis服务器，密码就会还原，命令如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用redis-cli连接上redis</span></span><br><span class="line">redis-cli</span><br><span class="line"><span class="comment"># 设置临时密码</span></span><br><span class="line">config <span class="built_in">set</span> requirepass 密码</span><br></pre></td></tr></table></figure><h3 id="Redis关闭"><a href="#Redis关闭" class="headerlink" title="Redis关闭"></a>Redis关闭</h3><h4 id="单实例关闭"><a href="#单实例关闭" class="headerlink" title="单实例关闭"></a>单实例关闭</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/redis/bin/redis-cli shutdown</span><br></pre></td></tr></table></figure><h4 id="终端后关闭"><a href="#终端后关闭" class="headerlink" title="终端后关闭"></a>终端后关闭</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用redis-cli连接上redis</span></span><br><span class="line">redis-cli</span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">shutdown</span><br></pre></td></tr></table></figure><h4 id="指定端口关闭"><a href="#指定端口关闭" class="headerlink" title="指定端口关闭"></a>指定端口关闭</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/redis/bin/redis-cli -p 6379 shutdown</span><br></pre></td></tr></table></figure><h4 id="使用kill命令"><a href="#使用kill命令" class="headerlink" title="使用kill命令"></a>使用kill命令</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看进程</span></span><br><span class="line">ps -ef | grep redis</span><br><span class="line"><span class="comment"># 杀掉对应进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 进程号</span><br></pre></td></tr></table></figure><h2 id="Redis配置文件详解"><a href="#Redis配置文件详解" class="headerlink" title="Redis配置文件详解"></a>Redis配置文件详解</h2><h3 id="Units（单位配置）"><a href="#Units（单位配置）" class="headerlink" title="Units（单位配置）"></a>Units（单位配置）</h3><p>配置数据单位换算关系，大小单位，只支持bytes，不支持bit、大小写不敏感</p><h3 id="include（包含配置）"><a href="#include（包含配置）" class="headerlink" title="include（包含配置）"></a>include（包含配置）</h3><p>多实例的情况，可以把公用的配置文件提取出来配置在子配置文件，然后在主文件引用子配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include /path/xxx.conf</span><br></pre></td></tr></table></figure><h3 id="Network（网络相关配置）"><a href="#Network（网络相关配置）" class="headerlink" title="Network（网络相关配置）"></a>Network（网络相关配置）</h3><table><thead><tr><th>配置</th><th>简介</th></tr></thead><tbody><tr><td>bind 127.0.0.1 -::1</td><td>这项配置绑定的IP并不是远程访问的客户端的IP地址，而是本机的IP地址 默认情况bind&#x3D;127.0.0.1只能接受本机的访问请求，因为服务器需要远程访问，所以生产环境要写应用服务器的地址； 若将其注释掉不写，将无限制接受任何ip地址的访问 如果想要让Redis可以远程连接的话，就需要让Redis监听eht0这块网卡， 加上配置bind 127.0.0.1 10.0.4.5，这样既可以本地访问，也能够远程访问。 bind只能有一行配置，如果有多个网卡要监听，就配置多个ip，用空格隔开，否者只有配置的最后一个bind生效</td></tr><tr><td>protected-mode yes</td><td>是否开启保护模式，设置no 若开启保护模式，没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应，不支持远程访问 若关闭保护模式，支持远程访问</td></tr><tr><td>port 6379</td><td>端口号，默认 6379</td></tr><tr><td>tcp-backlog 511</td><td>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和&#x3D;未完成三次握手队列+ 已经完成三次握手队列。 在高并发环境下，需要一个高backlog值来避免慢客户端连接问题。 注意Linux内核会将这个值减小到&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn的值（128）， 所以需要确认增大&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn和&#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog（128）两个值来达到想要的效果</td></tr><tr><td>timeout 0</td><td>一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。</td></tr><tr><td>tcp-keepalive 300</td><td>对访问客户端的一种心跳检测，每个n秒检测一次。 单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60</td></tr></tbody></table><h3 id="GENERAL（通用配置）"><a href="#GENERAL（通用配置）" class="headerlink" title="GENERAL（通用配置）"></a>GENERAL（通用配置）</h3><table><thead><tr><th>配置</th><th>简介</th></tr></thead><tbody><tr><td>daemonize no</td><td>是否为后台进程，设置为yes，守护进程，后台启动</td></tr><tr><td>pidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid</td><td>存放pid文件的位置，每个实例会产生一个不同的pid文件</td></tr><tr><td>loglevel notice</td><td>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为notice 四个级别根据使用阶段来选择，生产环境选择notice 或者warning</td></tr><tr><td>logfile “”</td><td>日志文件名称</td></tr><tr><td>databases 16</td><td>设定数据库的数量，默认16，默认数据库为0，可以使用SELECT<dbid>命令在连接上指定数据库id</dbid></td></tr></tbody></table><h3 id="SNAPSHOTTING-（快照相关）"><a href="#SNAPSHOTTING-（快照相关）" class="headerlink" title="SNAPSHOTTING （快照相关）"></a>SNAPSHOTTING （快照相关）</h3><table><thead><tr><th>配置</th><th>简介</th></tr></thead><tbody><tr><td>dbfilename dump.rdb</td><td>设置保存的RDB的文件名称，默认dump.rdb</td></tr><tr><td>dir .&#x2F;</td><td>设置RDB保存路径，默认在启动目录&#x2F;usr&#x2F;local&#x2F;bin生成快照文件</td></tr><tr><td>stop-writes-on-bgsave-error yes</td><td>当Redis无法写入磁盘的话，直接关掉Redis的写操作。推荐yes.</td></tr><tr><td>rdbcompression yes</td><td>存储到磁盘中的快照，是否进行压缩存储，推荐yes 如果是的话，redis会采用LZF算法进行压缩。 如果不想消耗CPU来进行压缩的话，可以设置为关闭此功能。</td></tr><tr><td>rdbchecksum yes</td><td>在存储快照后，还可以让redis使用CRC64算法来进行数据校验， 但是这样做会增加大约10%的性能消耗， 如果希望获取到最大的性能提升，可以关闭此功能，推荐yes.</td></tr></tbody></table><h3 id="SECURITY（安全配置）"><a href="#SECURITY（安全配置）" class="headerlink" title="SECURITY（安全配置）"></a>SECURITY（安全配置）</h3><p>由于redis很快，所以被破解密码时，性能也很好，如果密码太简单，那么可能很快就被破解了，因此尽量使用长且不容易被猜到的密码作为redis的访问密码，在配置文件设置密码是永久设置</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass 密码</span><br></pre></td></tr></table></figure><h3 id="LIMITS（限制配置）"><a href="#LIMITS（限制配置）" class="headerlink" title="LIMITS（限制配置）"></a>LIMITS（限制配置）</h3><table><thead><tr><th>配置</th><th>简介</th></tr></thead><tbody><tr><td>maxclients</td><td>设置redis同时可以与多少个客户端进行连接，默认情况下为10000个客户端，如果达到了此限制，redis会拒绝新的请求，并回应“max number of clients reached”</td></tr><tr><td>maxmemory</td><td>设置redis可以使用的内存量，建议必须设置，否则，将内存占满，造成服务器宕机 一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过maxmemory-policy来指定。 如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”， 那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。 但是对于无内存申请的指令，仍然会正常响应，比如GET等。 如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时， 需要在系统中留出一些内存空间给同步队列缓存， 只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</td></tr><tr><td>maxmemory-policy</td><td>volatile-lru：使用LRU算法移除key，只对设置了过期时间的键；（最近最少使用）<br>allkeys-lru：在所有集合key中，使用LRU算法移除key<br>volatile-random：在过期集合中移除随机的key，只对设置了过期时间的键<br>allkeys-random：在所有集合key中，移除随机的key<br>volatile-ttl：移除那些TTL值最小的key，即那些最近要过期的key<br>noeviction：不进行移除。针对写操作，只是返回错误信息</td></tr><tr><td>maxmemory-samples</td><td>设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值， 所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个。 一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小。</td></tr></tbody></table><h1 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h1><h2 id="Redis-是单线程吗？"><a href="#Redis-是单线程吗？" class="headerlink" title="Redis 是单线程吗？"></a>Redis 是单线程吗？</h2><p>（1）Redis 程序并不是单线程的</p><p>（2）Redis主要使用单个线程（即主线程）执行「<code>接收客户端请求——&gt;解析请求——&gt;进行数据读写等操作——&gt;发送数据给客户端</code>」的流程，因此我们常说Redis是单线程的</p><p>（3）实际上，Redis在启动时会创建后台线程（BIO），来处理一些耗时的任务，后台线程主要负责以下三个任务</p><ol><li><strong>关闭文件任务（BIO_CLOSE_FILE）</strong>：当需要关闭文件时，这个任务会被添加到关闭文件任务队列。后台线程会不断轮询该队列，并调用close(fd)方法来关闭相应的文件。</li><li><strong>AOF刷盘任务（BIO_AOF_FSYNC）</strong>：如果AOF持久化配置为每秒同步（everysec），主线程将把AOF写入操作封装为一个任务，并将其放入AOF刷盘任务队列。后台线程会不断轮询该队列，并调用fsync(fd)方法将AOF日志刷盘，确保数据持久化。</li><li><strong>内存释放任务（BIO_LAZY_FREE）</strong>：这个任务队列用于释放内存。当有需要释放对象、删除数据库中所有对象或释放跳表对象的操作时，这些操作会被封装成相应的任务，并添加到内存释放任务队列。后台线程会不断轮询该队列，并执行相关的内存释放操作。</li></ol><p>（4）可以将后台线程视为消费者，它从任务队列中获取任务并执行相应的操作，而生产者则是主线程，负责将耗时任务放入相应的任务队列中。通过这种方式，Redis能够在处理客户端请求的同时，利用后台线程处理一些耗时任务，避免主线程阻塞，从而提高了系统的性能和响应速度</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2021/08/15/Redis/Redis线程模型-1.png" style="zoom:33%"><h2 id="Redis-单线程为什么快？"><a href="#Redis-单线程为什么快？" class="headerlink" title="Redis 单线程为什么快？"></a>Redis 单线程为什么快？</h2><ol><li><strong>内存操作</strong>：Redis大部分操作都是基于内存的，而内存读写的速度远快于磁盘读写。因此，Redis能够在短时间内快速地执行读写操作，这是它高速的一个重要原因。</li><li><strong>单线程模型</strong>：Redis采用单线程模型，通过避免线程切换和竞争条件，提高了性能。单线程模型可以减少上下文切换的开销，并且在大多数情况下，单线程已足够处理大部分的请求。</li><li><strong>高效的数据结构</strong>：Redis支持丰富的数据结构，如字符串、列表、哈希表、集合、有序集合等。这些数据结构底层都经过精心设计和实现，使得Redis能够高效地执行各种操作，如查询、插入、更新和删除等。</li><li><strong>异步非阻塞IO</strong>：Redis利用了异步非阻塞IO模型来处理网络请求。它使用事件驱动的方式接收和响应客户端请求，通过监听和触发事件来实现高效的IO操作。这种模型允许Redis在处理一个客户端请求时，同时监听其他客户端请求，提高了处理并发请求的能力。</li><li><strong>非阻塞式的持久化机制</strong>：Redis的持久化机制采用了非阻塞式的方式。当进行AOF日志刷盘或RDB快照时，Redis会使用后台线程来执行相关的操作，而不会阻塞主线程的正常工作。这样可以确保Redis在进行持久化操作时不会对客户端请求产生明显的影响。</li></ol><h1 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h1><p>Redis是一个内存数据库，它的数据结构是键值对（key:value），其中键（key）是一个字符串，而值（value）可以采用多种数据类型。</p><table><thead><tr><th>数据结构</th><th>简介</th><th>示例</th></tr></thead><tbody><tr><td>字符串（key:String）</td><td>一个key对应一个字符串</td><td>key:”Hello World”</td></tr><tr><td>哈希（key:Hash）</td><td>一个key对应一个键值对</td><td>key:{name: “Alice”, age: 25}</td></tr><tr><td>列表（key:List）</td><td>一个key对应一个按照插入顺序存储的字符串列表</td><td>key:[“apple”, “banana”, “orange”]</td></tr><tr><td>无序集合（key:Set）</td><td>一个key对应一个无序、唯一的字符串集合</td><td>key:{“apple”, “banana”, “orange”}</td></tr><tr><td>有序集合（key:Zset）</td><td>一个key对应一个有序、唯一的字符串集合</td><td>key:{“apple”, “banana”, “orange”}</td></tr><tr><td>地理位置（key:Geospatial）</td><td>一个key对应一个地理位置信息的数据结构</td><td>key:{longitude: 39.9087, latitude: 116.3975}</td></tr><tr><td>位图（key:Bitmaps）</td><td>一个key对应一个位图，支持高效地处理二进制位操作</td><td>key:0101010011</td></tr><tr><td>基数估算算法（key:HyperLogLog）</td><td>一个key对应一个基数估算算法，用于统计元素数量的近似值</td><td>key:{“apple”, “banana”, “orange”}</td></tr></tbody></table><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2021/08/15/Redis/常用的五种数据结构.png" style="zoom:50%"><h2 id="键（key）"><a href="#键（key）" class="headerlink" title="键（key）"></a>键（key）</h2><blockquote><p>在Redis中，键（key）是一个字符串，用于唯一标识存储在数据库中的值，可以通过 key获取 Redis 中保存的数据。</p></blockquote><h3 id="key-基本操作"><a href="#key-基本操作" class="headerlink" title="key 基本操作"></a>key 基本操作</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>SET key value</td><td>设置键值对，将指定的值与键关联</td></tr><tr><td>GET key</td><td>获取键对应的值</td></tr><tr><td>DEL key</td><td>删除指定的键值对</td></tr></tbody></table><h3 id="key-时效性控制操作"><a href="#key-时效性控制操作" class="headerlink" title="key 时效性控制操作"></a>key 时效性控制操作</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>expire key seconds</td><td>为给定的key设置过期时间（秒），设置还能活多久</td></tr><tr><td>pexpire key milliseconds</td><td>为给定的key设置过期时间（毫秒），设置还能活多久</td></tr><tr><td>expireat key timestamp</td><td>为给定的key设置过期时间为timestamp所指定的毫秒数时间戳（秒）</td></tr><tr><td>pexpireat key milliseconds-timestamp</td><td>为给定的key设置过期时间为timestamp所指定的毫秒数时间戳（毫秒）</td></tr><tr><td>persist key</td><td>移除键的过期时间，使其永久有效</td></tr><tr><td>ttl key</td><td>获取 key 的剩余过期时间（秒）</td></tr><tr><td>pttl key</td><td>获取 key 的剩余过期时间（毫秒）</td></tr></tbody></table><h3 id="key-查询操作"><a href="#key-查询操作" class="headerlink" title="key 查询操作"></a>key 查询操作</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>key pattern</td><td>按照指定的正则表达式查询Redis中的key<br>查询所有：keys *<br>查询以 it 开头：keys it*<br>查询以 it 结尾：keys *it<br>查询以 user: 开头，最后一个字符任意：keys user:?</td></tr><tr><td>exists key</td><td>查询 key 是否存在（1 - key存在，0 - key不存在）</td></tr><tr><td>type key</td><td>获取 key 的类型</td></tr></tbody></table><h3 id="key-其他操作"><a href="#key-其他操作" class="headerlink" title="key 其他操作"></a>key 其他操作</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>rename key newkey</td><td>为 key 改名</td></tr><tr><td>move key db</td><td>移动key到另外一个库中</td></tr><tr><td>renamenx key newkey</td><td>当且仅当 newkey 不存在时,将 key 改名为 newkey</td></tr><tr><td>sort</td><td>对所有 key 排序（list、hash、sorted_sort）</td></tr></tbody></table><h2 id="字符串（key-String）"><a href="#字符串（key-String）" class="headerlink" title="字符串（key:String）"></a>字符串（key:String）</h2><h3 id="添加-x2F-修改数据"><a href="#添加-x2F-修改数据" class="headerlink" title="添加 &#x2F; 修改数据"></a>添加 &#x2F; 修改数据</h3><p>同等情况下，多数据操作要比单数据操作执行效率高，如果多数据操作一次发送的数据太多，要进行切分（一次发送 1 亿个数据，太大，切成每次发送 100 万个）</p><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>set key value</td><td>添加、修改键值对</td></tr><tr><td>mset key1 value1 key2 value2 …..</td><td>添加、修改多个数据</td></tr><tr><td>msetnx key1 value1 key2 value2 …..</td><td>同时添加一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</td></tr><tr><td>append key value</td><td>在key对应的value末尾，追加内容（不存在该key就创建，存在就追加）</td></tr><tr><td>setnx key value</td><td>设置值，key存在，什么事都不做，只有在 key 不存在时，设置 key 的值</td></tr></tbody></table><h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>get key</td><td>获取对应键值，根据 key 查询对应的 value ，如果不存在，返回空（nil）</td></tr><tr><td>mget key1 key2 …..</td><td>获取多个数据</td></tr><tr><td>strlen key</td><td>获得value字符串的长度</td></tr><tr><td>type key</td><td>获取key的类型</td></tr></tbody></table><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>del key</td><td>删除数据，删除指定的key数据</td></tr></tbody></table><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>unlink key</td><td>根据value选择非阻塞删除，仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作</td></tr><tr><td>getrange key 开始位置 结束位置</td><td>获得值的范围，类似java中的substring，前包，后包</td></tr><tr><td>setrange key 开始位置 value</td><td>用 value 覆写key所储存的字符串值，从开始位置开始(索引从0开始)。</td></tr><tr><td>getset key value</td><td>以新换旧，设置了新值同时获得旧值。</td></tr><tr><td>exists key</td><td>判断某个key是否存在</td></tr></tbody></table><h2 id="哈希（key-Hash）"><a href="#哈希（key-Hash）" class="headerlink" title="哈希（key:Hash）"></a>哈希（key:Hash）</h2><h3 id="添加-x2F-修改数据-1"><a href="#添加-x2F-修改数据-1" class="headerlink" title="添加 &#x2F; 修改数据"></a>添加 &#x2F; 修改数据</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>hset key field value</td><td>添加 &#x2F; 修改数据，给key集合中的 field 键赋值value gg:{id:val,id:val}</td></tr><tr><td>hmset key field1 value1 field2 value2…</td><td>批量添加 &#x2F; 修改多个数据，批量设置hash的值</td></tr><tr><td>hsetnx key field value</td><td>设置值，将哈希表 key 中的域 field 的值设置为 value<br>field不存在，正常添加，存在，什么事都不做</td></tr></tbody></table><h3 id="获取数据-1"><a href="#获取数据-1" class="headerlink" title="获取数据"></a>获取数据</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>hget key field</td><td>获取数据，从key集合field取出 value</td></tr><tr><td>hexists key field</td><td>获取field是否存在，哈希表key中是否存在指定的字段</td></tr><tr><td>hmget key field1 field2 …</td><td>获取多个数据</td></tr><tr><td>hlen key</td><td>获取当前hash结构中field的数量</td></tr><tr><td>hgetall key</td><td>获取所有数据，获取当前hash结构中的全部field和value</td></tr><tr><td>hkeys key</td><td>获取当前hash结构中的全部field</td></tr><tr><td>hvals key</td><td>获取当前hash结构的所有value</td></tr></tbody></table><h3 id="删除数据-1"><a href="#删除数据-1" class="headerlink" title="删除数据"></a>删除数据</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>hdel key field1 [field2]</td><td>删除数据，删除key对应的field，可以删除多个</td></tr></tbody></table><h3 id="扩展操作"><a href="#扩展操作" class="headerlink" title="扩展操作"></a>扩展操作</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>hincrby key field increment</td><td>自增，设置指定字段的数值，为哈希表 key 中的域 field 的值加上增量 1 -1</td></tr><tr><td>hincrbyfloat key field increment</td><td>增加指定范围的值</td></tr></tbody></table><h2 id="列表（key-List）"><a href="#列表（key-List）" class="headerlink" title="列表（key:List）"></a>列表（key:List）</h2><h3 id="添加-x2F-修改数据-2"><a href="#添加-x2F-修改数据-2" class="headerlink" title="添加 &#x2F; 修改数据"></a>添加 &#x2F; 修改数据</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>lpush key value1 value2 value3 ….</td><td>从左边插入一个或多个值</td></tr><tr><td>rpush key value1 value2 value3 ….</td><td>从右边插入一个或多个值</td></tr><tr><td>rpoplpush list1 list2</td><td>将list1列表右边一个值（末尾），插到list2列表左边（头部）</td></tr><tr><td>linsert key before value newvalue</td><td>在value的后面插入newvalue插入值</td></tr><tr><td>lset key index value</td><td>修改数据，将列表key下标为index的值替换成value<br>index超出整个列表的长度，也会失败</td></tr></tbody></table><h3 id="获取数据-2"><a href="#获取数据-2" class="headerlink" title="获取数据"></a>获取数据</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>llen key</td><td>获取列表长度</td></tr><tr><td>lindex key index</td><td>获取指定索引位置的数据（从左到右）</td></tr><tr><td>lrange key start stop</td><td>获取指定索引范围的数据（从右到左） start从0开始，stop输入-1，代表最后一个，-2代表倒数第二个<br>例：lrange mylist 0 -1 0 左边第一个，-1右边第一个，（0-1表示获取所有）</td></tr><tr><td>llen key</td><td>获取整个列表的长度（arr.length）</td></tr></tbody></table><h3 id="删除数据-2"><a href="#删除数据-2" class="headerlink" title="删除数据"></a>删除数据</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>lpop key</td><td>从左边吐出一个值。值在键在，值光键亡</td></tr><tr><td>rpop key</td><td>从右边吐出一个值。值在键在，值光键亡</td></tr><tr><td>lrem key n value</td><td>从左边删除n个value（n&gt;0从左到右，n&lt;0从右到左）</td></tr></tbody></table><h3 id="扩展操作-1"><a href="#扩展操作-1" class="headerlink" title="扩展操作"></a>扩展操作</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>blpop key1 [key2] … timeout</td><td>规定时间内从左边获取并移除 例：等待 30 s ，如果有数据直接取出 blpop list1 30</td></tr><tr><td>brpop key1 [key2] … timeout</td><td>规定时间内从右边获取并移除</td></tr><tr><td>ltrim key start stop</td><td>保留列表中的数据（保留指定索引范围内的数据，超过整个索引范围被移除掉）</td></tr></tbody></table><h2 id="无序集合（key-Set）"><a href="#无序集合（key-Set）" class="headerlink" title="无序集合（key:Set）"></a>无序集合（key:Set）</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>sadd key value1 value2…</td><td>添加数据</td></tr><tr><td>smembers key</td><td>获取数据（获取全部数据）</td></tr><tr><td>srem key value1 value2 …</td><td>删除一个或多个数据，不存在的成员元素会被忽略</td></tr><tr><td>sismember key value</td><td>查看当前的set集合中是否包含这个值</td></tr></tbody></table><h3 id="扩展命令"><a href="#扩展命令" class="headerlink" title="扩展命令"></a>扩展命令</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>srandmember key count</td><td>随机获取指定数量的数据（获取的同时，移除数据，count默认为1，代表弹出数据的数量）</td></tr><tr><td>spop key count</td><td>随机取出指定数量的数据并移除</td></tr><tr><td>sinter key1 key2</td><td>返回交集（取多个set集合交集）</td></tr><tr><td>sunion key1 key2</td><td>返回并集（获取全部集合中的数据）</td></tr><tr><td>sdiff key1 key2</td><td>返回差集（获取多个集合中不一样的数据），数据放在前面的为数据基点</td></tr><tr><td>sinterstore newkey key1 key2</td><td>将交集保存到newKey</td></tr><tr><td>sunionstore newkey key1 key2</td><td>将并集保存到newKey</td></tr><tr><td>sdiffstore newkey key1 key2</td><td>将key1 - key2并集保存到newKey</td></tr><tr><td>smove oldkey newkey value</td><td>将原集合的数据移动到其他集合</td></tr></tbody></table><h2 id="有序集合（key-Zset）"><a href="#有序集合（key-Zset）" class="headerlink" title="有序集合（key:Zset）"></a>有序集合（key:Zset）</h2><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>zadd key score1 member1 score2 member2…</td><td>添加一个或多个数据（score必须是数值，可重复。member不允许重复)</td></tr><tr><td>zincrby key increment member</td><td>修改value的分数（member存在于key中，正常增加分数，不存在，命令相当于zadd）</td></tr></tbody></table><h3 id="获取数据-3"><a href="#获取数据-3" class="headerlink" title="获取数据"></a>获取数据</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>zcard key</td><td>获取zset中数据的数量 获取数组长度</td></tr><tr><td>zcount key min max</td><td>统计该集合，分数区间内的元素个数，包含边界值（sql 语句里面between）</td></tr><tr><td>zrank key value</td><td>返回该值在集合中的排名，从0开始</td></tr><tr><td>zrange key start stop [withscores]</td><td>返回有序集 key 中，下标在start stop之间的元素（默认根据score从小到大排序） 带withscores，可以让分数和值一起返回到结果集。</td></tr><tr><td>zrangebyscore key min max [withscores] [limit offset count]</td><td>返回有序集 key 中，所有score 值介于min 和max 之间(包括等于min 或max )的成员。 有序集成员按score 值递增（从小到大）次序排列。</td></tr><tr><td>zrevrangebyscore key min max [withscores] [limit offset count]</td><td>返回有序集 key 中，所有score 值介于min 和max 之间(包括等于min 或max )的成员。 有序集成员按score 值递增（从大到小）次序排列。</td></tr></tbody></table><h3 id="删除数据-3"><a href="#删除数据-3" class="headerlink" title="删除数据"></a>删除数据</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>zrem key member</td><td>删除该集合下，指定值的元素</td></tr></tbody></table><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>zscore key member</td><td>查看指定的member的分数</td></tr><tr><td>zrange key start stop [withscores]</td><td>根据分数从小到大排序，获取指定范围内的数据 withscores如果添加这个参数，那么会返回member对应的分数</td></tr><tr><td>zrevrange key start stop [withscores]</td><td>根据分数从大到小排序，获取指定范围内的数据（降序排序） withscores如果添加这个参数，那么会返回member对应的分数</td></tr><tr><td>zrangebyscore key min max [withscores] [limit offset count]</td><td>根据分数的返回去获取member withscores代表同时返回score，添加limit，就和MySQL中一样， 如果不希望等于min或者max的值被查询出来可以采用 (分数 相当于 &lt; 但是不等于的方式，最大值和最小值使用+inf和-inf来标识)</td></tr></tbody></table><h2 id="地理位置（key-Geospatial）"><a href="#地理位置（key-Geospatial）" class="headerlink" title="地理位置（key:Geospatial）"></a>地理位置（key:Geospatial）</h2><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>geoadd key longitude latitude member [longitude latitude member…]</td><td>添加地理位置（经度，纬度，名称）</td></tr><tr><td>geopos key member [member…]</td><td>获得指定地区的坐标值</td></tr><tr><td>geodist key member1 member2 [m|km|ft|mi ]</td><td>获取两个位置之间的直线距离</td></tr></tbody></table><h2 id="位图（key-Bitmaps）"><a href="#位图（key-Bitmaps）" class="headerlink" title="位图（key:Bitmaps）"></a>位图（key:Bitmaps）</h2><h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>setbit key offset value</td><td>设置Bitmaps中某个偏移量的值（0或1）offset:偏移量从0开始</td></tr><tr><td>getbit key offset</td><td>获取Bitmaps中某个偏移量的值 获取键的第offset位的值（从0开始算）</td></tr><tr><td>bitcount key [start end]</td><td>统计字符串从start字节到end字节比特值为1的数量，start和end代表起始和结束字节数</td></tr><tr><td>bitop and(or&#x2F;not&#x2F;xor) destkey [key…]</td><td>bitop是一个复合操作，它可以做多个Bitmaps的and（交集）、 or（并集）、 not（非）、 xor（异或）操作 并将结果保存在destkey中。</td></tr></tbody></table><h2 id="基数估算算法（key-HyperLogLog）"><a href="#基数估算算法（key-HyperLogLog）" class="headerlink" title="基数估算算法（key:HyperLogLog）"></a>基数估算算法（key:HyperLogLog）</h2><h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>简介</th></tr></thead><tbody><tr><td>pfadd key element [element …]</td><td>添加指定元素到 HyperLogLog 中 如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0</td></tr><tr><td>pfcount key [key …]</td><td>计算HLL的近似基数，可以计算多个HLL， 比如用HLL存储每天的UV，计算一周的UV可以使用7天的UV合并计算即可</td></tr><tr><td>pfmerge destkey sourcekey [sourcekey …]</td><td>将一个或多个HLL合并后的结果存储在另一个HLL中， 比如每月活跃用户可以使用每天的活跃用户来合并计算可得</td></tr></tbody></table><h1 id="Java操作Redis"><a href="#Java操作Redis" class="headerlink" title="Java操作Redis"></a>Java操作Redis</h1><h2 id="Redis客户端"><a href="#Redis客户端" class="headerlink" title="Redis客户端"></a>Redis客户端</h2><p>（1）Redis客户端是与Redis服务器进行通信的工具或库。它允许开发人员使用各种编程语言（如Python、Java、C#等）来连接和与Redis数据库进行交互。通过Redis客户端，开发人员可以发送各种命令来读取、写入和操作存储在Redis中的数据</p><p>（2）不同的编程语言有不同的Redis客户端库可以使用，开发者可以根据自己使用的编程语言选择相应的Redis客户端，并根据需要使用客户端提供的功能与Redis数据库进行交互，一些常见的Redis客户端如下，详见官网：<a target="_blank" rel="noopener" href="https://redis.io/docs/clients/">https://redis.io/docs/clients/</a></p><ul><li><strong>Redis-cli</strong>：Redis自带的命令行客户端</li><li><strong>Jedis</strong>：Java语言的Redis客户端库</li><li><strong>hiredis</strong>：一个C语言的Redis客户端库</li><li><strong>Jedis</strong>：Java语言的Redis客户端。</li><li><strong>Redis-py</strong>：Python语言的Redis客户端。</li><li><strong>Node_redis</strong>：Node.js语言的Redis客户端。</li><li><strong>PhpRedis</strong>：PHP语言的Redis客户端。</li></ul><h2 id="Redis的Java客户端"><a href="#Redis的Java客户端" class="headerlink" title="Redis的Java客户端"></a>Redis的Java客户端</h2><p>Java语言有多个Redis客户端可以使用，以下是其中一些常用的客户端</p><ul><li><strong>Jedis</strong>：Jedis是一个流行的Java Redis客户端库，它提供了简单而直观的API来与Redis进行交互。</li><li><strong>Lettuce</strong>：Lettuce是另一个功能强大的Java Redis客户端库，它是基于Netty的异步、线程安全和可伸缩的库。</li><li><strong>Redisson</strong>：Redisson是一个功能丰富的Java Redis客户端和分布式对象库。</li></ul><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2021/08/15/Redis/Redis的Java客户端.png" style="zoom:50%"><h2 id="使用Jedis客户端连接Redis"><a href="#使用Jedis客户端连接Redis" class="headerlink" title="使用Jedis客户端连接Redis"></a>使用Jedis客户端连接Redis</h2><h3 id="Jedis基本使用"><a href="#Jedis基本使用" class="headerlink" title="Jedis基本使用"></a>Jedis基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 建立连接，Jedis(主机地址,端口号)</span></span><br><span class="line">    <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">    <span class="comment">// 输入密码</span></span><br><span class="line">    jedis.auth(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    <span class="comment">// 选择库</span></span><br><span class="line">    jedis.select(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 测试连接</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">pong</span> <span class="operator">=</span> jedis.ping();</span><br><span class="line">    System.out.println(<span class="string">&quot;连接成功：&quot;</span> + pong);</span><br><span class="line">    <span class="comment">// Redis的命令是什么，Jedis的方法就是什么</span></span><br><span class="line">    jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    jedis.get(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Jedis连接池使用"><a href="#Jedis连接池使用" class="headerlink" title="Jedis连接池使用"></a>Jedis连接池使用</h3><p>（1）配置jedis连接池类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">8</span>);<span class="comment">// 最多允许创建多少个连接</span></span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">0</span>);<span class="comment">// 最大空闲连接</span></span><br><span class="line">        poolConfig.setMinIdle(<span class="number">0</span>);<span class="comment">// 最小空闲数</span></span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>);<span class="comment">// 当连接池空了之后,多久没获取到Jedis对象,就超时</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接池</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(</span><br><span class="line">                poolConfig,</span><br><span class="line">                <span class="string">&quot;192.168.10.100&quot;</span>,</span><br><span class="line">                <span class="number">6379</span>,</span><br><span class="line">                <span class="number">1000</span>,</span><br><span class="line">                <span class="string">&quot;123456&quot;</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过连接池获取jedis对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）使用连接池测试连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactoryTest</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 通过Jedis连接池建立连接</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisConnectionFactory.getJedis();</span><br><span class="line">        <span class="comment">// 选择库</span></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 测试连接</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">pong</span> <span class="operator">=</span> jedis.ping();</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功：&quot;</span> + pong);</span><br><span class="line">        <span class="comment">// 添加、修改键值对</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">set</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;小明&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取对应键值</span></span><br><span class="line">        System.out.println(jedis.get(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        <span class="comment">// 关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h2><blockquote><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做SpringDataRedis，用于简化与Redis数据库的交互。</p></blockquote><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li><p><strong>连接管理</strong>：Spring Data Redis可以自动管理Redis连接池，确保高效地与Redis服务器进行交互，并提供连接的复用和连接的线程安全性。</p></li><li><p><strong>客户端整合</strong>：Spring Data Redis支持整合不同的Redis客户端，如Jedis、Lettuce和Redisson。从Spring Boot 2.X开始，默认使用Lettuce作为Redis客户端技术，如果需要切换到Jedis，可以引入相应的依赖库。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2021/08/15/Redis/SpringDataRedis集成连接.png" style="zoom:50%"></li><li><p><strong>数据访问</strong>：Spring Data Redis提供了高度封装的<code>RedisTemplate类</code>，统一了操作Redis的API，方便进行数据的存储和读取等操作。</p></li><li><p><strong>缓存支持</strong>：Spring Data Redis集成了Spring框架的缓存抽象，通过简单的配置即可将数据存储到Redis缓存中，提高应用程序的性能和响应速度。</p></li><li><p><strong>对象映射</strong>：Spring Data Redis 通过使用 RedisTemplate 和 RedisSerializer 接口，将对象序列化和反序列化到 Redis 数据库中。你可以将 Java 对象直接存储到 Redis 中，并且支持复杂的对象结构。</p></li><li><p><strong>发布订阅</strong>：Spring Data Redis支持Redis的发布和订阅功能，可以实时地将消息广播给多个消费者。</p></li><li><p><strong>事务支持</strong>：Spring Data Redis提供了对Redis事务的支持，可以将多个操作包装在一个事务中进行原子性的执行。</p></li><li><p><strong>分布式锁</strong>：Spring Data Redis提供了分布式锁的实现，通过Redis的原子操作来保证多个进程&#x2F;线程之间的数据一致性和互斥性。</p></li><li><p><strong>序列化&#x2F;反序列化</strong>：Spring Data Redis提供了多种可选择的策略（RedisSerializer）来对数据进行序列化和反序列化，以便将Java对象存储到Redis中，并支持复杂的对象结构。</p></li></ul><h3 id="RedisTemplate类"><a href="#RedisTemplate类" class="headerlink" title="RedisTemplate类"></a>RedisTemplate类</h3><p>（1）Spring Data Redis提供了一个高度封装的RedisTemplate类，统一API来操作Redis</p><table><thead><tr><th>API</th><th>简介</th></tr></thead><tbody><tr><td>redisTemplate.opsForValue();</td><td>操作String类型数据</td></tr><tr><td>redisTemplate.opsForHash();</td><td>操作Hash类型的数据</td></tr><tr><td>redisTemplate.opsForList();</td><td>操作List类型的数据</td></tr><tr><td>redisTemplate.opsForSet();</td><td>操作set类型数据</td></tr><tr><td>redisTemplate.opsForZSet();</td><td>操作zset类型数据</td></tr></tbody></table><p>（2）RedisTemplate 类提供了对 key 的 bound(绑定) 便捷化操作 API，可以通过 bound 封装指定的 key，然后进行一系列的操作而无须显式的再次指定 Key。</p><table><thead><tr><th>API</th><th>简介</th></tr></thead><tbody><tr><td>redistempalate.boundValueOps</td><td>绑定 string 类型的 key</td></tr><tr><td>redistempalate.boundListOps</td><td>绑定 list 类型的 key</td></tr><tr><td>redistempalate.boundHashOps</td><td>绑定 hash 即 map 类型的 key</td></tr><tr><td>redistempalate.boundSetOps</td><td>绑定 set 类型的 key</td></tr><tr><td>redistempalate.boundZSetOps</td><td>绑定 zset 类型的 key</td></tr></tbody></table><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>（1）创建maven工程，引入pom依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Redis依赖：使用Redis和Spring Data Redis，以及Jedis 客户端--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Redis依赖：使用Redis和Spring Data Redis Reactive，以及Lettuce 客户端--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis-reactive<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 集成redis所需common-pool2对象池（lecttuce缓存连接池）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）添加application.yaml配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.10</span><span class="number">.100</span> <span class="comment"># Redis服务器地址</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span> <span class="comment"># Redis服务器连接端口</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span> <span class="comment"># Redis服务器连接密码（默认为空）</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span> <span class="comment"># Redis数据库索引（默认为0）</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="string">3000ms</span> <span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line">    <span class="attr">client-type:</span> <span class="string">lettuce</span> <span class="comment"># 配置客户端技术类型，设置为lettuce</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span>  <span class="comment"># 连接池最大连接数，默认8（使用负值表示没有限制）</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span> <span class="comment"># 连接池最大阻塞等待时间，默认-1（使用负值表示没有限制）</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span>     <span class="comment"># 连接池最大空闲连接，默认8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span>     <span class="comment"># 连接池中最小空闲连接，默认0</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span>   <span class="comment"># 连接池最大连接数，默认8（使用负值表示没有限制）</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span> <span class="comment"># 连接池最大阻塞等待时间，默认-1（使用负值表示没有限制）</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span>     <span class="comment"># 连接池最大空闲连接，默认8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span>     <span class="comment"># 连接池中最小空闲连接，默认0</span></span><br></pre></td></tr></table></figure><p>（3）创建启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringbootApplication</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      SpringApplication.run(SpringbootApplication.class, args);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）创建Controller包，创建RedisTestController类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/Redis&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTestController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Object, Object&gt; <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取操作对象</span></span><br><span class="line">        ValueOperations&lt;String, String&gt; valueOperations = redisTemplate.opsForValue();<span class="comment">// 操作Redis的iStrng类型</span></span><br><span class="line">        HashOperations&lt;String, String, Object&gt; hashOperations = redisTemplate.opsForHash();<span class="comment">// 操作Redis的Hash类型</span></span><br><span class="line">        ListOperations&lt;String, String&gt; listOperations = redisTemplate.opsForList();<span class="comment">// 操作Redis的List类型</span></span><br><span class="line">        SetOperations&lt;String, String&gt; setOperations = redisTemplate.opsForSet();<span class="comment">// 操作Redis的Set类型</span></span><br><span class="line">        ZSetOperations&lt;String, String&gt; zSetOperations = redisTemplate.opsForZSet();<span class="comment">// 操作Redis的ZSet类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存入数据</span></span><br><span class="line">        valueOperations.set(<span class="string">&quot;stringKey&quot;</span>, <span class="string">&quot;stringValue&quot;</span>);<span class="comment">// 存储键值对到Redis的String类型中</span></span><br><span class="line">        hashOperations.put(<span class="string">&quot;hashKey&quot;</span>, <span class="string">&quot;field&quot;</span>, <span class="string">&quot;hashValue&quot;</span>);<span class="comment">// 存储字段和值到Redis的Hash类型中</span></span><br><span class="line">        listOperations.leftPush(<span class="string">&quot;listKey&quot;</span>, <span class="string">&quot;listValue&quot;</span>);<span class="comment">// 将元素插入到列表的左侧</span></span><br><span class="line">        setOperations.add(<span class="string">&quot;setKey&quot;</span>, <span class="string">&quot;setValue&quot;</span>);<span class="comment">// 向Redis的Set类型中添加元素</span></span><br><span class="line">        zSetOperations.add(<span class="string">&quot;zSetKey&quot;</span>, <span class="string">&quot;zSetValue&quot;</span>, <span class="number">0</span>);<span class="comment">// 向Redis的ZSet类型中添加元素，并指定分数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取对应键值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">stringValue</span> <span class="operator">=</span> valueOperations.get(<span class="string">&quot;stringKey&quot;</span>);<span class="comment">// 获取Redis中指定键的值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">hashValue</span> <span class="operator">=</span> hashOperations.get(<span class="string">&quot;hashKey&quot;</span>, <span class="string">&quot;field&quot;</span>);<span class="comment">// 获取Redis中指定Hash类型的键和字段的值</span></span><br><span class="line">        List&lt;String&gt; listValue = listOperations.range(<span class="string">&quot;listKey&quot;</span>, <span class="number">0L</span>, -<span class="number">1L</span>);<span class="comment">// 获取列表元素范围内的所有元素</span></span><br><span class="line">        Set&lt;String&gt; setValue = setOperations.members(<span class="string">&quot;setKey&quot;</span>);<span class="comment">// 获取集合中的所有元素</span></span><br><span class="line">        Set&lt;ZSetOperations.TypedTuple&lt;String&gt;&gt; zSetValue = zSetOperations.rangeWithScores(<span class="string">&quot;zSetKey&quot;</span>, <span class="number">0L</span>, -<span class="number">1L</span>);<span class="comment">// 获取有序集合中指定范围内的元素及其分数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 放入列表并返回</span></span><br><span class="line">        HashMap&lt;Object, Object&gt; resultMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        resultMap.put(<span class="string">&quot;stringKey&quot;</span>, stringValue);</span><br><span class="line">        resultMap.put(<span class="string">&quot;hashKey&quot;</span>, hashValue);</span><br><span class="line">        resultMap.put(<span class="string">&quot;listKey&quot;</span>, listValue);</span><br><span class="line">        resultMap.put(<span class="string">&quot;setKey&quot;</span>, setValue);</span><br><span class="line">        resultMap.put(<span class="string">&quot;zSetKey&quot;</span>, zSetValue);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（5）启动服务并访问<code>http://localhost:8080/Redis</code>查看页面数据，并打开Redis客户端对比数据是否一致</p><h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><p>（1）Redis序列化与反序列化是指将数据在Redis中进行存储和读取时的编码和解码过程</p><ul><li>序列化：将数据对象转换为字节流，并将其存储到Redis中的过程</li><li>反序列化：将存储在Redis中的字节流，重新转换为原始数据对象的过程</li></ul><p>（2）在Redis中，常见的序列化格式有以下几种</p><ul><li><p>JDK序列化：使用Java自带的序列化机制将对象序列化为字节流存储到Redis中</p></li><li><p>JSON序列化：将数据对象转换为JSON字符串存储在Redis中，在需要时从Redis中获取JSON字符串并反序列化回原始对象</p></li><li><p>字符串序列化：将数据对象直接转换为字符串形式存储在Redis中</p></li><li><p>MessagePack序列化：将数据对象序列化为紧凑的二进制数据进行存储和传输。</p></li><li><p>Protobuf序列化：使用Google的Protobuf协议将数据对象序列化为二进制数据，适用于高性能和跨平台需求。</p></li></ul><p>（3）Spring Data Redis（SDR）提供了多种序列化&#x2F;反序列化策略（RedisSerializer）来处理数据存储和读取操作，可以通过设置RedisTemplate的valueSerializer属性来选择使用合适的序列化方式，提高Redis的存储效率和读取速度，常见的序列化方式包括以下几种</p><table><thead><tr><th>序列化器</th><th>简介</th></tr></thead><tbody><tr><td>JdkSerializationRedisserializer</td><td>默认的序列化方式，使用Java的标准序列化机制，将对象转换为字节数组进行存储 适用于需要存储Java对象的场景</td></tr><tr><td>StringRedisSerializer</td><td>简单的字符串序列化，将对象转换为字符串进行存储，是最轻量级和高效的策略 适用于Key或者Value为字符串的场景，根据指定的字符集对数据的字节序列进行编码成字符串</td></tr><tr><td>GenericToStringSerializer</td><td>将对象转换为字符串进行存储，适用于简单对象的序列化和反序列化。</td></tr><tr><td>GenericFastJsonRedisSerializer</td><td>使用FastJson库将对象转换为JSON格式进行存储【需要引入FastJson依赖包】</td></tr><tr><td>GenericJackson2JsonRedisSerializer</td><td>使用Jackson库将对象转换为JSON格式进行存储【需要引入Jackson依赖包】</td></tr><tr><td>JacksonJsonRedisSerializer</td><td>使用Jackson库将对象转换为JSON格式进行存储【需要引入Jackson依赖包】</td></tr><tr><td>Jackson2JsonRedisSerializer</td><td>使用Jackson库将对象转换为JSON格式进行存储【需要引入Jackson依赖包】</td></tr><tr><td>OxmSerializer</td><td>使用XML格式进行存储，提供了将Java Bean与XML之间的转换能力【需要spring-oxm模块的支持】 使用此策略编程会有一定的难度，而且效率较低，不推荐使用</td></tr></tbody></table><h1 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h1><h2 id="主从复制模式（Master-Slave-Replication）"><a href="#主从复制模式（Master-Slave-Replication）" class="headerlink" title="主从复制模式（Master-Slave Replication）"></a>主从复制模式（Master-Slave Replication）</h2><p>（1）主从同步&#x2F;复制是最基本的 Redis 集群模式之一</p><p>（2）在这种模式下，存在一个主节点（Master）和一个或多个从节点（Slaves）</p><ul><li>主节点（Master）负责处理写操作和读操作，并将写操作的数据同步到所有从节点上</li><li>从节点（Slaves）只能执行读操作，通过定期同步主节点的数据，以便在主节点故障时提供高可用性和读取负载均衡</li></ul><p>（3）在主从复制模式下，主节点（Master）宕机了，从节点（Slaves）是不能变为主服务器进行写操作的（另外一个隐患）</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2021/08/15/Redis/主从复制.png" style="zoom:50%"><h2 id="哨兵模式（Sentinel-Mode）"><a href="#哨兵模式（Sentinel-Mode）" class="headerlink" title="哨兵模式（Sentinel Mode）"></a>哨兵模式（Sentinel Mode）</h2><p>（1）哨兵模式是在主从同步&#x2F;复制模式的基础上进一步扩展的</p><p>（2）哨兵模式引入了哨兵节点（Sentinels），任务是监视主节点的状态，并在主节点故障时，使用投票机制来选举新的主节点，进行故障转移，确保系统的高可用性</p><p>（3）在一个一主多从的集群中，可以启用多个哨兵进行监控以保证集群足够稳健，这种情况下，哨兵不仅监控主从服务，哨兵之间也会相互监控，建议哨兵至少3个并且是奇数</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2021/08/15/Redis/哨兵模式.png" style="zoom:50%"><h2 id="集群模式（Cluster-Mode）"><a href="#集群模式（Cluster-Mode）" class="headerlink" title="集群模式（Cluster Mode）"></a>集群模式（Cluster Mode）</h2><p>（1）Cluster模式是Redis 3.0版本引入的新特性，它是Redis集群的原生分布式方案。</p><p>（2）Cluster模式通过分片（Sharding）将数据分散存储在多个节点上，并在节点之间进行自动数据重分布和故障转移。</p><p>（3）Cluster模式中没有明确的主节点和从节点的区分，每个节点都是平等的，都可以处理读写操作，都会负责一部分数据的存储和处理</p><p>（4）Cluster模式中的每个节点都知道整个集群的状态和数据分布，当某个节点宕机时，其他节点会自动检测到该节点的状态变化，并负责接管它负责的槽位（slot）</p><p>（5）Cluster模式支持自动扩展和缩容，当集群中的节点发生故障或新节点加入时，集群会自动进行数据迁移和重新平衡，实现集群规模的动态调整，保证数据的可用性和负载均衡</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2021/08/15/Redis/Redis集群.png" style="zoom:33%"><h1 id="Redis消息队列"><a href="#Redis消息队列" class="headerlink" title="Redis消息队列"></a>Redis消息队列</h1><h2 id="消息队列（点对点模式）"><a href="#消息队列（点对点模式）" class="headerlink" title="消息队列（点对点模式）"></a>消息队列（点对点模式）</h2><blockquote><p>一对一，消费者主动拉取数据，消息收到后消息清除</p></blockquote><p>（1）消息生产者生产消息发送到队列（Queue）中，然后消息消费者从队列（Queue）中取出并且消费消息。</p><p>（2）消息被消费以后，队列（Queue） 中不再有存储，所以消息消费者不可能消费到已经被消费的消息。</p><p>（3）队列（Queue） 支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2021/08/15/Redis/点对点模式.png" style="zoom:50%"><h2 id="消息队列（发布-x2F-订阅模式）"><a href="#消息队列（发布-x2F-订阅模式）" class="headerlink" title="消息队列（发布&#x2F;订阅模式）"></a>消息队列（发布&#x2F;订阅模式）</h2><blockquote><p>一对多，主题给订阅的消费者分发消息，消费者消费数据之后不会清除消息</p></blockquote><p>（1）消息生产者将消息发布到 主题（topic） 中，同时有多个消息消费者订阅（subscribe）消费该消息。</p><p>（2）和点对点方式不同，发布到 主题（topic） 的消息会被所有订阅者消费。</p><p>（3）发布到 topic 的消息会保存7天</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2021/08/15/Redis/发布订阅模式.png" style="zoom:50%"><h2 id="Redis发布订阅使用案例"><a href="#Redis发布订阅使用案例" class="headerlink" title="Redis发布订阅使用案例"></a>Redis发布订阅使用案例</h2><p>（1）在两个窗口启动Redis</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定配置文件启动Redis</span></span><br><span class="line">redis-server /opt/redis.conf</span><br><span class="line"><span class="comment"># 使用redis-cli连接Redis，启动Redis客户端</span></span><br><span class="line">redis-cli -a 123456</span><br></pre></td></tr></table></figure><p>（2）一个窗口订阅频道channel（消费者）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe channel</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1		<span class="comment"># 返回值为当前已订阅的频道数量</span></span><br></pre></td></tr></table></figure><p>（3）另一个窗口向频道channel发布消息hello（生产者）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish channel <span class="string">&quot;hello&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 1		<span class="comment"># 返回值为订阅当前频道的客户端数量</span></span><br></pre></td></tr></table></figure><p>（4）打开第一个客户端可以看到发送的消息</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe channel [channel ...]</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1		<span class="comment"># 返回值为当前已订阅的频道数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下是客户端接收到的订阅消息</span></span><br><span class="line">1) <span class="string">&quot;message&quot;</span></span><br><span class="line">2) <span class="string">&quot;channel&quot;</span></span><br><span class="line">3) <span class="string">&quot;hello&quot;</span></span><br></pre></td></tr></table></figure><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="Redis持久化简介"><a href="#Redis持久化简介" class="headerlink" title="Redis持久化简介"></a>Redis持久化简介</h2><p>Redis的数据默认保存在内存中，如果不做任何持久化操作，当Redis关闭时数据将会丢失。为了防止数据丢失，Redis提供了两种持久化方式（RDB和AOF），会异步将数据保存在硬盘上</p><table><thead><tr><th>方式</th><th>简介</th></tr></thead><tbody><tr><td>RDB（Redis DataBase）</td><td>快照方式（默认）</td></tr><tr><td>AOF（Append Only File）</td><td>写日志方式</td></tr></tbody></table><h2 id="Redis持久化流程"><a href="#Redis持久化流程" class="headerlink" title="Redis持久化流程"></a>Redis持久化流程</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2021/08/15/Redis/Redis持久化流程.png" style="zoom:50%"><h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><h3 id="RDB持久化流程"><a href="#RDB持久化流程" class="headerlink" title="RDB持久化流程"></a>RDB持久化流程</h3><ol><li>触发条件：根据配置文件中的<code>save</code>参数设置触发持久化的条件，或者通过执行SAVE或BGSAVE命令手动触发持久化操作。</li><li>快照生成：当触发持久化条件满足时，Redis会创建一个子进程来进行快照生成工作。在创建子进程之前，Redis会使用复制-on-write机制来保证在持久化过程中不会对数据进行修改。</li><li>子进程工作：子进程会遍历整个数据集，并将数据写入到一个临时的RDB文件中（默认为dump.rdb）。这个过程是在内存中进行的，不会阻塞主进程。</li><li>文件写入：当子进程完成数据写入后，Redis会用新的RDB文件替换原来的旧文件。这个过程是原子性的，确保持久化文件的完整性。</li><li>持久化完成：持久化过程完成后，Redis会向客户端发送一个事件通知，告知持久化的结果以及生成的RDB文件的路径。</li><li>宕机恢复：假如Redis宕机，下次重启时可以通过读取这个快照文件来恢复数据</li></ol><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2021/08/15/Redis/RDB持久化流程.png" style="zoom:50%"><h3 id="RDB备份"><a href="#RDB备份" class="headerlink" title="RDB备份"></a>RDB备份</h3><p>将*.rdb的文件拷贝到别的地方即可</p><h3 id="RDB恢复"><a href="#RDB恢复" class="headerlink" title="RDB恢复"></a>RDB恢复</h3><p>关闭Redis，把备份的文件拷贝到工作目录下，重新启动Redis，会自动检查dump.rdb进行恢复备份数据</p><h3 id="RDB触发方式"><a href="#RDB触发方式" class="headerlink" title="RDB触发方式"></a>RDB触发方式</h3><p>（1）自动方式：通过配置文件中的<code>save</code>配置项，Redis会根据配置的情况进行自动持久化</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多个save仅是设置多个条件，是一个if elseif的关系（save 间隔时间 更新的key的数量）</span></span><br><span class="line"><span class="comment"># save &quot;&quot;         # 给空值表示不启用RDB，主从机制的时候，不能关闭 RDB 机制</span></span><br><span class="line">save 900 1        <span class="comment"># 每 900 秒，有 1 个数据更改就触发一次</span></span><br><span class="line">save 300 10       <span class="comment"># 每 300 秒，有 10 个数据更改就触发一次</span></span><br><span class="line">save 60 10000     <span class="comment"># 每 60 秒，有 10000 个数据更改就触发一次</span></span><br></pre></td></tr></table></figure><p>（2）手动方式：当要进行持久化的时候，输入save或bgsave命令进行持久化</p><p>save和bgsave命令本质上差不多，一个同步运行一个在异步运行，都是单线程阻塞（执行保存时不能执行其他命令）</p><table><thead><tr><th>触发方式</th><th>简介</th></tr></thead><tbody><tr><td>save</td><td>同步运行，执行save命令后，会阻塞当前Redis服务器，不能处理其他命令，RDB过程完成后，如果存在老的RDB文件，就把新的替代掉旧的。 实际生产环境客户端可能都有几万或者是几十万，这种方式显然不可取。（不建议）</td></tr><tr><td>bgsave</td><td>异步运行，执行bgsave命令后，Redis会在后台异步进行快照操作，快照同时还可以响应客户端请求 具体操作是Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。 阻塞只发生在fork阶段，一般时间很短，基本上 Redis 内部所有的RDB操作都是采用 bgsave 命令</td></tr></tbody></table><h3 id="RDB优点"><a href="#RDB优点" class="headerlink" title="RDB优点"></a>RDB优点</h3><ol><li>性能高：RDB持久化是在内存中进行的操作，生成的快照文件紧凑，恢复数据速度较快，适合用于备份和灾难恢复。</li><li>适用于大量数据：由于RDB文件是二进制格式，相比于AOF文件，占用较小的磁盘空间，适用于保存大规模的数据集。</li><li>简单并易于使用：RDB持久化配置相对简单，只需通过设置save参数来控制触发持久化的条件即可。</li><li>兼容性好：RDB文件是一个二进制格式的文件，可以在不同版本的Redis之间进行兼容和迁移。</li></ol><h3 id="RDB缺点"><a href="#RDB缺点" class="headerlink" title="RDB缺点"></a>RDB缺点</h3><ol><li>数据丢失：由于RDB持久化是异步的，Redis意外崩溃时可能会导致最近的数据丢失。RDB文件生成的时间间隔较长，如果Redis在最近一次生成RDB文件之后崩溃，那么这个时间段内的数据就无法恢复。</li><li>不适合实时数据：由于RDB持久化是定期生成快照，数据只能保持到最后一次快照生成时的状态，并不能实时保存每个写操作，因此不适合要求数据实时一致性的场景。</li><li>恢复时间较长：当使用RDB文件进行恢复时，需要将整个RDB文件加载到内存中，对于大规模的RDB文件，恢复的时间可能比较长。</li><li>不利于数据修改频繁的场景：由于RDB持久化是全量备份，在每次持久化时都需要遍历整个数据集，对于数据修改频繁的场景，持久化过程可能会对性能产生影响。</li></ol><h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><h3 id="AOF持久化流程"><a href="#AOF持久化流程" class="headerlink" title="AOF持久化流程"></a>AOF持久化流程</h3><p>客户端的请求写命令（读操作不记录）会被append追加到AOF缓冲区内（只许追加文件但不可以改写文件），AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；Redis服务重启时，会重新load加载AOF文件中的写操作，从前到后执行达到数据恢复的目的；</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2021/08/15/Redis/AOF持久化流程.png" style="zoom:50%"><h3 id="AOF备份"><a href="#AOF备份" class="headerlink" title="AOF备份"></a>AOF备份</h3><p>将*.aof的文件拷贝到别的地方，启动系统即加载</p><h3 id="AOF恢复"><a href="#AOF恢复" class="headerlink" title="AOF恢复"></a>AOF恢复</h3><p>关闭Redis，把备份的文件拷贝到工作目录下，重新启动Redis，会自动检查appendonly.aof进行恢复备份数据</p><h3 id="AOF异常恢复"><a href="#AOF异常恢复" class="headerlink" title="AOF异常恢复"></a>AOF异常恢复</h3><p>如遇到AOF文件损坏，可通过命令进行恢复</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/redis-check-aof--fix appendonly.aof</span><br></pre></td></tr></table></figure><h3 id="AOF实现方式"><a href="#AOF实现方式" class="headerlink" title="AOF实现方式"></a>AOF实现方式</h3><p>（1）AOF默认不开启，打开配置文件，找到appendonly配置项，配置开启</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">appendonly <span class="built_in">yes</span>  <span class="comment"># 开启AOF，AOF文件的保存路径，同RDB的路径一致</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.aof&quot;</span>  <span class="comment">#默认生成文件的名称</span></span><br></pre></td></tr></table></figure><p>（2）AOF的追加同步频率设置（appendfsync）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># appendfsync always  # 如果要高可靠，就选择 Always 策略</span></span><br><span class="line">appendfsync everysec  <span class="comment"># 如果允许数据丢失一点，但又想性能高，就选择 Everysec 策略（默认）</span></span><br><span class="line"><span class="comment"># appendfsync no  # 如果要高性能，就选择 No 策略</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>策略</th><th>概括</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>always</td><td>每次操作都同步写入日志（不推荐）</td><td>安全，始终同步，不丢失数据</td><td>慢，IO开销较大</td></tr><tr><td><code>everysec</code></td><td>每秒同步写入日志（推荐）</td><td>快，每秒同步，每秒一次fsync</td><td>如果宕机，可能丢1秒数据</td></tr><tr><td>no</td><td>把同步时机交给操作系统（不推荐）</td><td>快，不用管</td><td>不可控，持久化没保证</td></tr></tbody></table><h3 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h3><p>（1）AOF采用文件追加方式，文件会越来越大，为避免出现此种情况，Redis提供了重写机制，当 AOF 文件大小或文件大小的增长率到一定程度时，Redis 能够调用 bgrewriteaof 对日志文件进行重写 （或者手动调用 bgrewriteaof 进行重写）</p><p>（2）重写可以节约大量磁盘空间，减少恢复时间，但是每次重写有一定的负担，可以通过配置改进，建议生产环境配置到 G 的级别，因为默认 64mb 太小了，触发重写机制会 fork 进程，造成阻塞</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-min-size 64mb  <span class="comment"># 设置重写的基准值，当AOF 文件大小大于该配置项时自动开启重写</span></span><br><span class="line">auto-aof-rewrite-percentage 100  <span class="comment"># 设置重写的基准值，超过原文件大小的100%时自动开启重写</span></span><br></pre></td></tr></table></figure><p>（3）指定是否在后台 bgrewriteaof 期间调用 fsync，默认为 no</p><table><thead><tr><th>配置</th><th>简介</th></tr></thead><tbody><tr><td>no-appendfsync-on-rewrite&#x3D;yes</td><td>不写入aof文件只写入缓存，用户请求不会阻塞， 如果宕机，会丢失这段时间的缓存数据。（降低数据安全性，提高性能）</td></tr><tr><td>no-appendfsync-on-rewrite&#x3D;no</td><td>表示要调用 fsync，还是会把数据往磁盘里刷 但是遇到重写操作，可能会发生阻塞，不会造成数据丢失（数据安全，但是性能降低）</td></tr></tbody></table><h3 id="AOF重写流程"><a href="#AOF重写流程" class="headerlink" title="AOF重写流程"></a>AOF重写流程</h3><p>（1）bgrewriteaof触发重写，判断是否当前有bgsave或bgrewriteaof在运行，如果有，则等待该命令结束后再继续执行。</p><p>（2）Redis 主进程先进行 fork() ，创建出一个子进程执行重写操作，保证主进程不会阻塞。</p><p>（3）子进程遍历Redis内存中数据到临时文件，</p><p>（4）主进程的写请求，同时写入aof_buf内存缓冲区和aof_rewrite_buf重写缓冲区，保证原AOF文件完整，以及新AOF文件生成期间的新的数据修改动作不会丢失（即使 rewrite 失败了，也能保证旧数据是正确的）</p><p>（5）子进程写入结束后，向主进程发信号，主进程把aof_rewrite_buf中的数据写入到新的AOF文件。</p><p>（6）使用新的AOF文件覆盖旧的AOF文件，完成AOF重写（原子操作，不会被中断）</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2021/08/15/Redis/AOF重写流程.png" style="zoom:50%"><h3 id="AOF优点"><a href="#AOF优点" class="headerlink" title="AOF优点"></a>AOF优点</h3><p>备份机制更稳健，丢失数据概率更低 可读的日志文本，通过操作AOF稳健，可以处理误操作</p><h3 id="AOF缺点"><a href="#AOF缺点" class="headerlink" title="AOF缺点"></a>AOF缺点</h3><p>比起RDB占用更多的磁盘空间、恢复备份速度要慢 每次读写都同步的话，有一定的性能压力。 存在个别Bug，造成不能恢复</p><h1 id="Redis应用问题解决"><a href="#Redis应用问题解决" class="headerlink" title="Redis应用问题解决"></a>Redis应用问题解决</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="什么是缓存穿透？"><a href="#什么是缓存穿透？" class="headerlink" title="什么是缓存穿透？"></a>什么是缓存穿透？</h3><p>用户查询数据的过程中，如果 redis 数据库没有数据，就会穿透到数据库中查询，如果大量的请求都直接查找数据库，就会造成对数据库很大的压力，最终导致数据库压力过大而崩溃</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2021/08/15/Redis/缓存穿透.png" style="zoom:33%"><h3 id="缓存穿透的原因"><a href="#缓存穿透的原因" class="headerlink" title="缓存穿透的原因"></a>缓存穿透的原因</h3><p>可能原因一：Redis查询不到数据库，数据库中的数据无法同步到缓存 ，从而穿透到数据库中查询</p><p>可能原因二：黑客攻击，黑客使用非正常url持续访问</p><h3 id="缓存穿透的解决方案"><a href="#缓存穿透的解决方案" class="headerlink" title="缓存穿透的解决方案"></a>缓存穿透的解决方案</h3><table><thead><tr><th>方案</th><th>简介</th></tr></thead><tbody><tr><td>缓存空值</td><td>当请求的数据不存在 Redis 也不存在数据库的时候，设置一个缺省值（null或None）进行缓存 当后续再次进行查询则直接返回空值或者缺省值，设置空结果的过期时间会很短，最长不超过五分钟</td></tr><tr><td>设置可访问的名单（白名单）</td><td>使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量， 每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，进行拦截，不允许访问</td></tr><tr><td>采用布隆过滤器</td><td>在数据写入数据库的同时将这个id 同步到到布隆过滤器中，当请求的 id 不存在布隆过滤器中， 说明该请求查询的数据一定没有在数据库中保存，就不要去数据库查询了</td></tr><tr><td>进行实时监控</td><td>当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</td></tr></tbody></table><h3 id="布隆过滤器（Bloom-Filter）"><a href="#布隆过滤器（Bloom-Filter）" class="headerlink" title="布隆过滤器（Bloom Filter）"></a>布隆过滤器（Bloom Filter）</h3><p>（1）布隆过滤器（Bloom Filter）是1970年由布隆提出的，实际上是一个很长的二进制向量（位图）和一系列随机映射函数（哈希函数），由于布隆过滤器（Bloom Filter）需要缓存全量的 key，所以要求全量的 key 数量不大，100 亿条数据（约3.5GB内存）以内最佳</p><table><thead><tr><th>优缺点</th><th>简介</th></tr></thead><tbody><tr><td>优点</td><td>空间效率和查询时间都远远超过一般的算法</td></tr><tr><td>缺点</td><td>有一定的误识别率和删除困难</td></tr></tbody></table><p>（2）布隆过滤器的原理</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、首先分配一块内存空间做 <span class="variable">bit</span> 数组，数组的 <span class="variable">bit</span> 位初始值全部设为 <span class="number">0</span></span><br><span class="line"><span class="number">2</span>、加入元素时，采用 <span class="variable">k</span> 个相互独立的 <span class="built_in">Hash</span> 函数计算，然后将元素 <span class="built_in">Hash</span> 映射的 <span class="built_in">K</span> 个位置全部设置为 <span class="number">1</span>。</span><br><span class="line"><span class="number">3</span>、检测 <span class="variable">key</span> 是否存在，仍然用这 <span class="variable">k</span> 个 <span class="built_in">Hash</span> 函数计算出 <span class="variable">k</span> 个位置，如果位置全部为 <span class="number">1</span>，则表明 <span class="variable">key</span> 存在，否则不存在。</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2021/08/15/Redis/布隆过滤器的原理.png" style="zoom:33%"><p>（3）布隆过滤器的误判：哈希函数会出现碰撞，所以布隆过滤器会存在误判。</p><p>误判率：布隆过滤器判断某个 key 存在，但它实际不存在的概率</p><p>因为存的是 key 的 Hash 值，而非 key 的值，所以有概率存在这样的 key，它们内容不同，但多次 Hash 后的 Hash 值都相同。</p><p>布隆过滤器判断不存在的 key ，则是 100% 不存在的</p><p>布隆过滤器判断存在的 key，不一定真的存在，因为如果这个 key 存在，那它每次 Hash 后对应的 Hash 值位置肯定是 1，而不会是 0。</p><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="缓存击穿的简介"><a href="#缓存击穿的简介" class="headerlink" title="缓存击穿的简介"></a>缓存击穿的简介</h3><p>某个key在redis中过期，此时若有大量并发请求访问这个过期的key（秒杀），请求发现缓存过期，会从数据库加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把数据库压垮。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2021/08/15/Redis/缓存击穿.png" style="zoom:33%"><h3 id="缓存击穿的特点"><a href="#缓存击穿的特点" class="headerlink" title="缓存击穿的特点"></a>缓存击穿的特点</h3><p>数据库压力瞬间升高、Redis是正常运行的、 Redis中并没有大量key过期</p><h3 id="缓存击穿的解决方案"><a href="#缓存击穿的解决方案" class="headerlink" title="缓存击穿的解决方案"></a>缓存击穿的解决方案</h3><table><thead><tr><th>方案</th><th>简介</th></tr></thead><tbody><tr><td>预设置</td><td>在Redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</td></tr><tr><td>实时调整</td><td>现场监控哪些数据热门，实时调整key的过期时长</td></tr><tr><td>使用锁</td><td>给数据库加上锁，当发现缓存失效的时候，不是立即从数据库加载数据，而是先获取分布式锁， 获取锁成功才执行数据库查询和写数据到缓存的操作， 获取锁失败则说明当前有线程在执行数据库查询操作，当前线程睡眠一段时间在重试。 这样只让一个请求去数据库读取数据（效率低）</td></tr><tr><td>设置key永不过期</td><td>对于热点数据，不设置过期时间，把请求都放在缓存中处理，充分把 Redis 高吞吐量性能利用起来（不推荐）</td></tr><tr><td>过期时间+随机值</td><td>设计缓存的过期时间时，使用公式：过期时间&#x3D;baes 时间+随机时间。 即相同业务数据写缓存时，在基础过期时间之上，再加一个随机的过期时间， 让数据在未来一段时间内慢慢过期，避免瞬时全部过期，对 DB 造成过大压力</td></tr></tbody></table><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="缓存雪崩的简介"><a href="#缓存雪崩的简介" class="headerlink" title="缓存雪崩的简介"></a>缓存雪崩的简介</h3><p>缓存中的key大批量在同一时刻过期，此时大量的用户访问这些数据，只能到数据库中进行大量查询，导致数据库查询压力瞬间增大，与缓存击穿不同的是，缓存雪崩是大批量的key同时过期</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2021/08/15/Redis/缓存雪崩.png" style="zoom:33%"><h3 id="缓存雪崩的解决方案"><a href="#缓存雪崩的解决方案" class="headerlink" title="缓存雪崩的解决方案"></a>缓存雪崩的解决方案</h3><table><thead><tr><th>方案</th><th>简介</th></tr></thead><tbody><tr><td>构建多级缓存架构</td><td>nginx缓存 + redis缓存 + 其他缓存（ehcache等）</td></tr><tr><td>使用锁或队列</td><td>用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写<br>从而避免失效时大量的并发请求落到底层存储系统上（不适用高并发情况）</td></tr><tr><td>设置过期标志更新缓存</td><td>记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存</td></tr><tr><td>将缓存失效时间分散开</td><td>比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机<br>这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件</td></tr><tr><td>接口限流</td><td>如果访问的不是核心数据的时候，在查询的方法上加上接口限流保护（比如设置 10000 req&#x2F;s）<br>如果访问的是核心数据接口，缓存不存在允许从数据库中查询并设置到缓存中<br>这样的话，只有部分请求会发送到数据库，减少了数据库的压力<br>限流是指在业务系统的请求入口前端控制每秒进入系统的请求数，避免过多的请求被发送到数据库。</td></tr></tbody></table><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2021/08/15/Redis/接口限流.png" style="zoom:33%"><h3 id="Redis宕机导致的缓存雪崩"><a href="#Redis宕机导致的缓存雪崩" class="headerlink" title="Redis宕机导致的缓存雪崩"></a>Redis宕机导致的缓存雪崩</h3><p>（1）一个 Redis 实例能支撑 10 万的 QPS，而一个数据库实例只有 1000 QPS，一旦 Redis 宕机，会导致大量请求打到数据库，从而发生缓存雪崩。</p><p>（2）Redis宕机导致的缓存雪崩解决方案</p><table><thead><tr><th>方案</th><th>简介</th></tr></thead><tbody><tr><td>服务熔断和接口限流</td><td>在业务系统中，针对高并发的使用服务熔断来有损提供服务从而保证系统的可用性<br>服务熔断是从缓存获取数据发现异常，直接返回错误数据给前端，防止所有流量打到数据库导致宕机<br>服务熔断和限流属于在发生了缓存雪崩，如何降低雪崩对数据库造成的影响的方案。</td></tr><tr><td>构建高可用的缓存集群</td><td>如果 Redis 的主节点故障宕机了，从节点还可以切换成为主节点，继续提供缓存服务<br>避免了由于缓存实例宕机而导致的缓存雪崩问题，使用<code>Redis 哨兵集群</code>或者 <code>Redis Cluster 集群</code></td></tr></tbody></table><h2 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://w_e_n.gitee.io/blog">wen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://w_e_n.gitee.io/blog/2021/08/15/Redis/">https://w_e_n.gitee.io/blog/2021/08/15/Redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://w_e_n.gitee.io/blog" target="_blank">远方の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/Redis/">Redis</a></div><div class="post_share"><div class="social-share" data-image="/blog/2021/08/15/Redis/Redis.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/2021/09/01/RabbitMQ/" title="RabbitMQ笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2021/09/01/RabbitMQ/RabbitMQ.png" onerror='onerror=null,src="/blog/img/404.png"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RabbitMQ笔记</div></div></a></div><div class="next-post pull-right"><a href="/blog/2021/08/01/Nginx/" title="Nginx笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2021/08/01/Nginx/Nginx.png" onerror='onerror=null,src="/blog/img/404.png"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Nginx笔记</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Gitalk</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/img/%E5%A4%B4%E5%83%8F.png" onerror='this.onerror=null,this.src="/blog/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">wen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wen53231323"><i class="fab fa-github"></i><span>我的仓库</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">暂无</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">Redis基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">Redis简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.</span> <span class="toc-text">Redis应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="toc-number">1.3.</span> <span class="toc-text">Redis安装与配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85"><span class="toc-number">1.3.1.</span> <span class="toc-text">Linux操作系统安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%8C%85%E4%B8%8B%E8%BD%BD"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">安装包下载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Linux%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">Linux准备工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">安装与配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85"><span class="toc-number">1.3.2.</span> <span class="toc-text">Windows操作系统安装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E5%8C%85%E4%B8%8B%E8%BD%BD-1"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">安装包下载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE-1"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">安装与配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%8D%E5%AE%89%E8%A3%85%E5%9C%A8%E7%BA%BFRedis"><span class="toc-number">1.3.3.</span> <span class="toc-text">免安装在线Redis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%AE%89%E8%A3%85%E7%9B%AE%E5%BD%95%E7%AE%80%E4%BB%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">Redis安装目录简介</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%85%B3%E9%97%AD"><span class="toc-number">1.4.</span> <span class="toc-text">Redis连接与关闭</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">Redis服务启动</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E5%8F%B0%E5%90%AF%E5%8A%A8%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">前台启动（不推荐）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">后台启动（推荐）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">设置开机自启（推荐）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.4.2.</span> <span class="toc-text">Redis客户端连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%B8%A6redis-cli"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">使用自带redis-cli</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BD%BF%E7%94%A8%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%B7%A5%E5%85%B7"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">使用使用图形化工具</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81"><span class="toc-number">1.4.3.</span> <span class="toc-text">Redis设置密码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">配置文件（推荐）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%91%BD%E4%BB%A4%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">客户端命令（不推荐）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%85%B3%E9%97%AD"><span class="toc-number">1.4.4.</span> <span class="toc-text">Redis关闭</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%AE%9E%E4%BE%8B%E5%85%B3%E9%97%AD"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">单实例关闭</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%88%E7%AB%AF%E5%90%8E%E5%85%B3%E9%97%AD"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">终端后关闭</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3%E5%85%B3%E9%97%AD"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">指定端口关闭</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8kill%E5%91%BD%E4%BB%A4"><span class="toc-number">1.4.4.4.</span> <span class="toc-text">使用kill命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.5.</span> <span class="toc-text">Redis配置文件详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Units%EF%BC%88%E5%8D%95%E4%BD%8D%E9%85%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">1.5.1.</span> <span class="toc-text">Units（单位配置）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#include%EF%BC%88%E5%8C%85%E5%90%AB%E9%85%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">1.5.2.</span> <span class="toc-text">include（包含配置）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Network%EF%BC%88%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">1.5.3.</span> <span class="toc-text">Network（网络相关配置）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GENERAL%EF%BC%88%E9%80%9A%E7%94%A8%E9%85%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">1.5.4.</span> <span class="toc-text">GENERAL（通用配置）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SNAPSHOTTING-%EF%BC%88%E5%BF%AB%E7%85%A7%E7%9B%B8%E5%85%B3%EF%BC%89"><span class="toc-number">1.5.5.</span> <span class="toc-text">SNAPSHOTTING （快照相关）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SECURITY%EF%BC%88%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">1.5.6.</span> <span class="toc-text">SECURITY（安全配置）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LIMITS%EF%BC%88%E9%99%90%E5%88%B6%E9%85%8D%E7%BD%AE%EF%BC%89"><span class="toc-number">1.5.7.</span> <span class="toc-text">LIMITS（限制配置）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">Redis线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">Redis 是单线程吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">Redis 单线程为什么快？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">Redis数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%EF%BC%88key%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">键（key）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#key-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.1.</span> <span class="toc-text">key 基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#key-%E6%97%B6%E6%95%88%E6%80%A7%E6%8E%A7%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.2.</span> <span class="toc-text">key 时效性控制操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#key-%E6%9F%A5%E8%AF%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.3.</span> <span class="toc-text">key 查询操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#key-%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.4.</span> <span class="toc-text">key 其他操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%88key-String%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">字符串（key:String）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0-x2F-%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE"><span class="toc-number">3.2.1.</span> <span class="toc-text">添加 &#x2F; 修改数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">3.2.2.</span> <span class="toc-text">获取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE"><span class="toc-number">3.2.3.</span> <span class="toc-text">删除数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4"><span class="toc-number">3.2.4.</span> <span class="toc-text">其他命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%EF%BC%88key-Hash%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">哈希（key:Hash）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0-x2F-%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE-1"><span class="toc-number">3.3.1.</span> <span class="toc-text">添加 &#x2F; 修改数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE-1"><span class="toc-number">3.3.2.</span> <span class="toc-text">获取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE-1"><span class="toc-number">3.3.3.</span> <span class="toc-text">删除数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C"><span class="toc-number">3.3.4.</span> <span class="toc-text">扩展操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%EF%BC%88key-List%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">列表（key:List）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0-x2F-%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE-2"><span class="toc-number">3.4.1.</span> <span class="toc-text">添加 &#x2F; 修改数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE-2"><span class="toc-number">3.4.2.</span> <span class="toc-text">获取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE-2"><span class="toc-number">3.4.3.</span> <span class="toc-text">删除数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C-1"><span class="toc-number">3.4.4.</span> <span class="toc-text">扩展操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%88key-Set%EF%BC%89"><span class="toc-number">3.5.</span> <span class="toc-text">无序集合（key:Set）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.5.1.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%91%BD%E4%BB%A4"><span class="toc-number">3.5.2.</span> <span class="toc-text">扩展命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%88key-Zset%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">有序集合（key:Zset）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="toc-number">3.6.1.</span> <span class="toc-text">添加数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE-3"><span class="toc-number">3.6.2.</span> <span class="toc-text">获取数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE-3"><span class="toc-number">3.6.3.</span> <span class="toc-text">删除数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C"><span class="toc-number">3.6.4.</span> <span class="toc-text">其他操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%EF%BC%88key-Geospatial%EF%BC%89"><span class="toc-number">3.7.</span> <span class="toc-text">地理位置（key:Geospatial）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-1"><span class="toc-number">3.7.1.</span> <span class="toc-text">常用命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E5%9B%BE%EF%BC%88key-Bitmaps%EF%BC%89"><span class="toc-number">3.8.</span> <span class="toc-text">位图（key:Bitmaps）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-2"><span class="toc-number">3.8.1.</span> <span class="toc-text">常用命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E4%BC%B0%E7%AE%97%E7%AE%97%E6%B3%95%EF%BC%88key-HyperLogLog%EF%BC%89"><span class="toc-number">3.9.</span> <span class="toc-text">基数估算算法（key:HyperLogLog）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-3"><span class="toc-number">3.9.1.</span> <span class="toc-text">常用命令</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%93%8D%E4%BD%9CRedis"><span class="toc-number">4.</span> <span class="toc-text">Java操作Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">4.1.</span> <span class="toc-text">Redis客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84Java%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">4.2.</span> <span class="toc-text">Redis的Java客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Jedis%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5Redis"><span class="toc-number">4.3.</span> <span class="toc-text">使用Jedis客户端连接Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Jedis%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text">Jedis基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jedis%E8%BF%9E%E6%8E%A5%E6%B1%A0%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.2.</span> <span class="toc-text">Jedis连接池使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Data-Redis"><span class="toc-number">4.4.</span> <span class="toc-text">Spring Data Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD"><span class="toc-number">4.4.1.</span> <span class="toc-text">主要功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RedisTemplate%E7%B1%BB"><span class="toc-number">4.4.2.</span> <span class="toc-text">RedisTemplate类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">4.4.3.</span> <span class="toc-text">使用案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">4.5.</span> <span class="toc-text">序列化与反序列化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4"><span class="toc-number">5.</span> <span class="toc-text">Redis集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%BC%8F%EF%BC%88Master-Slave-Replication%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">主从复制模式（Master-Slave Replication）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%EF%BC%88Sentinel-Mode%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">哨兵模式（Sentinel Mode）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%EF%BC%88Cluster-Mode%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">集群模式（Cluster Mode）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">Redis消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E7%82%B9%E5%AF%B9%E7%82%B9%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">消息队列（点对点模式）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88%E5%8F%91%E5%B8%83-x2F-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">消息队列（发布&#x2F;订阅模式）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">6.3.</span> <span class="toc-text">Redis发布订阅使用案例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">7.</span> <span class="toc-text">Redis持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96%E7%AE%80%E4%BB%8B"><span class="toc-number">7.1.</span> <span class="toc-text">Redis持久化简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-number">7.2.</span> <span class="toc-text">Redis持久化流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">7.3.</span> <span class="toc-text">RDB持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E6%8C%81%E4%B9%85%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-number">7.3.1.</span> <span class="toc-text">RDB持久化流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E5%A4%87%E4%BB%BD"><span class="toc-number">7.3.2.</span> <span class="toc-text">RDB备份</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E6%81%A2%E5%A4%8D"><span class="toc-number">7.3.3.</span> <span class="toc-text">RDB恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="toc-number">7.3.4.</span> <span class="toc-text">RDB触发方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E4%BC%98%E7%82%B9"><span class="toc-number">7.3.5.</span> <span class="toc-text">RDB优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E7%BC%BA%E7%82%B9"><span class="toc-number">7.3.6.</span> <span class="toc-text">RDB缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">7.4.</span> <span class="toc-text">AOF持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-number">7.4.1.</span> <span class="toc-text">AOF持久化流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E5%A4%87%E4%BB%BD"><span class="toc-number">7.4.2.</span> <span class="toc-text">AOF备份</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E6%81%A2%E5%A4%8D"><span class="toc-number">7.4.3.</span> <span class="toc-text">AOF恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E5%BC%82%E5%B8%B8%E6%81%A2%E5%A4%8D"><span class="toc-number">7.4.4.</span> <span class="toc-text">AOF异常恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">7.4.5.</span> <span class="toc-text">AOF实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6"><span class="toc-number">7.4.6.</span> <span class="toc-text">AOF重写机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E9%87%8D%E5%86%99%E6%B5%81%E7%A8%8B"><span class="toc-number">7.4.7.</span> <span class="toc-text">AOF重写流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E4%BC%98%E7%82%B9"><span class="toc-number">7.4.8.</span> <span class="toc-text">AOF优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E7%BC%BA%E7%82%B9"><span class="toc-number">7.4.9.</span> <span class="toc-text">AOF缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E5%BA%94%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-number">8.</span> <span class="toc-text">Redis应用问题解决</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">8.1.</span> <span class="toc-text">缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%9F"><span class="toc-number">8.1.1.</span> <span class="toc-text">什么是缓存穿透？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">8.1.2.</span> <span class="toc-text">缓存穿透的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">8.1.3.</span> <span class="toc-text">缓存穿透的解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88Bloom-Filter%EF%BC%89"><span class="toc-number">8.1.4.</span> <span class="toc-text">布隆过滤器（Bloom Filter）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">8.2.</span> <span class="toc-text">缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">8.2.1.</span> <span class="toc-text">缓存击穿的简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">8.2.2.</span> <span class="toc-text">缓存击穿的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">8.2.3.</span> <span class="toc-text">缓存击穿的解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">8.3.</span> <span class="toc-text">缓存雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">8.3.1.</span> <span class="toc-text">缓存雪崩的简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">8.3.2.</span> <span class="toc-text">缓存雪崩的解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%AE%95%E6%9C%BA%E5%AF%BC%E8%87%B4%E7%9A%84%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">8.3.3.</span> <span class="toc-text">Redis宕机导致的缓存雪崩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">8.4.</span> <span class="toc-text">缓存一致性</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/CSS/" title="CSS笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/CSS/CSS.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="CSS笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/CSS/" title="CSS笔记">CSS笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/HTML/" title="HTML笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/HTML/HTML.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="HTML笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/HTML/" title="HTML笔记">HTML笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/JavaScript/" title="JavaScript笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/JavaScript/JavaScript.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="JavaScript笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/JavaScript/" title="JavaScript笔记">JavaScript笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/JavaWeb/" title="JavaWeb笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/JavaWeb/JavaWeb.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="JavaWeb笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/JavaWeb/" title="JavaWeb笔记">JavaWeb笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/Linux/" title="Linux笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/Linux/Linux.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="Linux笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/Linux/" title="Linux笔记">Linux笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By wen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '701b8bc001a40a760558',
      clientSecret: 'a51b436adc471c3949a8f41be05c2d58cccab10a',
      repo: 'Hexo-Butterfly-Comment',
      owner: 'wen53231323',
      admin: ['wen53231323'],
      id: 'a1a13136fcdca9decfeb72b7a8d25bbc',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'VI32wmbmMoxvlhpTpoDBNeOk-MdYXbMMI',
      appKey: 'oFstfBFkCQIkjuk4ibCpbGqz',
      avatar: 'monsterid',
      serverURLs: 'https://vi32wmbm.api.lncldglobal.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Gitalk' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/blog/js/search/local-search.js"></script></div></div></body></html>