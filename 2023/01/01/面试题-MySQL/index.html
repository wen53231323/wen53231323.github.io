<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>面试题-MySQL | 远方の博客</title><meta name="author" content="wen"><meta name="copyright" content="wen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="[TOC] 基础部分SQL查询关键词执行的顺序 SQL执行顺序：from→on→join→where→group by→agg_func→with→having→select→distinct→order by→limit  FROM：指定查询的数据源，即表名或视图名。 ON：指定连接条件，用于连接多个表。 JOIN：根据连接条件，将多个表的数据进行关联。内连接（INNER）、左外连接（LEFT）"><meta property="og:type" content="article"><meta property="og:title" content="面试题-MySQL"><meta property="og:url" content="https://w_e_n.gitee.io/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-MySQL/index.html"><meta property="og:site_name" content="远方の博客"><meta property="og:description" content="[TOC] 基础部分SQL查询关键词执行的顺序 SQL执行顺序：from→on→join→where→group by→agg_func→with→having→select→distinct→order by→limit  FROM：指定查询的数据源，即表名或视图名。 ON：指定连接条件，用于连接多个表。 JOIN：根据连接条件，将多个表的数据进行关联。内连接（INNER）、左外连接（LEFT）"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://w_e_n.gitee.io/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-MySQL/%E9%9D%A2%E8%AF%95%E9%A2%98.png"><meta property="article:published_time" content="2022-12-31T16:00:00.000Z"><meta property="article:modified_time" content="2023-09-06T15:01:49.039Z"><meta property="article:author" content="wen"><meta property="article:tag" content="面试题"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://w_e_n.gitee.io/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-MySQL/%E9%9D%A2%E8%AF%95%E9%A2%98.png"><link rel="shortcut icon" href="/blog/img/favicon.png"><link rel="canonical" href="https://w_e_n.gitee.io/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-MySQL/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//static.cloudflareinsights.com"><link rel="preconnect" href="//www.clarity.ms"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?[object Object]";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=[object Object]"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","[object Object]")</script><script defer data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;[object Object]&quot;}"></script><script>!function(t,e,c,n,a,r){t[c]=t[c]||function(){(t[c].q=t[c].q||[]).push(arguments)},(a=e.createElement(n)).async=1,a.src="https://www.clarity.ms/tag/[object Object]",(r=e.getElementsByTagName(n)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><script>const GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: {"path":"/blog/search.xml","preload":true,"top_n_per_article":5,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"面试题-MySQL",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-09-06 23:01:49"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/img/%E5%A4%B4%E5%83%8F.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/picture/"><i class="fa-fw fas fa-images"></i><span> 图片库</span></a></li><li><a class="site-page child" href="/blog/music/"><i class="fa-fw fas fa-music"></i><span> 音乐库</span></a></li><li><a class="site-page child" href="/blog/movies/"><i class="fa-fw fas fa-video"></i><span> 视频库</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/link/"><span>导航链接</span></a></li><li><a class="site-page child" href="/blog/comment_loading/"><span>评论管理</span></a></li><li><a class="site-page child" href="/blog/custom/"><span>自定义页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/blog/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-MySQL/%E9%9D%A2%E8%AF%95%E9%A2%98.png)"><nav id="nav"><span id="blog-info"><a href="/blog/" title="远方の博客"><span class="site-name">远方の博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/picture/"><i class="fa-fw fas fa-images"></i><span> 图片库</span></a></li><li><a class="site-page child" href="/blog/music/"><i class="fa-fw fas fa-music"></i><span> 音乐库</span></a></li><li><a class="site-page child" href="/blog/movies/"><i class="fa-fw fas fa-video"></i><span> 视频库</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/link/"><span>导航链接</span></a></li><li><a class="site-page child" href="/blog/comment_loading/"><span>评论管理</span></a></li><li><a class="site-page child" href="/blog/custom/"><span>自定义页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/blog/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试题-MySQL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-06T15:01:49.039Z" title="更新于 2023-09-06 23:01:49">2023-09-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="面试题-MySQL"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p><h1 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h1><h2 id="SQL查询关键词执行的顺序"><a href="#SQL查询关键词执行的顺序" class="headerlink" title="SQL查询关键词执行的顺序"></a>SQL查询关键词执行的顺序</h2><blockquote><p>SQL执行顺序：from→on→join→where→group by→agg_func→with→having→select→distinct→order by→limit</p><ol><li><strong>FROM</strong>：指定查询的数据源，即表名或视图名。</li><li><strong>ON</strong>：指定连接条件，用于连接多个表。</li><li><strong>JOIN</strong>：根据连接条件，将多个表的数据进行关联。内连接（INNER）、左外连接（LEFT）、右外连接（RIGHT）</li><li><strong>WHERE</strong>：指定查询的条件，只有符合条件的行才会被返回。</li><li><strong>GROUP BY</strong>：按照指定的列或表达式对数据进行分组。</li><li><strong>AGG_FUNC</strong>：对每个组进行聚合操作。</li><li><strong>WITH</strong>：可选WITH CUBE或WITH ROLLUP，在 GROUP BY 子句中使用，生成更多的汇总行。</li><li><strong>HAVING</strong>：类似于 WHERE，但是作用于已经分组的结果集，可以使用聚合函数进行筛选。</li><li><strong>SELECT</strong>：选择要返回的列或计算的表达式。</li><li><strong>DISTINCT</strong>：去除重复的行。不指定默认为all，表示返回所有行</li><li><strong>ORDER BY</strong>：按照指定的列对结果集进行排序。升序排序（ASC）或者降序排序（DESC）。</li><li><strong>LIMIT</strong>：限制返回记录的数量。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">select [distinct / all] </span><br><span class="line">	聚合函数/字段列表</span><br><span class="line">from</span><br><span class="line">	表名称1</span><br><span class="line">	 [left / right / inner] join 表名称2 on 多表的连接条件</span><br><span class="line">	……</span><br><span class="line">where</span><br><span class="line">	条件表达式，建议不包含聚合函数的过滤条件</span><br><span class="line">group by </span><br><span class="line">	分组字段</span><br><span class="line">having</span><br><span class="line">	分组后的条件表达式，建议包含聚合函数的过滤条件</span><br><span class="line">order by</span><br><span class="line">	排序字段[asc / desc]</span><br><span class="line">limit</span><br><span class="line">	[查询的起始行,]每页显示的条数</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-MySQL/%E9%9D%A2%E8%AF%95%E9%A2%98-MySQL%5CSQL%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png"></p></blockquote><h2 id="表跟表是怎么关联的？"><a href="#表跟表是怎么关联的？" class="headerlink" title="表跟表是怎么关联的？"></a>表跟表是怎么关联的？</h2><blockquote><p>表与表之间关联方式有很多种</p><ul><li><strong>自连接</strong>：自连接是指将表与自身进行连接。</li><li><strong>交叉连接</strong>：叉连接也称为笛卡尔积，它返回两个表的所有可能组合。</li><li><strong>合并查询</strong>：合并查询用于将两个或多个查询的结果合并成一个结果集。</li><li><strong>内连接</strong>：内连接返回两个表中满足连接条件的交集。内连接可以分为隐式内连接和显示内连接。</li><li><strong>外连接</strong>：外连接返回满足连接条件的行以及未匹配的行。外连接可以分为左外连接、右外连接和全外连接。</li></ul></blockquote><h2 id="说一说内连接？"><a href="#说一说内连接？" class="headerlink" title="说一说内连接？"></a>说一说内连接？</h2><blockquote><p>内连接返回两个表中满足连接条件的交集（A∩B）。内连接可以分为隐式内连接和显示内连接。</p><ul><li><p><strong>隐式内连接</strong>：隐式内连接使用WHERE子句来指定连接条件，将两个或多个表进行连接。</p></li><li><p><strong>显式内连接</strong>：显式内连接使用JOIN子句来指定连接条件，并明确地声明使用哪种连接方式</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 隐式内连接</span><br><span class="line">SELECT *</span><br><span class="line">FROM table1, table2</span><br><span class="line">WHERE table1.column = table2.column;</span><br><span class="line"></span><br><span class="line"># 显式内连接</span><br><span class="line">SELECT *</span><br><span class="line">FROM table1</span><br><span class="line">INNER JOIN table2 ON table1.column = table2.column;</span><br></pre></td></tr></table></figure></blockquote><h2 id="说一说外连接？"><a href="#说一说外连接？" class="headerlink" title="说一说外连接？"></a>说一说外连接？</h2><blockquote><p>外连接返回满足连接条件的行以及未匹配的行。外连接可以分为左外连接（A+A∩B）、右外连接（A∩B+B）和全外连接（A+A∩B+B）。</p><ul><li><p><strong>左外连接（LEFT JOIN）</strong>：返回包括左表中所有行和右表中匹配行的结果集。</p></li><li><p><strong>右外连接（RIGHT JOIN）</strong>：返回包括右表中所有行和左表中匹配行的结果集。</p></li><li><p><strong>全外连接（FULL JOIN）</strong>：返回左表和右表中所有行的结果集，如果没有匹配的行，则用NULL填充。MySQL不支持全外连接，但是可以使用UNION关键字将左外连接和右外连接的结合获取</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 左外连接（LEFT JOIN）</span><br><span class="line">SELECT *</span><br><span class="line">FROM table1</span><br><span class="line">LEFT JOIN table2 ON table1.column = table2.column;</span><br><span class="line"># 右外连接（RIGHT JOIN）</span><br><span class="line">SELECT *</span><br><span class="line">FROM table1</span><br><span class="line">RIGHT JOIN table2 ON table1.column = table2.column;</span><br><span class="line"># 全外连接（FULL JOIN）</span><br><span class="line">SELECT *</span><br><span class="line">FROM table1</span><br><span class="line">FULL JOIN table2 ON table1.column = table2.column;</span><br></pre></td></tr></table></figure></blockquote><h2 id="常见的聚合函数？"><a href="#常见的聚合函数？" class="headerlink" title="常见的聚合函数？"></a>常见的聚合函数？</h2><blockquote><p>MySQL中常见的聚合函数包括以下几种：</p><ul><li>**SUM(column_name)**：用于计算指定列的总和。</li><li>**MAX(column_name)**：用于找出指定列的最大值。</li><li>**MIN(column_name)**：用于找出指定列的最小值。</li><li>**AVG(column_name)**：用于计算指定列的平均值。</li><li>**COUNT(column_name)**：用于统计指定列的非空记录数。</li></ul></blockquote><h2 id="什么是SQL注入？"><a href="#什么是SQL注入？" class="headerlink" title="什么是SQL注入？"></a>什么是SQL注入？</h2><blockquote><p>攻击者通过在用户输入中插入特殊字符或SQL命令来欺骗应用程序，使应用程序误以为这些恶意内容是合法的输入，并将其作为SQL查询的一部分执行。这样，攻击者可以控制SQL查询的逻辑，执行未经授权的操作，如删除数据、泄露敏感信息等。</p></blockquote><h2 id="怎样防止SQL注入？"><a href="#怎样防止SQL注入？" class="headerlink" title="怎样防止SQL注入？"></a>怎样防止SQL注入？</h2><blockquote><p>为了预防SQL注入攻击，可以采取以下几种措施：</p><ul><li><strong>输入验证和过滤</strong>：对用户输入进行严格的验证和过滤，只允许合法的输入字符通过，可以通过正则表达式或白名单来实现。同时，还可以使用安全框架或库来过滤潜在的恶意输入。</li><li><strong>权限控制</strong>：对用户进行分级管理，严格控制用户的权限，对于普通用户，禁止给予数据库建立、删除、修改等相关权限，只有系统管理员才具有增、删、改、查的权限。</li><li><strong>使用参数化查询</strong>：使用参数化查询可以将用户输入和SQL查询逻辑分离，数据库引擎会对输入进行参数化处理，从而防止攻击者插入恶意代码。大多数编程语言和框架都支持参数化查询。</li></ul></blockquote><h2 id="视图是什么？"><a href="#视图是什么？" class="headerlink" title="视图是什么？"></a>视图是什么？</h2><blockquote><p>视图（View）是一种虚拟的表，基于一个或多个表的查询结果所创建的，可以看作是预定义查询，并不存储实际数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建视图</span><br><span class="line">create  view 视图名 as 查询语句;</span><br><span class="line"># 查看视图</span><br><span class="line">select * from 视图名称;</span><br></pre></td></tr></table></figure></blockquote><h2 id="存储过程是什么？"><a href="#存储过程是什么？" class="headerlink" title="存储过程是什么？"></a>存储过程是什么？</h2><blockquote><p>存储起来的SQL语句，预先编译，执行快，通过指定名称调用，占资源，调试难，通常用于封装常用的业务逻辑，但不建议使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 创建存储过程</span><br><span class="line">CREATE PROCEDURE GetEmployeeCount()</span><br><span class="line">BEGIN</span><br><span class="line">    SELECT COUNT(*) FROM employees;</span><br><span class="line">END;</span><br><span class="line"># 使用存储过程</span><br><span class="line">CALL GetEmployeeCount();</span><br></pre></td></tr></table></figure></blockquote><h2 id="存储过程的优点？"><a href="#存储过程的优点？" class="headerlink" title="存储过程的优点？"></a>存储过程的优点？</h2><blockquote><ol><li><strong>一次编译多次使用</strong>：存储过程只在创建时进行编译，之后的使用都不需要重新编译， 这就提升了 SQL 的执行效率。</li><li><strong>简化SQL使用</strong>：在进行相对复杂的数据库操作时，原本需要使用一条一条的 SQL 语句，可能要连接多次数据库才能完成的操作，现在变成了一次存储过程，只需要连接一次即可 。</li></ol></blockquote><h2 id="存储过程的缺点？"><a href="#存储过程的缺点？" class="headerlink" title="存储过程的缺点？"></a>存储过程的缺点？</h2><blockquote><ul><li><strong>可移植性差</strong>：存储过程不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。</li><li><strong>占用资源</strong>：存储过程需要在数据库中占用一定的空间，可能会导致数据库的数据膨胀</li><li><strong>调试困难</strong>：存储过程中的SQL语句通常比较复杂，调试起来相对困难</li><li><strong>维护困难</strong>：索引发生变化，可能会导致存储过程失效，存储过程本身没有版本控制，版本迭代更新的时候很麻烦</li></ul></blockquote><h2 id="存储函数是什么？"><a href="#存储函数是什么？" class="headerlink" title="存储函数是什么？"></a>存储函数是什么？</h2><blockquote><p>存储函数可以理解为自定义函数，存储起来的SQL语句，是一串执行逻辑，必须有返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建存储函数</span><br><span class="line">CREATE FUNCTION GetEmployeeCount() RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE count INT;</span><br><span class="line">    SELECT COUNT(*) INTO count FROM employees;</span><br><span class="line">    RETURN count;</span><br><span class="line">END;</span><br><span class="line"># 使用存储函数</span><br><span class="line">SELECT GetEmployeeCount();</span><br></pre></td></tr></table></figure></blockquote><h2 id="存储函数的优点？"><a href="#存储函数的优点？" class="headerlink" title="存储函数的优点？"></a>存储函数的优点？</h2><blockquote><ol><li><strong>代码重用</strong>：存储函数可以在多个查询和存储过程中被调用，实现代码的重用，提高开发效率和维护性。</li><li><strong>扩展性</strong>：存储函数可以通过自定义函数来增强数据库的功能，满足特定的业务需求。</li></ol></blockquote><h2 id="存储函数的缺点？"><a href="#存储函数的缺点？" class="headerlink" title="存储函数的缺点？"></a>存储函数的缺点？</h2><blockquote><ol><li><strong>性能影响</strong>：存储函数可能对数据库性能产生一定的影响。每次调用存储函数都需要与数据库进行交互，这会增加数据库的负载和响应时间。如果存储函数逻辑复杂或对大量数据进行操作，可能导致性能下降。</li><li><strong>难以调试</strong>：存储函数通常在查询语句中直接使用，而不像存储过程那样可以单独执行和调试。因此，在调试存储函数时可能需要通过调试整个查询语句来定位问题。</li></ol></blockquote><h2 id="存储过程与存储函数的区别？"><a href="#存储过程与存储函数的区别？" class="headerlink" title="存储过程与存储函数的区别？"></a>存储过程与存储函数的区别？</h2><blockquote><p>存储过程和存储函数的区别主要有以下几点：</p><ol><li><strong>返回值类型</strong>：存储过程可以没有返回值或者返回多个结果集；存储函数必须返回一个标量值，如一个数字、一个字符串等。</li><li><strong>调用方式</strong>：存储过程使用CALL语句进行调用，而存储函数可以在SELECT语句中直接使用。</li><li><strong>参数传递方式</strong>：存储过程可以接收输入参数、输出参数和输入输出参数；而存储函数只能接收输入参数，不能有输出参数或输入输出参数。</li><li><strong>使用场景</strong>：存储过程适合于执行一系列复杂的数据库操作和事务处理，通常用于封装常用的业务逻辑；存储函数适合于进行计算和数据处理，并且可以方便地嵌入到SQL语句中使用。</li></ol></blockquote><h2 id="共用表表达式（CTE）是什么？"><a href="#共用表表达式（CTE）是什么？" class="headerlink" title="共用表表达式（CTE）是什么？"></a>共用表表达式（CTE）是什么？</h2><blockquote><p>公用表表达式（通用表表达式）简称为CTE（Common Table Expressions）是一种在SQL语句中定义临时查询结果的结构。</p><p>共用表表达式（CTE）是一种在SQL查询中创建临时结果集的方法，可以提高查询的可读性、重用性和性能，并且支持递归查询。可以理解成一个可以复用的子查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># CTE语法</span><br><span class="line">with CTE名称 </span><br><span class="line">as (子查询) </span><br><span class="line">select|delete|update 语句;</span><br><span class="line"># 使用子查询实现需求</span><br><span class="line">select * from users where user_id in (select distinct user_id from user_info)</span><br><span class="line"># 使用CTE实现需求</span><br><span class="line">with testCTE</span><br><span class="line">as (select distinct user_id from user_info)</span><br><span class="line">select * from users join test on user.user_id = test.user_id;</span><br></pre></td></tr></table></figure></blockquote><h2 id="EXISTS和IN的区别？"><a href="#EXISTS和IN的区别？" class="headerlink" title="EXISTS和IN的区别？"></a>EXISTS和IN的区别？</h2><blockquote><p>EXISTS 用于检查子查询是否返回结果，而 IN 用于检查某个值是否存在于给定的列表或子查询中。</p><ul><li><p><strong>EXISTS</strong>：是一个条件表达式，返回一个布尔值（true或false），用于检查子查询是否返回结果。</p></li><li><p><strong>IN</strong>：是一个比较运算符，返回一个布尔值（true或false），用于检查某个值是否存在于给定的列表或子查询中。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 检查子查询是否返回结果</span><br><span class="line">SELECT column1 </span><br><span class="line">FROM table1 </span><br><span class="line">WHERE EXISTS (</span><br><span class="line">    SELECT column2 </span><br><span class="line">    FROM table2 </span><br><span class="line">    WHERE condition</span><br><span class="line">);</span><br><span class="line"># 检查某个值是否存在于给定的列表或子查询中</span><br><span class="line">SELECT column1 </span><br><span class="line">FROM table1 </span><br><span class="line">WHERE column2 IN (value1, value2, value3);</span><br></pre></td></tr></table></figure></blockquote><h2 id="UNION和UNION-ALL的区别？"><a href="#UNION和UNION-ALL的区别？" class="headerlink" title="UNION和UNION ALL的区别？"></a>UNION和UNION ALL的区别？</h2><blockquote><p>他们都可以将两个查询的数据结合起来，区别就是union会去除并排序，UNION ALL不去重也不排序</p></blockquote><h2 id="MySQL如何做分页？"><a href="#MySQL如何做分页？" class="headerlink" title="MySQL如何做分页？"></a>MySQL如何做分页？</h2><blockquote><p>limit 起始索引,每页条数</p><p>起始索引 &#x3D;（页码数-1） * 每页条数</p></blockquote><h2 id="如何将一张表的部分数据更新到另一张表？"><a href="#如何将一张表的部分数据更新到另一张表？" class="headerlink" title="如何将一张表的部分数据更新到另一张表？"></a>如何将一张表的部分数据更新到另一张表？</h2><blockquote><p>步骤1：创建目标表</p><p>步骤2：复制源表的结构</p><p>步骤3：插入源表的数据</p><p>步骤4：更新目标表的数据</p></blockquote><h2 id="Where和Having区别？"><a href="#Where和Having区别？" class="headerlink" title="Where和Having区别？"></a>Where和Having区别？</h2><blockquote><p><code>WHERE</code>和<code>HAVING</code>是SQL中的两个不同的子句，用于在查询中进行条件筛选和过滤。</p><ul><li><strong>执行时机</strong>：where用于在分组之前进行条件筛选，不满足where条件则不参与分组；having用于在分组之后对结果进行过滤</li><li><strong>过滤条件有聚合函数</strong>：如果过滤条件中有聚合函数，过滤条件必须声明在having中，因为where不能使用聚合函数。</li><li><strong>过滤条件无聚合函数</strong>：如果过滤条件中没有聚合函数，则此过滤条件声明在where中或having中都可以，但建议声明在where中，因为where的执行效率要高于having</li><li><strong>执行顺序</strong>：where &gt; 聚合函数 &gt; having</li></ul></blockquote><h1 id="数据库设计相关"><a href="#数据库设计相关" class="headerlink" title="数据库设计相关"></a>数据库设计相关</h1><h2 id="数据库设计的三范式是什么？"><a href="#数据库设计的三范式是什么？" class="headerlink" title="数据库设计的三范式是什么？"></a>数据库设计的三范式是什么？</h2><blockquote><p>数据库设计的三范式（3NF）是一组规则，用于规范化关系型数据库中的数据结构。</p><ul><li><strong>第一范式</strong>：确保每个列必须具有原子性，都不可以再拆分。目的是消除数据项的重复和复杂性，使数据结构更清晰和易于操作。</li><li><strong>第二范式</strong>：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。目的是消除部分依赖，防止数据冗余和更新异常，提高数据的一致性和完整性。</li><li><strong>第三范式</strong>：在第二范式的基础上，非主键列不依赖于其他非主键，只依赖于主键。目的是消除传递依赖，减少数据冗余和不一致性，提高数据的规范性和灵活性。</li></ul></blockquote><h2 id="什么是范式和反范式？"><a href="#什么是范式和反范式？" class="headerlink" title="什么是范式和反范式？"></a>什么是范式和反范式？</h2><blockquote><p>范式和反范式都各自有其优缺点，具体应该根据业务需求和数据库性能等方面进行权衡，选择合适的数据设计方案。</p><ul><li><strong>范式（Normalization）</strong>：通过减少数据的重复和冗余来提高数据库的性能、可靠性和扩展性。范式的目标是使数据表符合特定的标准形式，也就是所谓的“范式”。</li><li><strong>反范式（Denormalization）</strong>：通过增加数据冗余来提高数据库的性能、可靠性和可扩展性。反范式的目标是尽量减少数据表之间的关联操作，使查询更快速、简单和直接。</li></ul></blockquote><h2 id="MySQL有哪数据类型？"><a href="#MySQL有哪数据类型？" class="headerlink" title="MySQL有哪数据类型？"></a>MySQL有哪数据类型？</h2><blockquote><p>字符数据类型：</p><ul><li><strong>CHAR</strong>：固定长度字符类型。</li><li><strong>VARCHAR</strong>：可变长度字符类型。</li></ul><p>整数数据类型：</p><ul><li><strong>INT</strong>：整数类型，占用4字节。</li><li><strong>BIGINT</strong>：大整数类型，占用8字节。</li><li>SMALLINT：小整数类型，占用2字节。</li></ul><p>浮点数数据类型：</p><ul><li><strong>FLOAT</strong>：单精度浮点数类型。</li><li><strong>DOUBLE</strong>：双精度浮点数类型。</li></ul><p>日期&#x2F;时间数据类型：</p><ul><li><strong>DATE</strong>：日期类型，格式为’YYYY-MM-DD’。</li><li><strong>TIME</strong>：时间类型，格式为’HH:MM:SS’。</li><li><strong>DATETIME</strong>：日期和时间类型，格式为’YYYY-MM-DD HH:MM:SS’。</li><li><strong>TIMESTAMP</strong>：时间戳类型，记录从1970-01-01 00:00:00到当前时间的秒数。</li></ul><p>二进制和文本数据类型：</p><ul><li><strong>BLOB</strong>：二进制大对象类型，用于存储二进制数据。</li><li><strong>TEXT</strong>：文本类型，用于存储大量的字符数据。</li></ul></blockquote><h2 id="表中主键为什么要设置自增？"><a href="#表中主键为什么要设置自增？" class="headerlink" title="表中主键为什么要设置自增？"></a>表中主键为什么要设置自增？</h2><blockquote><p>在MySQL表中，设置主键为自增具有以下几个好处：</p><ul><li><strong>保证了唯一性</strong>：每次插入新记录时，数据库会自动分配一个比之前最大主键值更大的值，从而保证主键的唯一性，避免了主键冲突。</li><li><strong>提高插入效率</strong>：自增ID在插入数据时会按照顺序递增，插入新数据时会直接在表的末尾添加，不会造成数据的移动和调整（减少了页分裂和页合并），能够提高插入效率。使用UUID和雪花算法生成的ID无序，可能导致页分裂和页合并等性能问题。</li><li><strong>快速定位和检索</strong>：Innodb中主键一定是聚集索引，聚集索引下的数据记录是根据ID排序存储，主键索引的有序性使得范围查询、排序和连接等操作更加高效。</li></ul></blockquote><h2 id="主键使用自增-ID-还是-UUID？"><a href="#主键使用自增-ID-还是-UUID？" class="headerlink" title="主键使用自增 ID 还是 UUID？"></a>主键使用自增 ID 还是 UUID？</h2><blockquote><p>对于 MySQL 数据库的主键选择，推荐使用自增 ID</p><ul><li><strong>插入效率</strong>：自增ID在插入数据时会按照顺序递增，插入新数据时会直接在表的末尾添加，不会造成数据的移动和调整（减少了页分裂和页合并），能够提高插入效率。使用UUID和雪花算法生成的ID无序，可能导致页分裂和页合并等性能问题。</li><li><strong>存储空间</strong>：整型的自增 ID 占用的存储空间相对较小，通常为 4 字节或 8 字节，而 UUID 类型通常需要占用 16 字节。</li><li><strong>数据排序和分页查询</strong>：自增 ID 的顺序性使得数据按照插入顺序进行物理排序，方便执行范围查询和分页操作。</li><li><strong>避免精度损失问题</strong>：前端可以接收的长整型数据（number）限制为16位，如果后端ID大于这个限制，那么在传递给前端时可能会丢失其中的一部分数据。使用UUID和雪花算法生成的ID一般会超过16位，导致前端精度损失问题，而自增主键可以选择适当的整数类型（如INT）作为自增主键，确保其长度不超过16位，避免精度损失问题。</li><li><strong>易用性</strong>：使用自增主键在插入新数据时，不需要显式指定主键的值，数据库会自动为其生成一个唯一的自增 ID。而使用UUID需要使用工具类生成然后显式插入。</li></ul></blockquote><h2 id="NULL和空字符串””的区别？"><a href="#NULL和空字符串””的区别？" class="headerlink" title="NULL和空字符串””的区别？"></a>NULL和空字符串””的区别？</h2><blockquote><ul><li><strong>本质区别</strong>：<code>NULL</code> 代表一个未知或不适用的值，而字符串<code>&#39;&#39;</code>的是一个具体的值</li><li><strong>空间占用</strong>：<code>NULL</code> 需要占用空间；空字符串<code>&#39;&#39;</code>的长度是 0，不占用空间</li></ul></blockquote><h2 id="字段为什么要求定义为-NOT-NULL？"><a href="#字段为什么要求定义为-NOT-NULL？" class="headerlink" title="字段为什么要求定义为 NOT NULL？"></a>字段为什么要求定义为 NOT NULL？</h2><blockquote><p><strong>占用空间</strong>：存储<code>NULL</code>需要占用空间</p><p><strong>聚合函数不准确</strong>：使用聚合函数的时候会忽略<code>NULL</code>值，例如<code>count(列名)</code>是对表中非<code>NULL</code>的列进行统计</p><p><strong>索引性能</strong>：由于<code>NULL</code>值可能分布在不同的记录中，索引的选择性可能会降低，从而影响查询的效率。</p></blockquote><h2 id="固定长度的字符串应该什么数据类型存储？"><a href="#固定长度的字符串应该什么数据类型存储？" class="headerlink" title="固定长度的字符串应该什么数据类型存储？"></a>固定长度的字符串应该什么数据类型存储？</h2><blockquote><p>推荐使用CHAR类型，可以节省空间且提高检索效率</p></blockquote><h2 id="CHAR-和-VARCHAR-的区别？"><a href="#CHAR-和-VARCHAR-的区别？" class="headerlink" title="CHAR 和 VARCHAR 的区别？"></a>CHAR 和 VARCHAR 的区别？</h2><blockquote><p>CHAR和VARCHAR是MySQL中常见的字符数据类型，它们之间有以下区别：</p><ul><li><strong>字符串长度</strong>：CHAR是固定长度的字符类型，它会在存储时按照定义的长度进行填充；VARCHAR是可变长度的字符类型，它只会占用实际存储的字符串长度所需的空间。</li><li><strong>存储空间</strong>：CHAR的存储空间始终等于定义的长度乘以每个字符的字节数；VARCHAR的存储空间则取决于实际存储的字符串长度</li><li><strong>空格处理</strong>：当存储CHAR类型的数据时，MySQL会自动在字符串后面填充空格，以保持字段长度的一致性。而VARCHAR类型则不会自动填充空格。</li><li><strong>查询性能</strong>：CHAR类型通常略优于VARCHAR类型，因为CHAR是固定长度的，查询引擎可以更好地优化查询计划。然而，在大多数实际场景中，这种性能差异并不明显。</li></ul></blockquote><h2 id="CHAR-10-和-VARCHAR-10-的区别？"><a href="#CHAR-10-和-VARCHAR-10-的区别？" class="headerlink" title="CHAR(10) 和 VARCHAR(10) 的区别？"></a>CHAR(10) 和 VARCHAR(10) 的区别？</h2><blockquote><p>CHAR(10) 和 VARCHAR(10) 的区别在于存储方式和占用的存储空间</p><ul><li><strong>CHAR(10)</strong> ：如果定义一个CHAR(10)字段并插入一个长度为5的字符串，它将被存储为长度为10的字符串(5个字符+5个空格)</li><li>**VARCHAR(10)**：如果定义一个VARCHAR(10)字段并插入一个长度为5的字符串，它将只占用5个字符的存储空间。</li></ul></blockquote><h2 id="CHAR-和-VARCHAR-如何选择？"><a href="#CHAR-和-VARCHAR-如何选择？" class="headerlink" title="CHAR 和 VARCHAR 如何选择？"></a>CHAR 和 VARCHAR 如何选择？</h2><blockquote><p>选择使用CHAR还是VARCHAR主要取决于长度是否确定：</p><ul><li><strong>字段长度确定</strong>：如果字符串长度是固定的，并且所有值都确保具有相同的长度，可以使用CHAR。比如电话号码等固定长度的数据，可以提高存储效率和查询性能。</li><li><strong>字段长度不确定</strong>：在不能确定字段需要多少字符时，可以使用 VARCHAR。由于VARCHAR只占用实际数据所需的空间，可以避免浪费额外的存储空间。</li></ul></blockquote><h2 id="Text-与-Blob-的区别？"><a href="#Text-与-Blob-的区别？" class="headerlink" title="Text 与 Blob 的区别？"></a>Text 与 Blob 的区别？</h2><blockquote><p>Text和Blob是用于存储大文本数据和二进制数据的数据类型，它们之间的区别如下：</p><ol><li><strong>数据类型</strong>：Text类型用于存储文本数据，Blob类型用于存储二进制数据，例如图像、音频或视频文件。</li><li><strong>存储方式</strong>：Text类型存储数据时会进行对字符串的编码操作，通常使用字符集（如UTF-8）来编码文本数据。而Blob类型存储数据时不对其进行编码，直接以二进制形式存储。</li><li><strong>查询和检索</strong>：Text类型支持文本处理操作，可以使用各种字符串函数和模式匹配进行查询和检索。而Blob类型一般不能直接进行字符串处理操作，需要通过应用程序进行解析和处理。</li><li><strong>存储空间</strong>：在大多数数据库中，Text类型通常需要占用较多的存储空间，因为它存储的是经过编码的文本数据。而Blob类型通常只占用实际二进制数据所需的存储空间。</li><li><strong>索引和排序</strong>：Text类型可以使用索引并进行排序，可以在查询时利用索引提高性能。而Blob类型一般不适合建立索引，也无法进行排序操作。</li></ol></blockquote><h2 id="Datetime和Timestamp的区别？"><a href="#Datetime和Timestamp的区别？" class="headerlink" title="Datetime和Timestamp的区别？"></a>Datetime和Timestamp的区别？</h2><blockquote><p>DateTime 类型没有时区信息，Timestamp 和时区有关。</p><ul><li><strong>Datetime</strong>：是固定时区的日期和时间类型，它包括年、月、日、时、分、秒和微秒。Datetime表示的时间不会随着时区的改变而改变。在MySQL数据库中，Datetime类型占用8个字节的存储空间。</li><li><strong>Timestamp</strong>：也是日期和时间类型，但它与时区无关，它是基于UTC时间（即格林威治标准时间）的。Timestamp存储的是自1970年1月1日以来经过了多少秒的时间戳。在MySQL数据库中，Timestamp类型占用4个字节的存储空间。</li></ul></blockquote><h2 id="什么是数据库约束？"><a href="#什么是数据库约束？" class="headerlink" title="什么是数据库约束？"></a>什么是数据库约束？</h2><blockquote><p>数据库约束用于保证数据库、表数据的完整性（正确性和一致性）</p></blockquote><h2 id="数据库的约束有哪些？"><a href="#数据库的约束有哪些？" class="headerlink" title="数据库的约束有哪些？"></a>数据库的约束有哪些？</h2><blockquote><p>常见的约束有如下几种：</p><ul><li><strong>主键约束</strong>：非空且唯一</li><li><strong>外键约束</strong>：定义表之间的关系</li><li><strong>默认约束</strong>：未指定值则采用默认值</li><li><strong>非空约束</strong>：不能为空</li><li><strong>唯一约束</strong>：不能重复</li><li><strong>检查约束</strong>：检查某个字段的值是否满足某一个条件</li></ul></blockquote><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="数据库的事务是什么"><a href="#数据库的事务是什么" class="headerlink" title="数据库的事务是什么?"></a>数据库的事务是什么?</h2><blockquote><p>事务就是将一系列的操作看做一个整体，要么全部执行成功，要么全部失败回滚，确保数据的完整性和一致性。</p></blockquote><h2 id="事务的四大特性（ACID）"><a href="#事务的四大特性（ACID）" class="headerlink" title="事务的四大特性（ACID）?"></a>事务的四大特性（ACID）?</h2><blockquote><p>ACID 是指事务的四个关键特性，分别是原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）：</p><ol><li><strong>原子性（Atomicity）</strong>：事务中的所有操作要么全部执行成功，要么全部回滚，不允许部分执行。</li><li><strong>一致性（Consistency）</strong>：事务在执行之前和执行之后，数据库都必须保持一致的状态。</li><li><strong>隔离性（Isolation）</strong>：多个事务同时执行时，每个事务都应该被隔离开来，互不干扰。一个事务的执行不应该受到其他事务的影响，以此来避免并发执行时可能出现的问题，例如脏读、不可重复读和幻读等。</li><li><strong>持久性（Durability）</strong>：一旦事务提交成功，对数据库的修改就是永久性的，即使系统发生故障或重启，数据也不会丢失。</li></ol></blockquote><h2 id="事务隔离级别有哪些"><a href="#事务隔离级别有哪些" class="headerlink" title="事务隔离级别有哪些?"></a>事务隔离级别有哪些?</h2><blockquote><p>MySQL 支持四种隔离级别：读未提交、读已提交、可重复读和串行化，不同的隔离级别提供了不同程度的数据隔离和并发控制能力，默认隔离级别是<code>可重复读（RR）</code>：</p><ul><li><strong>读未提交（RC）</strong>：允许一个事务读取另一个事务尚未提交的数据。可能会导致脏读（Dirty Read）。</li><li><strong>读已提交（RC）</strong>：保证一个事务只能读取到已经提交的数据。避免了脏读，但可能导致不可重复读（Non-Repeatable Read）。</li><li><strong>可重复读（RR）</strong>：确保事务执行期间多次读取同一数据时，得到的结果都是一致的。可以防止不可重复读，但是可能会出现幻读（Phantom Read）</li><li><strong>串行化（S）</strong>：将所有事务串行执行，确保了强一致性。可以避免脏读、不可重复读和幻读的问题，但也降低了并发性能，可能导致性能下降。</li></ul></blockquote><h2 id="默认隔离级别是什么？"><a href="#默认隔离级别是什么？" class="headerlink" title="默认隔离级别是什么？"></a>默认隔离级别是什么？</h2><blockquote><p>默认隔离级别是<code>可重复读（RR）</code>：确保事务执行期间多次读取同一数据时，得到的结果都是一致的。</p></blockquote><h2 id="隔离级别为什么使用RC不使用RR？"><a href="#隔离级别为什么使用RC不使用RR？" class="headerlink" title="隔离级别为什么使用RC不使用RR？"></a>隔离级别为什么使用RC不使用RR？</h2><blockquote><p>用隔离级别RC（Read Committed）而不是RR（Repeatable Read）可以在一定程度上提高并发性能。</p><ul><li><strong>死锁概率</strong>：在Repeatable Read（RR）隔离级别下，MySQL使用了间隙锁（Gap Lock）来解决幻读问题。间隙锁是在范围的间隙上设置的锁，防止其他事务在此范围内插入新数据。然而，这也增加了死锁的潜在风险。当多个事务同时尝试往同一个范围插入新数据时，可能会发生死锁情况，导致事务无法继续执行。而在Read Committed（RC）隔离级别下，并不使用间隙锁，因此避免了这种死锁风险。</li><li><strong>锁的颗粒度</strong>：在Repeatable Read隔离级别下，当条件列未命中索引时，MySQL会锁住整个表（Table Lock）。这是由于Repeatable Read要求创建一致的快照，以便保证读取的数据一致性。因此，为了防止其他事务修改已读取的数据，MySQL会锁住整个表，对于大型表来说，这可能导致性能问题。而在Read Committed隔离级别下，只锁住涉及到的行，而不是整个表，这减少了锁的粒度，提高了并发性能。</li></ul></blockquote><h2 id="并发事务是什么？"><a href="#并发事务是什么？" class="headerlink" title="并发事务是什么？"></a>并发事务是什么？</h2><blockquote><p>并发事务是指多个事务同时执行的情况，当多个用户或应用程序同时访问和操作数据库时，可能会发生并发事务，常见的并发事务的场景如下：</p><ul><li><strong>读-读</strong>：多个事务同时读取同一个数据，互不干扰，所以不会出现问题</li><li><strong>读-写</strong>：一个事务读取数据，另一个事务更新数据，可能出现脏读、不可重复读、幻读的问题</li><li><strong>写-写</strong>：多个事务同时更新同一个数据，可能出现数据丢失问题</li></ul></blockquote><h2 id="并发事务会带来哪些问题"><a href="#并发事务会带来哪些问题" class="headerlink" title="并发事务会带来哪些问题?"></a>并发事务会带来哪些问题?</h2><blockquote><p>事务并发可能会出现：脏读（Dirty read）、不可重复读（Non-repeatable read）、幻读（Phantom read）、数据丢失（Lost update）等问题</p><ul><li><strong>脏读（Dirty read）</strong>：一个事务读取到另一个事务尚未提交的数据，如果另一个事务回滚，则读取到的数据就是是无效或错误的。</li><li><strong>不可重复读（Non-repeatable read）</strong>：在同一个事务内，多次读取同一数据，由于其他事务的修改或删除操作，先后得到的结果不一致。</li><li><strong>幻读（Phantom read）</strong>：一个事务在多次查询同一范围内的数据时，由于其他事务的插入或删除操作，结果集中出现了新的行或者消失了原有的行</li><li><strong>数据丢失（Lost update）</strong>：两个或多个事务修改同一条记录，后提交的事务覆盖了先提交的事务的修改结果，导致覆盖丢失的情况。</li></ul></blockquote><h2 id="并发事务问题怎么解决？"><a href="#并发事务问题怎么解决？" class="headerlink" title="并发事务问题怎么解决？"></a>并发事务问题怎么解决？</h2><blockquote><p>处理事务并发问题，可以采取以下一些策略和技术，需要根据具体场景和需求选择适当的方法：</p><h2 id="方式一：使用事务隔离级别"><a href="#方式一：使用事务隔离级别" class="headerlink" title="方式一：使用事务隔离级别"></a>方式一：使用事务隔离级别</h2><p>使用事务隔离级别，选择适当的隔离级别来控制事务之间的相互影响。</p><ul><li><strong>读未提交</strong>：不能解决并发问题，可能导致脏读、不可重复读、幻读、数据丢失等问题。</li><li><strong>读已提交</strong>：可以解决脏读的问题，但仍可能出现不可重复读、幻读、数据丢失等问题。</li><li><strong>可重复读</strong>：可以解决脏读和不可重复读的问题，但仍可能出现幻读和数据丢失等问题。</li><li><strong>串行化</strong>：可以解决脏读、不可重复读、幻读和数据丢失等问题，但会牺牲并发性能。</li></ul><p>使用事务隔离级别的优缺点：</p><ul><li><strong>优点</strong>：可以灵活地处理并发问题，控制读写操作之间的隔离程度</li><li><strong>缺点</strong>：不同的隔离级别会在一定程度上影响并发性能。</li></ul><h2 id="方式二：使用锁机制来保护共享资源"><a href="#方式二：使用锁机制来保护共享资源" class="headerlink" title="方式二：使用锁机制来保护共享资源"></a>方式二：使用锁机制来保护共享资源</h2><p>确保在一个事务修改共享资源时，其他事务无法同时访问或修改该资源。</p><ul><li><strong>共享锁（读锁）</strong>：允许多个事务同时读取同一数据，但是不能进行写操作。适用于读多写少的情况，可以提高并发性能。</li><li><strong>排他锁（写锁）</strong>：在一个事务进行写操作时，其他事务不能进行任何读写操作。适用于写多读少的情况，保证数据的一致性。</li></ul><p>使用锁机制的优缺点：</p><ul><li><strong>优点</strong>：能够精确控制对数据的访问，保证高并发下的数据一致性和有效性。</li><li><strong>缺点</strong>：锁的粒度过大或者过小都容易导致死锁和饥饿等问题，加锁操作对于 CPU 的负载也是一个不可忽视的问题。</li></ul><h2 id="方式三：使用MVCC多版本并发控制"><a href="#方式三：使用MVCC多版本并发控制" class="headerlink" title="方式三：使用MVCC多版本并发控制"></a>方式三：使用MVCC多版本并发控制</h2><p>使用MVCC多版本并发控制，为每个事务创建快照，事务读取的是快照而不是实际数据。</p><ul><li><strong>读取操作</strong>：通过为每个事务创建快照，事务读取的是快照而不是实际数据，避免了并发修改导致的读取问题。</li><li><strong>更新操作</strong>：更新操作会生成新版本的数据，不会破坏已经存在的数据版本，旧版本的用户仍然可以读取到上一次提交前的数据。</li></ul><p>使用MVCC多版本并发控制的优缺点：</p><ul><li><strong>优点</strong>：读操作不会被写操作所阻塞，提高了并发性能，处理并发时能够降低锁的粒度，避免锁竞争和死锁等问题</li><li><strong>缺点</strong>：需要对于数据版本进行管理，因此会对存储空间带来一定的开销。</li></ul></blockquote><h2 id="什么是当前读与快照读？"><a href="#什么是当前读与快照读？" class="headerlink" title="什么是当前读与快照读？"></a>什么是当前读与快照读？</h2><blockquote><p>当前读（Current Read）和快照读（Snapshot Read）是数据库中的两种读取数据的方式。</p><ul><li><strong>当前读（锁定读）</strong>：读取的是记录数据的最新版本，<code>显式加锁的都是当前读</code>，保证其他事务不能并发的修改数据记录。</li><li><strong>快照读（普通读）</strong>：读取的是记录数据的可见版本（有旧的版本），<code>普通的select语句都是快照读</code>，不需要加锁，因此可以提高并发性能。</li></ul></blockquote><h2 id="MVCC是什么？"><a href="#MVCC是什么？" class="headerlink" title="MVCC是什么？"></a>MVCC是什么？</h2><blockquote><p>MVCC（Multi-Version Concurrency Control）是MySQL中一种多版本并发控制机制。它用于在数据库系统中实现并发访问和事务隔离。具体来说，MVCC允许并发执行的事务访问同一个数据表中的不同版本数据，而不会相互干扰或产生冲突。每个事务在读取数据时，会看到一个一致性的快照，并且不受其他事务的影响。这样可以提高并发性能和事务隔离级别。</p><ul><li><strong>读取操作</strong>：通过为每个事务创建快照，事务读取的是快照而不是实际数据，避免了并发修改导致的读取问题。</li><li><strong>更新操作</strong>：更新操作会生成新版本的数据，不会破坏已经存在的数据版本，旧版本的用户仍然可以读取到上一次提交前的数据。</li></ul></blockquote><h2 id="MVCC的实现原理？"><a href="#MVCC的实现原理？" class="headerlink" title="MVCC的实现原理？"></a>MVCC的实现原理？</h2><blockquote><p>MVCC的实现原理主要涉及以下几个关键点：</p><ul><li><strong>隐藏字段</strong>：在InnoDB存储引擎中，当创建一张表后，每一行数据都会增加额外的隐藏字段，例如事务ID和回滚指针。事务ID用于记录最后一次修改该数据行的事务ID，回滚指针用于指向该数据行的前一个版本。</li><li><strong>Undo Log版本链</strong>：MVCC使用Undo Log来实现数据行的版本管理。当事务对数据行进行修改时，不会直接在原始数据行上进行更新，而是将旧版本的数据保存到Undo Log中。Undo Log中的版本形成了一个链表，通过回滚指针连接。</li><li><strong>Read View读视图</strong>：每个事务在开始时会创建一个Read View，作为其读取数据的视图。Read View包含了事务开始时已提交的事务ID列表。当事务执行读取操作时，它会根据自己的事务ID与数据行的版本号进行比较，判断数据行是否对当前事务可见。</li><li><strong>可见性判断</strong>：如果数据行的版本号小于等于当前事务的事务ID，则表示该数据行是可见的。事务可以读取这个版本的数据，因为它是在事务开始之前创建的。如果数据行的版本号大于当前事务的事务ID，则表示该数据行是不可见的。这意味着该版本是在事务开始之后创建的，所以事务不能读取这个版本的数据。如果数据行的版本号在当前事务的事务ID范围内，但不包含在事务的读视图（Read View）中的已提交事务列表中，则表示该版本已被其他事务修改。事务需要查找Undo Log中的旧版本数据来保证读取的一致性。如果数据行的版本号在当前事务的事务ID范围内，并且在事务的读视图中的已提交事务列表中，则表示该版本是可见的。事务可以读取这个版本的数据。</li><li><strong>事务的提交和回滚</strong>：当事务提交时，它所做的修改操作将被应用到数据库中，并且新版本的数据行将变为当前版本。如果事务回滚，则将撤销事务所做的修改，并将数据行恢复到之前的版本。</li></ul></blockquote><h2 id="RC和RR隔离级别MVCC有什么不同？"><a href="#RC和RR隔离级别MVCC有什么不同？" class="headerlink" title="RC和RR隔离级别MVCC有什么不同？"></a>RC和RR隔离级别MVCC有什么不同？</h2><blockquote><p>在MySQL中，当事务进行快照读（SELECT）的时候，都会生成一个记录快照（Read View），用来做事务的可见性判断</p><ul><li><strong>读已提交（RC）隔离级别</strong>：事务中每次进行快照读（SELECT）时，都会创建一个新的记录快照（Read View）。这意味着每个快照读都可以看到其他事务已提交的最新数据，但是不能看到其他事务未提交的数据。</li><li><strong>可重复读（RR）隔离级别</strong>：事务中第一次快照读（SELECT）才创建记录快照（Read View），并在整个事务期间复用这个记录快照（Read View）。保证了事务期间对同一数据的多次快照读结果是一致的，即可重复读。</li></ul></blockquote><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="MySQL-数据库的锁有哪些？"><a href="#MySQL-数据库的锁有哪些？" class="headerlink" title="MySQL 数据库的锁有哪些？"></a>MySQL 数据库的锁有哪些？</h2><blockquote><p>按照实现方式划分，可以分为乐观锁和悲观锁</p><ul><li><strong>乐观锁</strong>：认为并发环境下数据不一定会被并发修改，因此只在提交时判断数据是否发生了变化</li><li><strong>悲观锁</strong>：认为数据在并发环境下总是会被修改，因此需要先加锁再操作数据</li></ul><p>按照按颗粒度划分，可以分为全局锁、表级锁、行级锁</p><ul><li><strong>全局锁</strong>：锁定数整个数据库</li><li><strong>表级锁</strong>：每次操作锁住整张表</li><li><strong>行级锁</strong>：每次操作锁住对应的行数据或行间隙</li></ul><p>按类型划分，可以分为共享锁（读锁）和排它锁（写锁）</p><ul><li><strong>共享锁（读锁）</strong>：用于保护读操作，多个事务都可以共享同一个锁</li><li><strong>排它锁（写锁）</strong>：用于保护写操作，同一时间只能有一个事务持有锁</li></ul><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-MySQL/MySQL锁的分类.png" style="zoom:35%"></blockquote><h2 id="乐观锁和悲观锁是什么？"><a href="#乐观锁和悲观锁是什么？" class="headerlink" title="乐观锁和悲观锁是什么？"></a>乐观锁和悲观锁是什么？</h2><blockquote><p>乐观锁和悲观锁是并发控制机制中的两种不同策略，用于处理多个事务同时访问和修改相同数据时可能引发的数据不一致性问题。</p><ul><li><strong>乐观锁</strong>：乐观锁认为并发环境下数据不一定会被并发修改，不需要借助数据库的锁机制，每次去拿数据的时候不会上锁，因此只在提交时判断数据是否发生了变化，如果没被修改过，说明只有自己操作过，正常去修改数据，如果被修改过，则不对数据进行修改，选择放弃、报错重试等策略</li><li><strong>悲观锁</strong>：认为数据在并发环境下总是会被修改，因此需要先加锁再操作数据，对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，会对该数据进行加锁，拿到锁才能进行操作，否则需要等待释放锁，直到拿到锁才能进行操作</li></ul></blockquote><h2 id="乐观锁和悲观锁怎么实现？"><a href="#乐观锁和悲观锁怎么实现？" class="headerlink" title="乐观锁和悲观锁怎么实现？"></a>乐观锁和悲观锁怎么实现？</h2><blockquote><h4 id="乐观锁的实现方式："><a href="#乐观锁的实现方式：" class="headerlink" title="乐观锁的实现方式："></a>乐观锁的实现方式：</h4><ol><li><strong>版本号机制</strong>：在表中添加一个版本号列，每次更新操作都会对版本号进行递增或修改。在更新时，比较当前版本号与最初读取时的版本号是否一致，如果一致则可以执行更新，否则表示有冲突。</li><li><strong>时间戳机制</strong>：在表中添加一个时间戳列，记录数据的最后修改时间。在更新时，比较当前时间戳与最初读取时的时间戳是否一致，如果一致就可以执行更新，否则表示有冲突。</li><li><strong>CAS（Compare and Swap）机制</strong>：某些数据库和编程语言提供了原子操作的支持，如MySQL的<code>SELECT ... FOR UPDATE</code>语句和Java的<code>AtomicReference</code>类，可以使用CAS操作来实现乐观锁。</li></ol><h4 id="悲观锁的实现方式："><a href="#悲观锁的实现方式：" class="headerlink" title="悲观锁的实现方式："></a>悲观锁的实现方式：</h4><ol><li><strong>数据库锁机制</strong>：通过数据库提供的锁机制实现，如行级锁、表级锁或页级锁等，对需要修改的数据先加锁，其他事务无法修改该数据，直到释放锁。</li><li><strong>应用锁</strong>：在应用层代码中使用锁机制来控制并发访问，例如使用Java中的<code>synchronized</code>关键字或分布式锁工具（如Redis的分布式锁）。</li><li><strong>锁表</strong>：直接对整个表进行加锁，确保任何事务在操作表时都无法进行并发修改。</li></ol></blockquote><h2 id="共享锁和排它锁是什么？"><a href="#共享锁和排它锁是什么？" class="headerlink" title="共享锁和排它锁是什么？"></a>共享锁和排它锁是什么？</h2><blockquote><p>共享锁（Shared Lock）和排它锁（Exclusive Lock）是数据库中常用的两种锁类型，用于控制并发事务对数据的访问。</p><ul><li><strong>共享锁</strong>：共享锁又称为读锁，如果加了读锁，当前事务可以读，但不能写，其他事物可以读，但写入会阻塞</li><li><strong>排它锁</strong>：排它锁又称为写锁，如果加了写锁，当前事务可读可写，其他事务不能读写</li></ul></blockquote><h2 id="全局锁是什么？"><a href="#全局锁是什么？" class="headerlink" title="全局锁是什么？"></a>全局锁是什么？</h2><blockquote><p>全局锁是对整个 MySQL 数据库实例加锁，添加全局锁后，数据库处于只读状态，增删改操作会处于阻塞状态，防止其他客户端对数据库中任何表进行修改操作，一般用于备份数据库或者调整数据库参数等场景。</p></blockquote><h2 id="表级锁是什么？"><a href="#表级锁是什么？" class="headerlink" title="表级锁是什么？"></a>表级锁是什么？</h2><blockquote><p>表锁是悲观锁机制中的一种实现方式，用于控制对整个表的并发访问。在表锁中，可以包括表级共享锁、表级排它锁、元数据锁和意向锁等不同类型。</p><ol><li><strong>表级共享锁（Table-level Shared Lock）</strong>： 表级共享锁允许多个事务同时对表进行读操作，但不允许任何事务进行写操作。也就是说，多个事务可以并发地共享读取表的数据，互不干扰。</li><li><strong>表级排它锁（Table-level Exclusive Lock）</strong>： 表级排它锁在某个事务对表进行写操作时，会阻塞其他事务对同一表的读写操作。也就是说，在有事务持有表级排它锁的情况下，其他事务无法对该表进行读取或写入操作，直到持有排它锁的事务释放锁。</li><li><strong>元数据锁（Metadata Lock）</strong>： 元数据锁用于保护数据库对象的元数据（如表结构、索引等）不被修改或删除。当一个事务正在对数据库对象进行修改时，会持有元数据锁，这样其他事务就无法对该对象进行同类的修改操作，以避免冲突。</li><li><strong>意向锁（Intent Lock）</strong>： 意向锁是表级锁的辅助锁，用于表示事务对表的意向操作。当一个事务请求对表加锁时，会先请求意向锁。意向锁分为意向共享锁和意向排它锁两种，用于协调不同事务对同一表的并发访问。</li></ol></blockquote><h2 id="表级锁有什么特点？"><a href="#表级锁有什么特点？" class="headerlink" title="表级锁有什么特点？"></a>表级锁有什么特点？</h2><blockquote><p>表级锁是对某个表加锁，防止其他客户端对该表进行修改操作有以下特点：</p><ol><li><strong>表锁定范围</strong>：对整个表进行锁定，意味着其他事务无法对该表进行读取或写入操作。可以确保数据的一致性和完整性，但也限制了其他并发访问的能力。</li><li><strong>锁粒度较大</strong>：表级锁是对整个表进行锁定，而不是对单个行或记录进行锁定。这意味着当一个事务持有表级锁时，其他事务无法对表的任何部分进行读取或写入操作，限制了并发访问的能力。</li><li><strong>锁开销较小</strong>：相比于行级锁，表级锁的管理开销较小。因为只需要维护少量的锁对象，减少了锁的粒度和数量，从而降低了锁开销。</li><li><strong>锁冲突少</strong>：由于表级锁的粒度较大，不同事务之间的冲突较少。只有当两个事务都需要修改同一张表时才会发生冲突。相比于行级锁，表级锁对冲突的潜在可能性较小。</li><li><strong>并发性较低</strong>：由于表级锁的粒度较大，当多个事务同时访问同一张表时，会出现阻塞和竞争的情况。当一个事务持有表级排它锁时，其他事务无法读取或修改表中的任何数据，直到排它锁被释放。这降低了并发性能。</li><li><strong>InnoDB支持</strong>：InnoDB 支持表锁和行锁，MyISAM 仅支持表锁，不支持行锁</li></ol></blockquote><h2 id="元数据锁是什么？"><a href="#元数据锁是什么？" class="headerlink" title="元数据锁是什么？"></a>元数据锁是什么？</h2><blockquote><p>元数据锁用于保护数据库对象的元数据（如表结构、索引等）不被修改或删除。当一个事务正在对数据库对象进行修改时，会持有元数据锁，这样其他事务就无法对该对象进行同类的修改操作，以避免冲突。</p></blockquote><h2 id="意向锁（Intent-Lock）"><a href="#意向锁（Intent-Lock）" class="headerlink" title="意向锁（Intent Lock）"></a>意向锁（Intent Lock）</h2><blockquote><p>意向锁是表级锁的辅助锁，用于表示事务对表的意向操作。当一个事务请求对表加锁时，会先请求意向锁。意向锁分为意向共享锁和意向排它锁两种，用于协调不同事务对同一表的并发访问。</p></blockquote><h2 id="行级锁是什么？"><a href="#行级锁是什么？" class="headerlink" title="行级锁是什么？"></a>行级锁是什么？</h2><blockquote><p>行锁是悲观锁机制中的一种实现方式，用于控制对数据库表中行级数据的并发访问。在行锁中，包括了行级共享锁、行级排它锁、插入意向锁、记录锁、间隙锁和临键锁等不同类型。</p><ol><li><strong>行级共享锁（Row-level Shared Lock）</strong>： 行级共享锁允许多个事务同时对一行数据进行读操作，但不允许进行写操作。多个事务可以并发地共享读取同一行的数据，互不干扰。</li><li><strong>行级排它锁（Row-level Exclusive Lock）</strong>： 行级排它锁在某个事务对一行数据进行写操作时，会阻塞其他事务对同一行的读写操作。也就是说，在有事务持有行级排它锁的情况下，其他事务无法对该行进行读取或写入操作，直到持有排它锁的事务释放锁。</li><li><strong>插入意向锁（Insert Intention Lock）</strong>： 插入意向锁是为了在同一时间内防止多个事务同时往一个页中插入行而引起的问题。当一个事务要往表中插入一行时，会请求插入意向锁。意向锁分为插入意向共享锁和插入意向排它锁，用于协调事务之间的并发插入操作。</li><li><strong>记录锁（Record Lock）</strong>： 记录锁是对单个记录或行进行的锁定操作，用于保护事务对行的读取或修改操作。当一个事务请求对某行记录加锁时，会获得记录锁，其他事务在此期间无法对该行记录进行写操作。</li><li><strong>间隙锁（Gap Lock）</strong>： 间隙锁是指在索引上的一个范围（间隙）上设置的锁，用于防止其他事务在这个范围内插入新的记录。可以防止幻读问题的发生。</li><li><strong>临键锁（Next-Key Lock）</strong>： 临键锁是一种结合记录锁和间隙锁的锁机制，主要用于解决幻读问题。当事务需要读取范围内的数据时，会对范围内的每个记录加上临键锁，确保其他事务无法插入新的记录或修改已有记录。</li></ol></blockquote><h2 id="行级锁有什么特点？"><a href="#行级锁有什么特点？" class="headerlink" title="行级锁有什么特点？"></a>行级锁有什么特点？</h2><blockquote><p>行锁也称为记录锁，只针对数据表中的一行数据加锁，是最小粒度的锁，有以下特点：</p><ol><li><strong>行锁定范围</strong>：只针对表中的单行或记录进行锁定，其他事务可以并发地访问表中的其他行数据。这提供了更高的并发性能，但也需要更细粒度的锁管理。</li><li><strong>锁粒度较小</strong>：行级锁是对表中的单行或记录进行锁定，而不是对整个表进行锁定。这意味着当一个事务持有行级锁时，其他事务仍然可以并发地访问表中的其他行数据，提高了并发性能。</li><li><strong>锁开销较大</strong>：相比于表级锁，行级锁的管理开销较大。需要为每一行数据维护锁状态和锁信息，增加了锁的粒度和数量，从而增加了锁管理的开销。</li><li><strong>锁冲突较多</strong>：由于行级锁的粒度较小，不同事务之间的冲突较多。当多个事务需要修改同一行数据时，会发生锁冲突，其中一些事务需要等待其他事务释放锁才能继续执行。</li><li><strong>并发性较高</strong>：由于行级锁的粒度较小，当多个事务同时访问同一张表时，它们可以同时对不同行进行读取或写入操作，减少了阻塞和竞争的情况，提高了并发性能。</li><li><strong>InnoDB支持</strong>：InnoDB 支持表锁和行锁，MyISAM 仅支持表锁，不支持行锁</li></ol></blockquote><h2 id="行锁是如何实现的？"><a href="#行锁是如何实现的？" class="headerlink" title="行锁是如何实现的？"></a>行锁是如何实现的？</h2><blockquote><p>在 MySQL 中，InnoDB 支持表锁和行锁，MyISAM 仅支持表锁，不支持行锁。</p><p>InnoDB 的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁。</p><p>如果在数据表中没有适当的索引，MySQL 在实现行锁时会使用基于表的锁来代替基于索引的行级锁。基于表的锁相比基于索引的行级锁需要更多的计算资源和时间。</p></blockquote><h2 id="插入意向锁是什么？"><a href="#插入意向锁是什么？" class="headerlink" title="插入意向锁是什么？"></a>插入意向锁是什么？</h2><blockquote><p>插入意向锁是为了在同一时间内防止多个事务同时往一个页中插入行而引起的问题。当一个事务要往表中插入一行时，会请求插入意向锁。意向锁分为插入意向共享锁和插入意向排它锁，用于协调事务之间的并发插入操作。</p></blockquote><h2 id="自增锁是什么？"><a href="#自增锁是什么？" class="headerlink" title="自增锁是什么？"></a>自增锁是什么？</h2><blockquote><p>AUTO_INCREMENT是一种用于创建自动增长数字主键列的机制，如果表中的主键列被设置为AUTO_INCREMENT，每当插入一个新记录时，MySQL会自动为该列分配一个比前一个最大值大1的数值。在多用户并发访问的情况下，使用AUTO_INCREMENT可能会导致锁竞争问题。为了避免这种情况，MySQL引入了自增锁机制，可以保证在同一个事务内插入的记录的AUTO_INCREMENT列的值是连续的。当一个事务进行插入操作时，MySQL会自动获取一个自增锁，任何其他尝试插入带有自增主键的表的操作都必须等待该锁被释放。自增锁只有在原始事务提交或回滚后，才会被释放</p></blockquote><h2 id="记录锁、间隙锁和临键锁是什么？"><a href="#记录锁、间隙锁和临键锁是什么？" class="headerlink" title="记录锁、间隙锁和临键锁是什么？"></a>记录锁、间隙锁和临键锁是什么？</h2><blockquote><p>记录锁、间隙锁和临键锁是数据库中用于并发事务控制的不同锁机制</p><ol><li><strong>记录锁（Record Lock）</strong>： 记录锁是对单个记录或行进行的锁定操作，用于保护事务对行的读取或修改操作。当一个事务请求对某行记录加锁时，会获得记录锁，其他事务在此期间无法对该行记录进行写操作。</li><li><strong>间隙锁（Gap Lock）</strong>： 间隙锁是指在索引上的一个范围（间隙）上设置的锁，用于防止其他事务在这个范围内插入新的记录。可以防止幻读问题的发生。</li><li><strong>临键锁（Next-Key Lock）</strong>： 临键锁是一种结合记录锁和间隙锁的锁机制，主要用于解决幻读问题。当事务需要读取范围内的数据时，会对范围内的每个记录加上临键锁，确保其他事务无法插入新的记录或修改已有记录。</li></ol></blockquote><h2 id="记录锁、间隙锁和临键锁的区别？"><a href="#记录锁、间隙锁和临键锁的区别？" class="headerlink" title="记录锁、间隙锁和临键锁的区别？"></a>记录锁、间隙锁和临键锁的区别？</h2><blockquote><p>记录锁、间隙锁和临键锁是数据库中用于并发事务控制的不同锁机制</p><ul><li><strong>记录锁（Record Lock）</strong>：锁定一个单行记录，其他事务无法修改或插入该行记录，用于保护这个记录的读写操作。</li><li><strong>间隙锁（Gap Lock）</strong>：锁定范围区间，不包含记录本身，用于防止并发事务在该范围内插入数据或更新已存在的数据。</li><li><strong>临键锁（Next-Key Lock）</strong>：临键锁是记录锁和间隙锁的结合形式，既锁定了记录，又锁定了记录之前的间隙，用于避免幻读问题。</li></ul></blockquote><h2 id="临键锁是如何防止幻读的发生？"><a href="#临键锁是如何防止幻读的发生？" class="headerlink" title="临键锁是如何防止幻读的发生？"></a>临键锁是如何防止幻读的发生？</h2><blockquote><p>默认情况下，InnoDB工作在可重复读（RR）隔离级别下，并且会以临键锁（Next-Key Lock）的方式对数据行进行加锁，以防止幻读的发生。</p><ol><li>当一个事务执行查询时，在查询过程中，InnoDB会为满足查询条件的索引记录加上行锁，以防止其他事务修改或删除这些记录。</li><li>同时，InnoDB还会对查询的索引记录两边的间隙加上间隙锁，以防止其他事务无法在这个范围内插入新的记录，避免了新插入记录导致幻读的问题。</li></ol></blockquote><h2 id="表锁与行锁的区别？"><a href="#表锁与行锁的区别？" class="headerlink" title="表锁与行锁的区别？"></a>表锁与行锁的区别？</h2><blockquote><p>在MySQL中，表锁（Table Lock）和行锁（Row Lock）是用于并发控制的两种不同的锁机制。</p><ul><li><strong>表锁</strong>：行锁定范围，表锁定范围，锁粒度较大，锁开销较小，锁冲突少，并发性较低。InnoDB 支持表锁和行锁，MyISAM 仅支持表锁，不支持行锁</li><li><strong>行锁</strong>：行锁定范围，锁粒度较小，锁开销较大、锁冲突较多，并发性较高。InnoDB 支持表锁和行锁，MyISAM 仅支持表锁，不支持行锁</li></ul></blockquote><h2 id="死锁是什么？"><a href="#死锁是什么？" class="headerlink" title="死锁是什么？"></a>死锁是什么？</h2><blockquote><p>死锁是指两个或多个事务相互等待对方释放资源而陷入无限等待的状态，从而导致数据库无法操作</p></blockquote><h2 id="锁等待是什么？"><a href="#锁等待是什么？" class="headerlink" title="锁等待是什么？"></a>锁等待是什么？</h2><blockquote><p>锁等待是指当一个事务获取了锁并开始执行时，其他事务需要等待上一个事务释放它的锁，才能占用相应的资源</p><p>在MySQL中，<code>innodb_lock_wait_timeout</code>参数用于控制InnoDB存储引擎获取锁的等待超时时间，单位是秒，默认值为50秒。当一个事务等待获取锁的时间超过了该参数指定的值，系统会自动回滚该事务，以避免长时间的锁等待可能导致的性能问题和数据不一致性。可以根据具体的业务需求合理地调整事务的等待超时时间。</p><ul><li><strong>较小的超时时间</strong>：可以增加锁冲突的风险，因为如果一个事务等待获取锁的时间超过了超时时间，那么它将被回滚并释放锁资源，这样可能会导致其他事务需要等待更长的时间才能获取锁。但是，较小的超时时间能够更快地释放锁资源，适用于高并发场景，可以减少长时间的锁等待，提高系统的并发性能。</li><li><strong>较大的超时时间</strong>：可以减少锁冲突，因为事务有更长的时间来等待获取锁，这样可以降低其他事务发生锁等待的概率。较大的超时时间适用于对数据一致性要求较高的场景，因为事务有更多的时间来等待其他事务释放锁，这样可以避免数据不一致的可能性。</li></ul></blockquote><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="MySQL的逻辑架构？"><a href="#MySQL的逻辑架构？" class="headerlink" title="MySQL的逻辑架构？"></a>MySQL的逻辑架构？</h2><blockquote><ul><li>第一层：处理客户端连接、授权认证，安全校验等。（连接器）</li><li>第二层：服务器server层，负责对SQL解析、优化、执行操作引擎等。（查询缓存、分析器、优化器、执行器）</li><li>第三层：存储引擎，负责MySQL中数据的存储和提取。（存储引擎）</li></ul></blockquote><h2 id="说说重要组件？"><a href="#说说重要组件？" class="headerlink" title="说说重要组件？"></a>说说重要组件？</h2><blockquote><p>MySQL的逻辑架构主要由以下几个组件组成：</p><p><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</p><p><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</p><p><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</p><p><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</p><p><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</p><p><strong>插件式存储引擎</strong>：主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎</p></blockquote><h2 id="SQL语句执行过程？"><a href="#SQL语句执行过程？" class="headerlink" title="SQL语句执行过程？"></a>SQL语句执行过程？</h2><blockquote><p>执行顺序：连接器→查询缓存→解析器→优化器→执行器→存储引擎</p><ol><li><strong>连接器建立连接</strong>：当客户端请求连接时，连接器会进行身份验证，并建立与服务器的连接。</li><li><strong>查询缓存</strong>：如果查询被缓存，那么直接返回缓存结果集，避免了后面的解析、优化和执行步骤。</li><li><strong>解析器生成执行计划</strong>：如果查询没有被缓存或者缓存被清空，那么解析器会对查询进行语法和语义分析，确定查询要执行的操作和涉及的表和列，根据表的结构信息生成一个初始的执行计划，包含哪些表需要连接、如何连接、使用哪些索引等。</li><li><strong>优化器优化执行计划</strong>：执行计划是根据查询语句生成的，可能并不是最优的执行方式，优化器的目标是找到最优的执行计划，并生成一个优化后的执行计划。</li><li><strong>执行器执行执行计划</strong>：执行器根据优化器生成的执行计划，调用存储引擎对数据进行操作。</li><li><strong>访问存储引擎返回结果</strong>：MySQL的存储引擎负责实际的数据存储和访问，根据执行计划，存储引擎会读取所需的数据块，并返回给MySQL服务器，最后MySQL将执行结果返回给客户端</li></ol><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-MySQL/MySQL内部的执行过程.png" style="zoom:50%"></blockquote><h2 id="什么是存储引擎？"><a href="#什么是存储引擎？" class="headerlink" title="什么是存储引擎？"></a>什么是存储引擎？</h2><blockquote><p>在MySQL中，存储引擎是负责数据存储和检索的组件，具有以下特点：</p><ul><li><strong>基于表</strong>：存储引擎是基于表级别的，而不是基于整个数据库。</li><li><strong>可插拔</strong>：存储引擎采用插拔式，不同的存储引擎具有不同的特性和功能，可以根据不同的需求和场景进行更换。</li></ul></blockquote><h2 id="常见的存储引擎有哪些？"><a href="#常见的存储引擎有哪些？" class="headerlink" title="常见的存储引擎有哪些？"></a>常见的存储引擎有哪些？</h2><blockquote><p>最常见的存储引擎如下：</p><ul><li><strong>InnoDB</strong>：支持事务，提供表级锁定、行级锁定和外键约束等功能</li><li><strong>MyISAM</strong>：不支持事务和外键约束，提供了表级锁定。</li><li><strong>Memory</strong>：将数据存储在内存中，访问速度较快，但系统奔溃数据会丢失，适用于需要快速读写的临时表或缓存。</li><li><strong>CSV</strong>：将数据存储为逗号分隔的值（CSV）格式文件，适用于导入&#x2F;导出数据。</li></ul></blockquote><h2 id="InnoDB的逻辑存储结构？"><a href="#InnoDB的逻辑存储结构？" class="headerlink" title="InnoDB的逻辑存储结构？"></a>InnoDB的逻辑存储结构？</h2><blockquote><p>InnoDB存储引擎的逻辑存储结构如下</p><ul><li><strong>表空间（多个段组成）</strong>：表空间是由多个段组成的逻辑存储单位，每个数据库至少有一个表空间，用于存储表和索引的数据</li><li><strong>段（数据段、索引段、回滚段等）</strong>：用于组织和存储数据，一个段由多个区组成。</li><li><strong>区（每个区大小为1M）</strong>：InnoDB存储引擎管理磁盘空间的基本单元。</li><li><strong>页（每个页大小默认为16KB）</strong>：数据和索引都以页的形式存储在磁盘上，并且按需从磁盘加载到内存中进行访问。</li><li><strong>行（存储了表的字段和两个隐藏字段）</strong>：行是表中的一个记录，也称为记录或元组。每一行存储了表的字段值以及两个隐藏字段，包括事务ID和回滚指针。</li></ul></blockquote><h2 id="InnoDB与MyISAM的区别？"><a href="#InnoDB与MyISAM的区别？" class="headerlink" title="InnoDB与MyISAM的区别？"></a>InnoDB与MyISAM的区别？</h2><blockquote><p>InnoDB和MyISAM是MySQL中两种不同的存储引擎，在 MySQL 5.5 版本之前，MySQL 的默认存储引擎是 MyISAM，从 MySQL 5.5 版本开始，MySQL 的默认存储引擎变为了 InnoDB，他们主要的区别如下：</p><ul><li><strong>事务支持</strong>：InnoDB支持事务；MyISAM不支持事务。</li><li><strong>锁定级别</strong>：InnoDB支持行级锁定和表级锁定，颗粒度更细，可以在并发访问时提供更好的性能和并发控制；MyISAM仅支持表级锁定，颗粒度更粗，可能会导致并发访问性能下降。</li><li><strong>外键支持</strong>：InnoDB支持外键约束；MyISAM不支持外键约束。</li><li><strong>索引方式</strong>：InnoDB支持聚集索引和非聚集索引；而MyISAM仅支持非聚簇索引。</li><li><strong>磁盘文件</strong>：InnoDB的磁盘文件包括<code>*.frm</code>和<code>*.ibd</code>两个文件，其中<code>*.frm</code>文件存放表的结构定义信息，<code>*.ibd</code>文件存放表中的数据和索引信息。而MyISAM的磁盘文件包括<code>*.frm</code>、<code>*.MYD</code>和<code>*.MYI</code>三个文件，其中<code>*.frm</code>文件存放表的结构定义信息，<code>*.MYD</code>文件存放表中的数据，<code>*.MYI</code>文件存放表的索引信息。</li><li><strong>使用场景</strong>：如果应用需要支持事务，保证数据的完整性和一致性，需要使用InnoDB；如果应用主要以读操作为主，对事务支持没有严格要求，可以考虑选择MyISAM；</li></ul></blockquote><h2 id="InnoDB一颗B-树可以存放多少数据？"><a href="#InnoDB一颗B-树可以存放多少数据？" class="headerlink" title="InnoDB一颗B+树可以存放多少数据？"></a>InnoDB一颗B+树可以存放多少数据？</h2><blockquote><p>在InnoDB中，一颗B+树可以存放多少行数据是由多个因素决定的，包括页大小，数据行大小以及树的层级等，一个三层的B+树大约可存2200万条数据。</p><ul><li><strong>页大小</strong>：在InnoDB的B+树结构中，数据是以页（Page）为单位进行存储和管理的，每个页的默认大小为16KB（16 * 1024字节）。</li><li><strong>数据行大小</strong>：每行数据的大小取决于所存储的列以及其数据类型，不同的列会占用不同的空间。假设一条数据占 1 kb 的空间，那么一个页可以存放 16 条这样的数据。</li></ul><p>每个B+树节点都对应一个页（page），这些页通常被称为数据页或索引页，它们存储了数据库中的索引和数据。</p><ul><li><strong>B+树叶子节点</strong>：每个叶子节点对应一个数据页，用来存放实际的数据行。假设一条数据占 1 kb 的空间，那么一个叶子节点可以存放 16 条这样的数据。</li><li><strong>B+树非叶子节点</strong>：每个非叶子节点都对应一个索引页，用来存放索引信息，由指向下一层地址的指针和主键值组成。指针大小在InnoDB源码中设置为6字节，如果主键是bigint类型，会占8个字节。</li></ul><p>根据上述信息，可以计算出一个非叶子节点（索引页）中可以存储的索引信息（主键+指针）数量：(16 * 1024) &#x2F; (6 + 8) ≈ 1170，就是说一个非叶子节点（索引页）中可以存放大约1170个指向下一层地址的指针，下一层大约有1170个叶子节点（数据页）。</p><p>综合上述信息，可以得出不同B+树层级的数据存储情况：</p><ul><li>如果B+树有1层，那么根节点就是叶子节点（数据页），最多能存放 <code>16</code> 条记录，大约占用<code>16 KB</code>空间；</li><li>如果B+树有2层，那么第一层是非叶子节点（索引页），指向下一层地址的指针有<code>1170</code>个，第二层都是叶子节点（数据页）会有<code>1170</code>个，最多能存放 <code>1170 × 16 = 18720</code> 条记录，大约占用<code>18.72 MB</code>空间；</li><li>如果B+树有3层，那么第二层是非叶子节点（索引页），指向下一层地址的指针有<code>1170 x 1170</code>个，第三层都是叶子节点（数据页）会有<code>1170 x 1170</code>个，最多能存放 <code>1170 x 1170 x 16 = 21902400</code> 条记录，大约占用<code>21.9 GB</code>空间；</li></ul></blockquote><h2 id="MySQL中常见的日志有哪些？"><a href="#MySQL中常见的日志有哪些？" class="headerlink" title="MySQL中常见的日志有哪些？"></a>MySQL中常见的日志有哪些？</h2><blockquote><p>在MySQL中，常见的日志包括以下几种：</p><ol><li><strong>错误日志（Error Log）</strong>：记录MySQL服务器启动和运行过程中的错误和警告信息。</li><li><strong>查询日志（Query Log）</strong>：记录所有客户端发起的查询语句，包括SELECT、INSERT、UPDATE、DELETE等操作。</li><li><strong>慢查询日志（Slow Query Log）</strong>：记录执行时间超过设定阈值的查询语句，用于分析和优化性能低下的查询。</li><li><strong>回滚日志（Undo Log）</strong>：undo log 记录了对数据进行修改操作的逆操作，主要用于实现事务的回滚和MVCC（多版本并发控制）。当事务执行过程中需要进行数据修改操作时，除了将修改写入数据文件，还会先将原始数据的副本写入 undo log 中。如果事务回滚或者其他需要还原数据的操作发生，可以利用 undo log 中的信息来撤销或还原事务所做的修改。</li><li><strong>重写日志（Redo Log）</strong>：redo log 是用于持久化数据修改操作的日志，主要用于崩溃恢复。当事务提交时，相关的数据修改操作被先记录在 redo log 中，然后再由后台线程将这些操作应用到磁盘上的数据文件中。在发生故障时，通过 redo log 可以重新执行未能完成的事务，从而达到数据的一致性和完整性。</li><li><strong>二进制日志（Binary Log）</strong>：记录数据库的更改操作，包括数据修改语句和表结构的变更，用于数据恢复、主从复制等场景。</li><li><strong>事务日志（Transaction Log）</strong>：记录每个事务的开始、提交和回滚等操作，在崩溃恢复和故障保护方面起到重要作用。</li><li><strong>中继日志（Relay Log）</strong>：在主从复制中，从服务器上记录主服务器上二进制日志的内容，用于实现数据同步。</li></ol></blockquote><h2 id="慢查询日志有什么用？"><a href="#慢查询日志有什么用？" class="headerlink" title="慢查询日志有什么用？"></a>慢查询日志有什么用？</h2><blockquote><p>用来记录在 MySQL 中执行时间超过指定时间的查询语句的日志，通常用于分析性能问题。通过慢查询日志，可以查找出哪些查询语句的执行时间较长，从而找到性能瓶颈所在。针对这些慢查询语句，可以进行优化操作</p></blockquote><h2 id="Undo-Log有什么用？"><a href="#Undo-Log有什么用？" class="headerlink" title="Undo Log有什么用？"></a>Undo Log有什么用？</h2><blockquote><p>回滚日志（Undo Log）记录了对数据进行修改操作的逆操作，主要用于实现事务的回滚和MVCC（多版本并发控制）。当事务执行过程中需要进行数据修改操作时，除了将修改写入数据文件，还会先将原始数据的副本写入 undo log 中。如果事务回滚或者其他需要还原数据的操作发生，可以利用 undo log 中的信息来撤销或还原事务所做的修改。</p></blockquote><h2 id="Redo-Log有什么用？"><a href="#Redo-Log有什么用？" class="headerlink" title="Redo Log有什么用？"></a>Redo Log有什么用？</h2><blockquote><p>重写日志（Redo Log）是用于持久化数据修改操作的日志，主要用于崩溃恢复。当事务提交时，相关的数据修改操作被先记录在 redo log 中，然后再由后台线程将这些操作应用到磁盘上的数据文件中。在发生故障时，通过 redo log 可以重新执行未能完成的事务，从而达到数据的一致性和完整性。</p></blockquote><h2 id="Binary-Log有什么用？"><a href="#Binary-Log有什么用？" class="headerlink" title="Binary Log有什么用？"></a>Binary Log有什么用？</h2><blockquote><p>二进制日志（Binary Log）记录了所有的 DDL语句和 DML语句，但不包括数据查询（SELECT、SHOW）语句。二进制日志常用于数据恢复、主从复制等场景。</p><ul><li><strong>数据修改记录</strong>：Binary Log 记录了数据库中的数据修改操作，包括插入、更新和删除等。每个数据修改操作都会被记录为一个事件（Event），并以二进制格式存储在 Binary Log 文件中。</li><li><strong>数据恢复</strong>：Binary Log 可以记录数据库中所有的数据修改操作，包括插入、更新和删除等。通过定期备份 Binary Log，可以实现对数据库的增量备份，当数据库出现故障或数据丢失时，可以使用备份的 Binary Log 进行数据恢复，减少数据损失。</li><li><strong>数据复制</strong>，Binary Log 是实现主从复制的核心组件。主服务器将所有的数据修改操作记录到 Binary Log 中，并将其发送给从服务器。从服务器通过解析和应用 Binary Log 中的数据修改操作，实现与主服务器的数据同步，达到数据复制和冗余的目的。</li></ul></blockquote><h2 id="Binary-Log和Redo-Log有什么区别？"><a href="#Binary-Log和Redo-Log有什么区别？" class="headerlink" title="Binary Log和Redo Log有什么区别？"></a>Binary Log和Redo Log有什么区别？</h2><blockquote><p>Binary Log是MySQL级别的日志，也就是说所有的存储引擎都会产生<code>bin log</code>，而<code>redo log</code>或者<code>undo log</code>事务日志只有<code>innoDB</code>存储引擎才有。</p></blockquote><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h2><blockquote><p>在MySQL中，索引是建立某个或多个列上的数据结构，用于提高数据库表的查询性能。它类似于书籍的目录，可以快速定位到特定数据的位置，减少了数据库的扫描和搜索工作。</p></blockquote><h2 id="索引在查询中起到什么作用？"><a href="#索引在查询中起到什么作用？" class="headerlink" title="索引在查询中起到什么作用？"></a>索引在查询中起到什么作用？</h2><blockquote><p>索引在查询中起到提高查询速度和减少磁盘IO次数的作用。数据是存储在磁盘上的，在查询时有索引和没索引的区别如下：</p><ul><li><strong>没有索引的查询</strong>：查询数据需要进行将整个表的数据加载到内存中，然后逐行进行检索和读取。这样会导致磁盘IO次数较多，查询速度较慢。</li><li><strong>有索引后的查询</strong>：查询数据可以利用索引的数据结构（如B+树）来快速定位到符合查询条件的数据行，而不再需要加载所有数据，大大减少了磁盘IO次数，从而提高了查询速度。</li></ul></blockquote><h2 id="索引的优缺点？"><a href="#索引的优缺点？" class="headerlink" title="索引的优缺点？"></a>索引的优缺点？</h2><blockquote><p>MySQL索引的优点包括：</p><ol><li><strong>提高查询性能</strong>：索引可以加快数据库的查询速度，特别是对于大型表和复杂查询，使用合适的索引可以显著提高查询效率。</li><li><strong>加速分组和排序</strong>：在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。</li><li><strong>加速连接</strong>：在进行表之间的连接操作时，使用索引可以加快连接的速度，减少查询时间。</li><li><strong>减少IO操作</strong>：索引可以帮助数据库引擎更快地定位需要查询的数据，从而减少了对硬盘的IO操作次数。</li><li><strong>保证数据的唯一性</strong>：通过在列上创建唯一索引，可以确保数据的唯一性，避免重复插入相同的值。</li></ol><p>索引也有以下缺点：</p><ol><li><strong>占用空间</strong>：索引需要额外的存储空间，特别是对于大型表和复杂索引，会增加存储成本。</li><li><strong>增删改操作的性能下降</strong>：当对表进行增、删、改操作时，索引需要随之更新，这会导致写操作的性能下降。</li><li><strong>索引维护开销</strong>：随着数据的增加和修改，索引需要进行维护，包括重新构建、重新组织等操作，这些维护操作会增加数据库的负载。</li><li><strong>索引选择困难</strong>：设计合适的索引需要根据具体的查询需求和数据特点进行综合考虑，选错索引可能导致查询性能下降。</li></ol></blockquote><h2 id="索引类型有哪些？"><a href="#索引类型有哪些？" class="headerlink" title="索引类型有哪些？"></a>索引类型有哪些？</h2><blockquote><p>根据索引的字段特性分类</p><ul><li><strong>普通索引</strong>：快速定位特定数据</li><li><strong>唯一索引</strong>：针对于表中主键创建的索引</li><li><strong>主键索引</strong>：索引列的值必须唯一，但允许有空值。</li><li><strong>全文索引</strong>：全文索引用于对文本类型的列进行全文搜索</li><li><strong>前缀索引</strong>：对索引列的前缀进行索引，可以节省索引存储空间</li><li><strong>空间索引</strong>：对空间数据类型的字段建立的索引</li></ul><p>根据索引的字段个数分类</p><ul><li><strong>单值索引</strong>：单值索引（也称为单列索引）一个索引只包含单个列，每张表可以创建多个单列索引。</li><li><strong>联合索引</strong>：联合索引（也称为复合索引或多列索引）一个索引包含多个列，每张表可以创建多个联合索引。</li></ul><p>根据索引的存储形式分类</p><ul><li><strong>聚集索引</strong>：聚集（簇）索引是基于表中的主键或唯一约束来创建的索引，每张表只能有一个。聚集索引将表的数据按照索引的顺序进行物理排序，数据行的存储顺序与索引的顺序一致。在InnoDB存储引擎中，使用主键索引就是创建了一个聚集索引。</li><li><strong>非聚集索引</strong>：非聚集索引（也称为辅助索引或二级索引）则是基于表中非主键列创建的索引，每张表可以有多个。非聚集索引保存了指向数据行的指针，而不是直接存储数据行本身，数据行的实际存储顺序与索引的顺序可能不一致。在InnoDB存储引擎中，辅助索引就是非聚集索引。</li></ul><p>根据数据结构分类</p><ul><li><strong>B-Tree索引</strong>：最常见的索引类型，采用B-Tree数据结构进行存储和检索。</li><li><strong>哈希索引</strong>：使用哈希表数据结构存储索引值，并通过哈希算法进行快速的查找。适用于精确匹配查询。</li><li><strong>全文索引</strong>：使用全文索引算法构建索引，支持文本类型的全文搜索。</li><li><strong>空间索引</strong>：采用特定的空间数据结构（如R-Tree、Quadtree等）对地理空间数据进行索引和查询。</li></ul></blockquote><h2 id="什么情况推荐使用索引？"><a href="#什么情况推荐使用索引？" class="headerlink" title="什么情况推荐使用索引？"></a>什么情况推荐使用索引？</h2><blockquote><p>推荐使用索引的情况：</p><ol><li><strong>频繁进行查询操作</strong>：当表中的数据需要频繁地进行查询时，可以考虑使用索引。索引可以加快查询速度，提高数据库系统的响应性能。</li><li><strong>数据量大或表较大</strong>：当表中的数据量较大或表本身很大时，使用索引可以显著减少查询的时间复杂度，提高查询效率。</li><li><strong>经常被用于连接操作</strong>：如果某一列经常被用于连接操作（如JOIN语句），在该列上创建索引可以加快连接操作的执行效率。</li><li><strong>主键约束唯一约束</strong>：通过在主键或唯一约束列上创建索引，可以确保数据的唯一性和完整性，防止重复数据的插入或更新。</li><li><strong>排序字段或分组字段</strong>：当需要对某一列进行排序或进行分组操作时，可以考虑在该列上创建索引。索引可以加速排序操作，并提高分组操作的效率。</li></ol></blockquote><h2 id="什么情况不推荐使用索引？"><a href="#什么情况不推荐使用索引？" class="headerlink" title="什么情况不推荐使用索引？"></a>什么情况不推荐使用索引？</h2><blockquote><p>不推荐使用索引的情况：</p><ol><li><strong>数据量较小或表结构简单</strong>：当数据量较小或表结构简单，并且查询操作并不频繁时，索引可能带来的性能提升相对较小，不值得额外的索引维护开销。</li><li><strong>经常进行大批量的插入、更新或删除操作</strong>：在进行大量的数据插入、更新或删除操作时，索引会增加额外的维护开销，降低这些操作的执行效率。</li><li><strong>列值重复率较高</strong>：如果要创建索引的列值重复率非常高，那么索引可能不会对查询性能产生显著影响，甚至可能导致查询变慢。</li><li><strong>不稳定的查询模式</strong>：如果查询模式频繁变化，每次查询所需的列或条件都不同，使用索引可能对性能产生负面影响，因为索引的选择可能不适用于不同的查询模式。</li></ol></blockquote><h2 id="索引的数据结构？"><a href="#索引的数据结构？" class="headerlink" title="索引的数据结构？"></a>索引的数据结构？</h2><blockquote><p>索引的数据结构常见的就两种，一种是b+树，另一种是哈希索引，默认是采用了b+树的数据结构</p><ol><li><strong>Hash索引</strong>：一种key value键值对结构，可能出现hash冲突，不支持范围查询和排序，不支持模糊查询，只适合在精确条件下的等值查询。</li><li><strong>B+树索引</strong>：全称为 <strong>多路平衡查找树</strong> ，B+ 树是InnoDB采用的索引结构，查询性能稳定。</li></ol></blockquote><h2 id="Hash索引和B-树索引的区别？"><a href="#Hash索引和B-树索引的区别？" class="headerlink" title="Hash索引和B+树索引的区别？"></a>Hash索引和B+树索引的区别？</h2><blockquote><p>Hash索引和B+树索引是两种常见的索引结构，它们在实现原理和适用场景上存在一些区别。</p><ul><li><strong>实现原理</strong>：Hash索引使用哈希算法将索引键映射到哈希表中，直接定位到对应数据行。B+树索引使用B+树数据结构，通过比较索引键的大小逐层定位到目标数据行。</li><li><strong>查询性能</strong>：Hash索引只支持等值查询，平均查找时间复杂度为O(1)。B+树索引则适用于各种类型的查询，平均查找时间复杂度为O(log N)。</li><li><strong>内存占用</strong>：Hash索引可能由于哈希冲突导致内存占用较高。B+树结构较为平衡，节点的利用率高，相对而言占用的内存较少。</li><li><strong>适用场景</strong>：Hash索引只支持等值查询，频繁的场景，不支持范围查询和排序。B+树索引适用于各种类型的查询，包括范围查询和排序。</li></ul></blockquote><h2 id="为什么使用B-树而不是B树？"><a href="#为什么使用B-树而不是B树？" class="headerlink" title="为什么使用B+树而不是B树？"></a>为什么使用B+树而不是B树？</h2><blockquote><p>MySQL选择B+树的一些重要原因：</p><ol><li><strong>减少磁盘 I&#x2F;O 操作</strong>：B-树叶子节点和非叶子节点都会存储数据，要找到具体的数据，需要遍历，磁盘I&#x2F;O操作更多；B+树只有叶子节点存储数据，要找到具体的数据，只需要扫一遍叶子结点，磁盘I&#x2F;O操作更少。</li><li><strong>顺序访问和范围查询</strong>：B树需要在内部节点和叶子节点之间频繁切换，难以实现顺序访问和范围查询；B+树的叶子节点通过链表连接，范围查询只需要遍历一段连续的叶子节点即可完成</li></ol></blockquote><h2 id="索引的失效情况？"><a href="#索引的失效情况？" class="headerlink" title="索引的失效情况？"></a>索引的失效情况？</h2><blockquote><p>索引的失效情况是指在数据库查询中，索引无法有效地加速查询操作，导致性能下降。以下是几种常见的索引失效情况：</p><ul><li>对索引列使用不等于匹配</li><li>对索引列使用IS NOT NULL</li><li>对索引列进行模糊查询like以%开头</li><li>对索引列进行运算操作</li><li>对索引列进行函数操作</li><li>使用运算符OR前后存在非索引的列</li><li>复合索引违反最左前缀法则</li></ul></blockquote><h2 id="怎么确定索引失效？"><a href="#怎么确定索引失效？" class="headerlink" title="怎么确定索引失效？"></a>怎么确定索引失效？</h2><blockquote><p>确定索引失效可以在查询语句前加上explin命令查看SQL的执行计划，主要关注执行计划中的以下参数：</p><ol><li><strong>Type</strong>：查询类型。如果Type显示为ALL，说明没有使用到索引，而是进行全表扫描，表示索引失效。</li><li><strong>Key</strong>：实际使用的索引列。如果Key为空，或者显示为NULL，表示索引未被使用。</li><li><strong>key_len</strong>：索引使用的字节数。如果key_len很小，可能意味着只使用了部分索引，导致索引失效。</li><li><strong>Extra</strong>：额外的信息。特别关注是否出现Using where、Using join buffer、Using temporary、Using filesort等关键词，这些都可能表示索引失效。</li></ol></blockquote><h2 id="什么是聚集索引和非聚集索引？"><a href="#什么是聚集索引和非聚集索引？" class="headerlink" title="什么是聚集索引和非聚集索引？"></a>什么是聚集索引和非聚集索引？</h2><blockquote><p>聚集索引（Clustered Index）：</p><ul><li>每张表只能有一个聚集索引。</li><li>聚集索引是基于表的主键或唯一约束创建的一种索引结构，决定了表中数据行的物理存储顺序。</li><li>叶子节点存储的是数据行本身，对于使用聚集索引的表，查询时可以通过聚集索引快速定位到所需的数据行。</li><li>对于频繁基于范围查询或顺序访问的操作性能好，因为相关的数据行存储在物理上相邻的位置。</li><li>在InnoDB存储引擎中，使用主键索引就是创建了一个聚集索引。</li></ul><p>非聚集索引（Non-clustered Index）：</p><ul><li>每张表可以有多个非聚集索引。</li><li>非聚集索引是基于表的非主键列或辅助索引创建的索引结构。</li><li>叶子节点存储的是指向数据行的指针，查询时先根据非聚集索引定位到数据行的位置，然后再通过指针走聚集索引回表查询找到实际的数据行。</li><li>对于快速定位和查找特定值或范围的查询性能更好，但在进行涉及大量数据行的查询时，可能需要额外的IO操作来获取实际的数据行。</li><li>在InnoDB存储引擎中，辅助索引就是非聚集索引。</li></ul></blockquote><h2 id="什么是联合索引？"><a href="#什么是联合索引？" class="headerlink" title="什么是联合索引？"></a>什么是联合索引？</h2><blockquote><p>联合索引（Composite Index）是指在数据库表中，通过组合多个字段创建的索引。它是由多列构成的索引，可以包含两个或更多的表列。</p></blockquote><h2 id="为什么使用联合索引？"><a href="#为什么使用联合索引？" class="headerlink" title="为什么使用联合索引？"></a>为什么使用联合索引？</h2><blockquote><p>使用联合索引的主要原因有以下几点：</p><ol><li>减少索引数量：通过将多个索引合并成一个联合索引，可以减少索引的数量，降低磁盘空间的消耗，并提高索引的更新和维护效率。</li><li>覆盖索引：使用联合索引可以实现覆盖索引，即索引本身包含了查询所需要的所有字段，不需要回表到数据页中查找，从而提高查询性能。</li></ol></blockquote><h2 id="什么是覆盖索引？"><a href="#什么是覆盖索引？" class="headerlink" title="什么是覆盖索引？"></a>什么是覆盖索引？</h2><blockquote><p>覆盖索引是指执行查询时，查询所需的数据可以直接从索引中获取，而无需去访问数据所在的表，覆盖索引不是一种索引结构，而是一种优化手段，用于提高查询性能。</p></blockquote><h2 id="为什么使用覆盖索引？"><a href="#为什么使用覆盖索引？" class="headerlink" title="为什么使用覆盖索引？"></a>为什么使用覆盖索引？</h2><blockquote><p>当使用了覆盖索引时，MySQL可以直接使用索引中的数据满足查询的需求，而无需回表读取实际的数据行。</p><ul><li><strong>不使用覆盖索引</strong>：查询非聚集索引时，先查询到指向数据行的指针，然后再通过指针走聚集索引回表查询找到实际的数据行。</li><li><strong>使用覆盖索引</strong>：查询非聚集索引时，通过索引索引值直接找到要查询字段的值，然后直接走聚集索引查询找到实际的数据行。</li></ul></blockquote><h2 id="什么是回表查询？"><a href="#什么是回表查询？" class="headerlink" title="什么是回表查询？"></a>什么是回表查询？</h2><blockquote><p>回表查询就是在使用非聚集索引查询数据时，在索引层面只能得到部分数据信息（例如主键或行指针），然后需要通过这些信息回到表中，利用聚集索引或堆结构找到对应的完整数据行。</p><ol><li>首先，通过非聚集索引找到满足查询条件的行指针或主键值。</li><li>根据行指针或主键值回到表中，参照聚集索引或堆结构来获取完整的数据行。</li><li>返回查询结果，包括满足查询条件的完整数据行。</li></ol></blockquote><h2 id="什么是最左前缀原则？"><a href="#什么是最左前缀原则？" class="headerlink" title="什么是最左前缀原则？"></a>什么是最左前缀原则？</h2><blockquote><p>最左匹配原则，就是在建立了联合索引的情况下，会优先从最边的索引，往右匹配，当遇到范围查询(&gt;、&lt;、between、like)就会停止匹配，后面的字段不会用到索引。</p></blockquote><h2 id="为什么要遵循最左匹配"><a href="#为什么要遵循最左匹配" class="headerlink" title="为什么要遵循最左匹配?"></a>为什么要遵循最左匹配?</h2><blockquote><p>不能遵循的话，查询就不走索引了，索引失效可能造成回表查询，影响效率。</p></blockquote><h2 id="什么是前缀索引？"><a href="#什么是前缀索引？" class="headerlink" title="什么是前缀索引？"></a>什么是前缀索引？</h2><blockquote><p>前缀索引是一种在数据库中用于优化查询效率的技术，它只对某一列的前缀部分建立索引，而不是对整个列进行索引。</p></blockquote><h2 id="为什么使用前缀索引？"><a href="#为什么使用前缀索引？" class="headerlink" title="为什么使用前缀索引？"></a>为什么使用前缀索引？</h2><blockquote><p>对于较长的列值或者包含大量不同值的列，完整索引可能会占用大量的存储空间和索引构建时间，而前缀索引则是通过仅使用列值的前缀来创建索引，从而减少索引的大小和构建时间，并且可以在一定程度上提高查询的性能。</p></blockquote><h2 id="什么是索引下推？"><a href="#什么是索引下推？" class="headerlink" title="什么是索引下推？"></a>什么是索引下推？</h2><blockquote><p>索引下推是一种数据库查询优化技术，可以在索引层面对查询条件进行处理，减少不必要的数据读取和处理（减少回表操作次数），提高查询性能。</p><p>假设我们有一个名为”users”的表，包含100万行数据，表中包含列：id、name、age，在该表上创建了一个索引idx_age（age）。我们想查询年龄大于等于30的用户记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id, name, age FROM users WHERE age &gt;= 30;</span><br></pre></td></tr></table></figure><p>没有使用索引下推时的查询过程：</p><ol><li>数据库引擎遍历非聚集索引idx_age，找到所有满足条件的索引项（age &gt;&#x3D; 30）对应的数据行的指针。</li><li>对于每个匹配的索引行，数据库引擎需要通过指针回表查找实际的数据行，存放到内存中。</li><li>在内存中对每一行数据，检查年龄是否大于等于30，并返回满足条件的记录结果给用户。</li></ol><p>使用了索引下推时的查询过程：</p><ol><li>数据库引擎遍历非聚集索引idx_age，找到满足条件的索引项（age &gt;&#x3D; 30）对应的数据行的指针。</li><li>对于每个匹配的索引行，数据库引擎需要通过指针回表查找实际的数据行，存放到内存中。</li><li>由于已经在索引层面过滤过，无需再对内存中的数据进行条件判断，直接返回满足条件的记录结果给用户。</li></ol></blockquote><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="谈谈你对数据库优化的经验？"><a href="#谈谈你对数据库优化的经验？" class="headerlink" title="谈谈你对数据库优化的经验？"></a>谈谈你对数据库优化的经验？</h2><blockquote><p>数据库优化是一个综合性的工作，需要从多个方面进行考虑和改进，以下是一些经验和技巧：</p><ul><li><strong>SQL语句的优化</strong>：编写高效的 SQL 语句是数据库优化的关键。</li><li><strong>索引的优化</strong>：索引可以加速查询操作，提高数据库的读取性能。确保常用查询条件的字段上有索引，并避免创建过多的索引，因为索引也会增加写入操作的开销。定期检查和更新索引的统计信息，以保持索引的最佳运行状态。</li><li><strong>表字段优化</strong>：合理设计表的字段，避免过多冗余字段或者不必要的字段。减少字段长度和使用合适的数据类型，以节省存储空间和提高查询速度。根据业务需求和数据特点，对字段进行垂直分割和水平分割，以降低对不必要数据的访问和IO开销。</li><li><strong>存储引擎优化</strong>：不同的存储引擎有不同的特点和适用场景。例如，InnoDB适合处理事务和并发性能，MyISAM适合读取密集型应用。根据具体需求选择合适的存储引擎，以获得更好的性能和可靠性。</li><li><strong>配置优化</strong>：数据库服务器的配置对性能有很大影响。根据硬件资源和应用需求，调整数据库的缓冲区大小、连接数限制、日志级别等参数。合理分配内存和磁盘空间，避免过度分配或不足的情况。</li><li><strong>硬件优化</strong>：数据库服务器的硬件配置可以对性能产生直接影响。增加内存容量可以提升查询性能，减少磁盘IO操作。使用专用的网络设备和存储设备也可以提升数据库的性能和可靠性。</li></ul></blockquote><h2 id="常见的查询优化"><a href="#常见的查询优化" class="headerlink" title="常见的查询优化?"></a>常见的查询优化?</h2><blockquote><ul><li><strong>避免使用SELECT * 查询</strong>：使用 SELECT * 会查询表中的所有列，包括不需要的列，这会增加数据传输量和内存消耗。明确指定需要查询的列可以减少不必要的资源消耗。</li><li><strong>避免使用不必要的DISTINCT去重</strong>：使用 SELECT DISTINCT 去重会增加查询的开销，因为它需要在结果集上执行排序和比较操作。如果不必要，尽量避免使用 DISTINCT，而是通过其他方式进行去重操作。</li><li><strong>避免使用不必要的ORDER BY排序</strong>：如果只关心查询结果的数据，而不需要按特定顺序排列，那么可以删除 ORDER BY 子句，提高查询性能。</li><li><strong>避免使用多个JOIN联表查询</strong>：多个 JOIN 联表查询会引入更多的关联和数据扫描成本。在实际应用中，可以考虑拆分查询进行优化，以减少联接操作的复杂性。</li><li><strong>避免使用子查询</strong>：子查询可能会执行多次，每次执行都会引入额外的开销。通过使用 JOIN 或临时表进行联接，可以将子查询转换为更高效的连接操作，从而提高查询性能。</li><li><strong>使用INNER JOIN代替LEFT JOIN或RIGHT JOIN</strong>：INNER JOIN 只返回匹配的行，而 LEFT JOIN 或 RIGHT JOIN 还会返回左表或右表中未匹配的行。如果不需要这些额外的数据，尽量使用 INNER JOIN，可以减少不必要的数据扫描和连接操作。</li><li><strong>使用WHERE替换HAVING子句</strong>：HAVING 子句用于对分组后的结果进行过滤，而 WHERE 子句用于对原始数据进行过滤。将过滤条件放在 WHERE 子句中可以减少分组的数据量，提高查询效率。</li><li><strong>使用UNION ALL代替UNION</strong>：UNION 操作会对结果集进行去重操作，而 UNION ALL 不会。如果不需要去重，可以使用 UNION ALL 替代 UNION，从而减少排序和比较的开销。</li><li><strong>使用LIMIT子句限制查询结果</strong>：LIMIT 子句允许你限制查询结果的数量。当只需要获取部分查询结果时，通过使用 LIMIT 可以减少数据传输和处理的开销。</li><li><strong>使用NOT EXISTS替代NOT IN</strong>：NOT IN子句和 NOT EXISTS 子句都可以用于子查询，判断某个值是否不存在。但是 NOT EXISTS 更高效，因为它只需要判断是否不存在结果，而不需要检索具体的值。</li><li><strong>使用EXISTS替代IN</strong>：IN 子句和 EXISTS 子句都可以用于子查询，判断某个值是否存在。但是 EXISTS 更高效，因为它只需要判断是否存在结果，而不需要检索具体的值。</li></ul></blockquote><h2 id="常见的插入优化"><a href="#常见的插入优化" class="headerlink" title="常见的插入优化?"></a>常见的插入优化?</h2><blockquote><ul><li><strong>批量插入</strong>：假如需要插入多条数据，可以使用多条 INSERT 语句一次性插入多条数据，减少与数据库的交互次数，提高效率</li><li><strong>使用事务</strong>：假如需要插入多条数据，可以将多个插入操作放在一个事务中，可以控制数据的一致性，同时也可以提高插入效率</li><li><strong>禁用索引</strong>：如果需要插入大量数据，而且这些数据并不需要立即查询，可以在插入前暂时禁用索引，插入完毕后再重新启用索引，可以提高插入效率</li><li><strong>使用LOAD DATA INFILE导入</strong>：如果数据源是外部文件，可以使用LOAD DATA INFILE命令可以高效地将外部文件中的数据导入到表中，这种方式比逐行插入更高效，但文件格式需要符合MySQL的要求。</li></ul></blockquote><h2 id="什么是页分裂与页合并？"><a href="#什么是页分裂与页合并？" class="headerlink" title="什么是页分裂与页合并？"></a>什么是页分裂与页合并？</h2><blockquote><p>页分裂（Page Split）和页合并（Page Merge）是数据库中常见的两种操作，用于管理表的物理存储结构。</p><ul><li><strong>页分裂</strong>：当一个表中需要插入新的行时，如果该表已经没有空闲的页可用于存储新行，则数据库系统会自动创建一个新的页，这个过程就是页分裂</li><li><strong>页合并</strong>：当一个表中已有的行被删除时，如果该页中已有的记录行数量小于页容量的一半，则数据库系统会将该页与邻近的页合并成一个新的页</li></ul></blockquote><h2 id="常见的表设计优化？"><a href="#常见的表设计优化？" class="headerlink" title="常见的表设计优化？"></a>常见的表设计优化？</h2><blockquote><ul><li><strong>使用合适的存储引擎</strong>：InnoDB支持事务和行级锁定，适用于事务处理；MyISAM适用于读写较少的情况。</li><li><strong>单表不要包含过多字段</strong>：当表的列过多时，会增加查询和写入的复杂度，并且会占用更多的磁盘空间。可以将相关的字段组织在一起，将不常用的字段拆分成其他表，以减少冗余和提高查询效率。</li><li><strong>禁止存储较大二进制数据</strong>：存储较大的二进制数据（如图片、音频等）可能会导致数据库表的膨胀，影响查询和更新的性能。</li><li><strong>正确选择合适的数据类型</strong>：选择合适的数据类型可以减少存储空间的占用并提高查询效率。</li><li><strong>主键使用自增ID</strong>：自增ID保证了主键的唯一性，避免了重复插入数据的情况；由于自增ID在插入数据时会按照顺序递增，插入新数据时会直接在表的末尾添加，不会造成数据的移动和调整（减少了页分裂和页合并），能够提高插入效率</li></ul></blockquote><h2 id="常见的索引优化？"><a href="#常见的索引优化？" class="headerlink" title="常见的索引优化？"></a>常见的索引优化？</h2><blockquote><p>通过合理选择字段添加索引、使用联合索引、避免过多索引以及定期维护和优化索引，可以最大程度地提高数据库的查询性能，并确保索引的有效性和一致性。</p><ol><li><strong>频繁访问的字段适合添加索引</strong>：通过为频繁使用的字段添加索引，可以加快查询操作的速度。这样可以减少数据库的扫描次数，提高查询效率。</li><li><strong>使用联合索引来覆盖查询</strong>：在某些情况下，单个索引无法满足复杂的查询需求。使用联合索引可以在一个索引中包含多个列，以便更好地支持复杂的查询操作。联合索引能够通过覆盖查询（Covering Index）的方式，直接从索引中获取所需数据，而不必再去查询表的行数据，从而提高查询性能。</li><li><strong>避免过多的索引</strong>：过多的索引会使数据库写操作的性能下降，并且会占用更多的存储空间。每个索引都需要维护和更新，因此过多的索引会增加数据库维护的成本。因此，在创建索引时，需要评估每个索引的必要性，并避免创建不必要的索引。</li><li><strong>维护索引并避免索引失效</strong>：随着数据的插入、更新和删除，索引的数据也会发生变化。为了保证索引的有效性和性能，需要定期维护索引。维护索引可以包括重建索引、重新组织索引等操作。此外，还需要避免使用不符合索引定义的查询，以免触发索引失效。</li></ol></blockquote><h2 id="有个SQL执行很慢怎么优化？"><a href="#有个SQL执行很慢怎么优化？" class="headerlink" title="有个SQL执行很慢怎么优化？"></a>有个SQL执行很慢怎么优化？</h2><blockquote><p>导致SQL执行慢的常见原因有SQL语句问题、索引失效、表数据过多、事务和锁问题：</p><ul><li><strong>SQL语句有问题</strong>：查询语句可能存在一些问题，例如写得太复杂、嵌套子查询过多，或者使用了不必要的函数和操作符，导致查询效率低下。可以通过重新设计查询语句，减少数据访问次数和计算量。</li><li><strong>SQL语句导致索引失效</strong>：查询语句的条件与索引列不匹配，导致数据库无法有效利用索引来加速查询。可以通过分析查询语句，调整查询条件，优化索引设计或创建新索引来提高查询性能。</li><li><strong>表数据过多</strong>：如果表中的数据量非常庞大，查询的执行时间就可能较长。可以考虑对表进行分区、分片或者使用分布式数据库来处理大量数据，将查询任务分散到多个节点上，以提高查询速度和并发性能。</li><li><strong>事务和锁问题</strong>：并发事务操作可能导致锁竞争，从而影响查询性能。当多个事务同时访问同一数据时，可能会发生锁等待的情况，导致查询执行变慢。可以考虑调整事务隔离级别，减少锁竞争，或者重新设计事务的逻辑，避免长时间占用锁资源。</li></ul><p>首先，需要找到这条执行慢的SQL，可以通过慢查询日志定位出执行效率比较低的SQL</p><p>然后，进一步分析是什么原因导致的，可以更好地了解问题所在，并采取相应的优化策略。</p><ul><li>通过 Show Profile 查看SQL执行信息分析 SQL 执行性能</li><li>通过 EXPLAIN 查看执行计划分析索引是否失效、全表扫描等问题</li></ul></blockquote><h2 id="说一说慢查询日志？"><a href="#说一说慢查询日志？" class="headerlink" title="说一说慢查询日志？"></a>说一说慢查询日志？</h2><blockquote><p>慢查询日志记录了所有执行时间超过指定参数的所有 SQL语句的日志，通过慢查询日志，就可以定位出执行效率比较低的SQL，从而有针对性的进行优化。</p></blockquote><h2 id="说一说怎样查看SQL执行信息"><a href="#说一说怎样查看SQL执行信息" class="headerlink" title="说一说怎样查看SQL执行信息?"></a>说一说怎样查看SQL执行信息?</h2><blockquote><p>在MySQL中，”Profile”是一个用于性能分析和调优的特殊功能。Profile允许捕获并分析查询语句的执行情况，以便确定潜在的性能问题和瓶颈。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看每一条SQL的耗时基本情况，结果的三个字段：查询的唯一标识符（Query_ID）查询的执行时间（Duration）被执行的查询语句（Query）</span><br><span class="line">show profiles;</span><br></pre></td></tr></table></figure></blockquote><h2 id="说一说执行计划？"><a href="#说一说执行计划？" class="headerlink" title="说一说执行计划？"></a>说一说执行计划？</h2><blockquote><p>每条SQL语句执行之前，都会先计算该SQL语句需要调用的相关资源，再决定该SQL语句是否要最终执行，该行为被称为“执行计划”。执行计划主要用于分析 SQL 语句的执行情况，包括索引的使用情况、表的访问方式、连接操作的顺序等，并不实际执行查询。MySQL 提供了一个内置的查询执行计划分析工具，称为 EXPLAIN。使用EXPLAIN查看 SQL 语句的执行计划，语法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain SQL语句;</span><br></pre></td></tr></table></figure><p>主要关注执行计划中的以下参数：</p><ol><li><strong>Type</strong>：查询类型。如果Type显示为ALL，说明没有使用到索引，而是进行全表扫描，表示索引失效。</li><li><strong>Key</strong>：实际使用的索引列。如果Key为空，或者显示为NULL，表示索引未被使用。</li><li><strong>key_len</strong>：索引使用的字节数。如果key_len很小，可能意味着只使用了部分索引，导致索引失效。</li><li><strong>Extra</strong>：额外的信息。特别关注是否出现Using where、Using join buffer、Using temporary、Using filesort等关键词，这些都可能表示索引失效。</li></ol></blockquote><h2 id="超大分页或深度分页如何处理？"><a href="#超大分页或深度分页如何处理？" class="headerlink" title="超大分页或深度分页如何处理？"></a>超大分页或深度分页如何处理？</h2><blockquote><h2 id="准备数据"><a href="#准备数据" class="headerlink" title="准备数据"></a>准备数据</h2><p>创建学生表，并在创建时间列添加索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建学生表，并在创建时间列添加索引</span><br><span class="line">CREATE TABLE `student` (</span><br><span class="line">    `id` int NOT NULL AUTO_INCREMENT COMMENT &#x27;主键&#x27;,</span><br><span class="line">    `name` varchar(255) DEFAULT NULL COMMENT &#x27;姓名&#x27;,</span><br><span class="line">    `age` int DEFAULT NULL COMMENT &#x27;年龄&#x27;,</span><br><span class="line">    `create_time` timestamp NULL DEFAULT NULL COMMENT &#x27;创建时间&#x27;,</span><br><span class="line">    PRIMARY KEY (`id`),</span><br><span class="line">    KEY `idx_create_time` (`create_time`)</span><br><span class="line">) ENGINE=InnoDB COMMENT=&#x27;学生表&#x27;;</span><br></pre></td></tr></table></figure><p>使用存储过程往学生表中插入100万条测试数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 删除存储过程</span><br><span class="line">DROP PROCEDURE IF EXISTS insertData;</span><br><span class="line"></span><br><span class="line"># 设置分隔符为 $$</span><br><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line"># 创建插入数据的存储过程</span><br><span class="line">CREATE PROCEDURE insertData()</span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE i INT DEFAULT 1;</span><br><span class="line"></span><br><span class="line">  WHILE i &lt;= 100000 DO</span><br><span class="line">    INSERT INTO student (name, age, create_time) VALUES (CONCAT(&quot;name&quot;,i), i, now());</span><br><span class="line">    SET i = i + 1; </span><br><span class="line">  END WHILE;</span><br><span class="line">END $$</span><br><span class="line"></span><br><span class="line"># 调用插入数据的存储过程</span><br><span class="line">CALL insertData() $$</span><br></pre></td></tr></table></figure><h2 id="深分页问题"><a href="#深分页问题" class="headerlink" title="深分页问题"></a>深分页问题</h2><p>MySQL的分页查询语法一般使用LIMIT语句来实现，参数<code>offset</code>指定从第几条记录开始获取数据，参数<code>count</code>指定获取多少条记录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表名 LIMIT offset, count;</span><br></pre></td></tr></table></figure><p>假设student表有100万条数据，当每页10条查询第一页的时候，速度很快</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student limit 0, 10;</span><br></pre></td></tr></table></figure><p>当翻页过多的时候，就会产生深分页，越往后翻，查询效率会越低</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from student limit 10000, 10;</span><br></pre></td></tr></table></figure><h2 id="LIMIT深分页变慢的原因"><a href="#LIMIT深分页变慢的原因" class="headerlink" title="LIMIT深分页变慢的原因"></a>LIMIT深分页变慢的原因</h2><p>LIMIT深分页会变慢的主要原因是在执行查询时，MySQL需要扫描并跳过大量的记录，偏移量（offset）越大，需要扫描并跳过的记录数量就越多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 会先扫描 offset + count 条记录，然后丢弃掉前offset条记录，返回后count条记录。</span><br><span class="line">SELECT * FROM 表名 LIMIT offset, count;</span><br><span class="line"># 会先扫描10条记录，然后丢弃掉前0条记录，返回后10条记录。</span><br><span class="line">SELECT * FROM student LIMIT 0, 10;</span><br><span class="line"># 会扫描100010条记录，然后丢弃掉前10000条记录，返回后10条记录。</span><br><span class="line">SELECT * FROM student LIMIT 10000, 10;</span><br></pre></td></tr></table></figure><h2 id="LIMIT深分页问题解决方案"><a href="#LIMIT深分页问题解决方案" class="headerlink" title="LIMIT深分页问题解决方案"></a>LIMIT深分页问题解决方案</h2><h3 id="方案一：使用标签记录法（推荐）"><a href="#方案一：使用标签记录法（推荐）" class="headerlink" title="方案一：使用标签记录法（推荐）"></a>方案一：使用标签记录法（推荐）</h3><p>标签记录法是指在每次查询时，记录当前页最后一条数据的标识（比如主键值），下次查询时直接根据这个标识进行查询，避免了大量的扫描弃掉操作。这种方式有一个局限性，需要一种类似连续自增的字段来作为标记。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 假设上一页最后一条数据的id为last_id</span><br><span class="line">SELECT * FROM student WHERE id &lt; last_id ORDER BY id LIMIT 10;</span><br></pre></td></tr></table></figure><h3 id="方案二：使用BETWEEN…AND…范围扫描"><a href="#方案二：使用BETWEEN…AND…范围扫描" class="headerlink" title="方案二：使用BETWEEN…AND…范围扫描"></a>方案二：使用BETWEEN…AND…范围扫描</h3><p>很多时候，可以将<code>LIMIT</code>查询转换为已知位置的查询，这样MySQL通过<code>BETWEEN...AND...</code>进行范围扫描，获得到对应的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM student WHERE id BETWEEN 100000 AND 100010;</span><br></pre></td></tr></table></figure><h3 id="方案三：使用子查询优化"><a href="#方案三：使用子查询优化" class="headerlink" title="方案三：使用子查询优化"></a>方案三：使用子查询优化</h3><p>当根据非聚簇索引字段进行分页查询时，可以使用子查询来优化，将条件转移到主键索引树，减少回表查询，加快查询效率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 由于create_time是非聚簇索引，需要先查询出主键ID，再回表查询，通过主键ID查询出所有字段</span><br><span class="line">SELECT * FROM student WHERE create_time &gt; &#x27;2022-02-02&#x27; LIMIT 100000, 10;</span><br><span class="line"># 使用子查询时，会使用覆盖索引，避免回表查询，加快查询效率。</span><br><span class="line">SELECT * FROM student WHERE id IN (</span><br><span class="line">    SELECT id FROM (</span><br><span class="line">        SELECT id FROM student WHERE create_time &gt; &#x27;2022-02-02&#x27; LIMIT 100000, 10;</span><br><span class="line">    ) AS stu</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="方案四：使用-INNER-JOIN-延迟关联"><a href="#方案四：使用-INNER-JOIN-延迟关联" class="headerlink" title="方案四：使用 INNER JOIN 延迟关联"></a>方案四：使用 INNER JOIN 延迟关联</h3><p>使用内连接和延迟关联的方式，将条件转移到主键索引树，减少回表操作，加快查询效率。思路跟子查询的优化思路类似</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 由于create_time是非聚簇索引，需要先查询出主键ID，再回表查询，通过主键ID查询出所有字段</span><br><span class="line">SELECT * FROM student WHERE create_time &gt; &#x27;2022-02-02&#x27; LIMIT 100000, 10;</span><br><span class="line"># 使用 INNER JOIN 延迟关联</span><br><span class="line">SELECT * FROM student INNER JOIN (</span><br><span class="line">    SELECT id FROM student create_time &gt; &#x27;2022-02-02&#x27; LIMIT 100000, 10;</span><br><span class="line">) AS stu ON student.id = stu.id;</span><br></pre></td></tr></table></figure></blockquote><h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><h2 id="主从复制是什么？"><a href="#主从复制是什么？" class="headerlink" title="主从复制是什么？"></a>主从复制是什么？</h2><blockquote><p>MySQL主从复制是一种常用的数据库复制技术，通过复制主服务器（Master）上的数据复制到另一个或多个从服务器（Slave）上，实现数据的实时同步和备份。</p></blockquote><h2 id="主从复制的作用？"><a href="#主从复制的作用？" class="headerlink" title="主从复制的作用？"></a>主从复制的作用？</h2><blockquote><p>主从复制在数据库系统中有以下几个主要作用：</p><ul><li><strong>读写分离</strong>：主服务器（Master）负责处理写操作（写入数据），从服务器（Slave）负责处理读操作（查询数据），可以有效分担主服务器的负载，提高系统性能和扩展性。</li><li><strong>高可用性</strong>：从服务器（Slave）作为主服务器的备份，可以在主服务器（Master）发生故障时，提供数据的备份和恢复功能。</li></ul></blockquote><h2 id="主从复制的原理？"><a href="#主从复制的原理？" class="headerlink" title="主从复制的原理？"></a>主从复制的原理？</h2><blockquote><p>主从复制中的每个连接通常会涉及三个线程：</p><ol><li><strong>Binlog输出线程</strong>：在主库上，为每个连接到主库的从库创建一个binlog输出线程。这个线程负责将主库上的数据更改操作记录（binlog）发送给相应的从库。它将binlog事件推送到对应的从库的I&#x2F;O线程。</li><li><strong>I&#x2F;O线程</strong>：在从库上，每个连接到主库的从库都有一个独立的I&#x2F;O线程。这个线程负责与主库建立连接，接收并读取主库上的binlog事件，并将其存储到从库的本地中继日志（relay log）中。</li><li><strong>SQL线程</strong>：在从库上，每个连接到主库的从库都有一个独立的SQL线程。这个线程负责从本地中继日志中读取存储的binlog事件，并将其解析并执行在从库上重放这些事件，从而实现与主库的数据同步。</li></ol><p>具体的主从复制过程如下：</p><ol><li><strong>主服务器记录二进制日志（Binary Log）</strong>：当主服务器接收到客户端的写请求时，会在执行写操作前将该操作记录到<code>二进制日志（Binary Log）</code>。</li><li><strong>从服务器尝试连接主服务器</strong>：从服务器尝试通过网络连接到主服务器</li><li><strong>主服务器接受从服务器连接请求</strong>：主服务器接收到从服务器的连接请求，并响应该请求</li><li><strong>从服务器请求同步数据</strong>：从服务器向主服务器发送一个数据同步请求，请求复制主服务器上的数据。</li><li><strong>主服务器发送二进制日志事件</strong>：如果主服务器允许该从服务器进行复制，则主服务器将存储在二进制日志中的写操作事件发送给从服务器。</li><li><strong>从服务器接收并写入中继日志（Relay log）</strong>：从服务器启动一个<code>I/O线程</code>，接收到并解析主服务器发来的二进制日志事件后，会将事件写入自己本地的<code>中继日志（Relay log）</code>。</li><li><strong>从服务器读取中继日志（Relay log）并应用</strong>：从服务器会创建一个<code>SQL线程</code>，按照从主服务器接收到的二进制日志事件的顺序依次读取中继日志（Relay log）中的事件，并且将这些事件应用到自己的数据库中，实现数据的同步。</li><li><strong>从服务器向主服务器发送确认消息</strong>：从服务器在完成了一轮数据同步后，会向主服务器发送一个确认消息，表示已经成功完成数据同步。</li><li><strong>主服务器和从服务器之间保持心跳连接</strong>：为了保证连接的可靠性和稳定性，主服务器和从服务器之间需要不断地保持心跳连接，并且监测连接的状态，如果发现连接异常，则会进行重连。</li><li><strong>重复执行复制过程</strong>：上述步骤将不断地重复执行，以实现主从服务器之间的数据同步。</li></ol><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-MySQL/主从复制原理.png" style="zoom:50%"></blockquote><h2 id="主从复制的架构方式"><a href="#主从复制的架构方式" class="headerlink" title="主从复制的架构方式?"></a>主从复制的架构方式?</h2><blockquote><p>单主单从架构</p><p>单主多从架构</p><p>多主单从架构</p><p>主-主同步架构</p><p>级联复制架构</p></blockquote><h2 id="主从复制有哪些模式？"><a href="#主从复制有哪些模式？" class="headerlink" title="主从复制有哪些模式？"></a>主从复制有哪些模式？</h2><blockquote><p>MySQL主从复制有以下几种常见的模式：</p><ul><li><strong>异步复制（Asynchronous Replication）</strong>：异步复制是MySQL默认的复制方式。主服务在执行完用户提交的事务后，将结果写入 binlog 日志并立即返回给客户端，并不等待从服务接收和处理复制事件。提高主服务的性能，但在主服务宕机而从服务未备份到新的 binlog 时可能会导致数据丢失。</li><li><strong>半同步复制（Semi-Synchronous Replication）</strong>：半同步复制是MySQL主从复制的另一种模式。主服务在执行完事务后，需要至少等待一个从服务确认已经接收并写入复制事件才能返回给客户端。提供了更高的数据一致性和可靠性，但也增加了主服务器的延迟。</li><li><strong>全同步复制（Synchronous Replication）</strong>：全同步复制要求主服务执行完客户端提交的事务后，等待所有从服务都接收并写入relay log后才能返回给客户端。提供了最高的数据一致性和安全性保障，但也会引入更高的延迟和性能开销。</li></ul></blockquote><h2 id="并行复制是什么？"><a href="#并行复制是什么？" class="headerlink" title="并行复制是什么？"></a>并行复制是什么？</h2><blockquote><p>并行复制是MySQL中用于加快主从复制速度的一种机制，允许在从库上同时应用多个来自主库的事务，以减少复制延迟。</p><ul><li><strong>传统主从复制</strong>：在传统主从复制中，从库使用 IO 线程（io_thread）接收二进制日志（Binary Log）并保存到中继日志（Relay log），当主库并行写入压力较大时，因为是顺序写入中继日志（Relay log），所以从库 IO 线程（io_thread）一般不会产生延迟。但是<code>只有单个 SQL 线程（sql_thread）来读取和应用中继日志（Relay log）</code>，导致在高并发场景下主库严重延迟。</li><li><strong>并行复制机制</strong>：在采用并行复制机制后，从库的IO线程（io_thread）仍然负责接收主库的二进制日志（Binary log）并保存到中继日志（Relay log），但会<code>将单个SQL线程（sql_thread）演化成多个Worker线程，并行读取和应用中继日志（Relay log）中的事务</code>，充分利用了硬件资源，提高了复制的效率。</li></ul></blockquote><h2 id="GTID复制是什么？"><a href="#GTID复制是什么？" class="headerlink" title="GTID复制是什么？"></a>GTID复制是什么？</h2><blockquote><p>GTID复制是MySQL 5.6版本引入的复制方式，它使用全局唯一的事务标识符（GTID）来追踪和标识主从服务器上的事务。GTID复制简化了配置和管理，可以确保每个事务在主从服务器上只执行一次，并自动处理主从服务器之间的不一致性。</p></blockquote><h2 id="什么是分库分表？"><a href="#什么是分库分表？" class="headerlink" title="什么是分库分表？"></a>什么是分库分表？</h2><blockquote><p><strong>分库</strong>：将一个大型数据库拆分成多个小型数据库（分库）</p><p><strong>分表</strong>：将一个大型表拆分成多个较小的表（分表）</p></blockquote><h2 id="为什么分库分表"><a href="#为什么分库分表" class="headerlink" title="为什么分库分表?"></a>为什么分库分表?</h2><blockquote><p>分库的原因如下：</p><ul><li><strong>提高存储能力</strong>：随着业务的发展，数据量会不断增长，单个数据库的存储容量可能无法满足需求。通过将数据拆分到多个数据库中，从而实现更高的存储能力。</li><li><strong>提高并发能力</strong>：随着业务的发展，在高并发的场景下大量请求访问数据库，单个数据库实例可能无法处理这么多的连接，导致性能下降或响应时间延长。通过分库，可以将数据在多个数据库中分散存储，将并发压力均匀分布到多个数据库上，每个数据库负责处理一部分并发请求，提高整个系统的并发处理能力。</li><li><strong>提高可用性</strong>：随着业务的发展，系统的可用性变得尤为重要，当数据集中存储在单个数据库中时，如果该数据库出现故障，整个系统都将不可用。通过将数据分散存储到多个数据库中，即使一个数据库发生故障，其他数据库仍然可以正常运行，确保业务的连续性和可用性。</li></ul><p>分表的原因如下：</p><ul><li><strong>提高查询性能</strong>：当一个表的数据量过大时（达到几千万），B+树的高度会增高，数据库需要扫描更多的数据页来查找所需的数据，导致查询速度下降。通过分表，可以将数据分散到多个小表中，每个小表的数据量变小，从而提高查询性能。</li><li><strong>减少锁冲突</strong>：在高并发环境下，当多个用户同时对同一张表进行写操作时，可能会引发锁冲突，降低系统的并发性能。通过分表，可以将数据分散到多个小表中，减少锁冲突的可能性，提高并发性能。</li><li><strong>方便维护和备份</strong>：当数据量较大时，整张表的维护和备份可能会变得困难。通过分表，可以将数据分散到多个小表中，便于对每个小表进行维护和备份。这样可以提高维护和备份的效率，并降低出错的风险。</li></ul></blockquote><h2 id="什么时候分库？"><a href="#什么时候分库？" class="headerlink" title="什么时候分库？"></a>什么时候分库？</h2><blockquote><p>分库的时机主要取决于以下几个因素：</p><ul><li><strong>单库容量达到上限</strong>：MySQL单库容量的上限具体取决于数据库类型和配置，通常是在几十到几百亿条数据之间。当单个数据库的存储容量达到极限，无法再容纳更多数据时，需要考虑进行分库操作。</li><li><strong>单库并发达到上限</strong>：MySQL单库一般可以支持1万到10万的并发读写，当并发量达到2万时，可以考虑分库来分担负载，提高并发处理能力。</li><li><strong>业务拆分需求</strong>：当业务规模扩大或需要在不同地域或数据中心部署时，可以考虑根据业务功能或地理位置等因素进行数据库的拆分。这样可以提高系统的灵活性、可伸缩性和可用性。</li></ul></blockquote><h2 id="什么时候分表？"><a href="#什么时候分表？" class="headerlink" title="什么时候分表？"></a>什么时候分表？</h2><blockquote><p>对于MySQL的InnoDB存储引擎而言，单表最多可以存储10亿级别的数据量。单表数据量在500万左右，性能会处于最佳状态，根据阿里巴巴的《Java开发手册》的建议，当单表行数超过500万行或者单表容量超过2GB时，推荐考虑进行分表操作。</p><p>InnoDB存储引擎最小储存单元是页，一页大小就是16k，假设一行记录占用1KB空间，一棵高度为1的B+树能存放<code>16</code>条数据，大约占用<code>16 KB</code>空间；一棵高度为2的B+树能存放<code>18720</code>条数据，大约占用<code>18.72 MB</code>空间；一棵高度为3的B+树能存放<code>21902400</code>条数据，大约占用<code>21.9 GB</code>空间；B+树高度一般为1-3层，如果B+到了4层，查询的时候会增加磁盘交互的次数，SQL就会变慢。</p></blockquote><h2 id="什么时候分库分表？"><a href="#什么时候分库分表？" class="headerlink" title="什么时候分库分表？"></a>什么时候分库分表？</h2><blockquote><p>分库分表方案可以分为下面3种：</p><ul><li><strong>只分库不分表</strong>：单库并发达到上限，但是单表数据量不大；</li><li><strong>只分表不分库</strong>：单表数据量过大，但是单库并发没达到上限；</li><li><strong>即分库又分表</strong>：单库并发达到上限，同时单表数据量过大。</li></ul></blockquote><h2 id="分库分表的策略"><a href="#分库分表的策略" class="headerlink" title="分库分表的策略?"></a>分库分表的策略?</h2><blockquote><p>分库和分表都可以从垂直（纵向）和水平（横向）两个维度进行拆分。</p><ul><li><strong>垂直分库</strong>：将不同的业务模块或功能模块的数据存储在不同的数据库中，每个数据库负责一个或多个特定的模块。</li><li><strong>垂直分表</strong>：将一个大表根据字段的关联性进行拆分，每个拆分出来的小表只包含一部分字段。</li><li><strong>水平分库</strong>：将一个数据库中的数据水平划分到多个独立的数据库实例中，每个数据库实例负责一部分数据。</li><li><strong>水平分表</strong>：将一个大表按照行进行拆分，将不同的行分散存储在多个物理表中。</li></ul></blockquote><h2 id="分库分表带来的问题怎么解决？"><a href="#分库分表带来的问题怎么解决？" class="headerlink" title="分库分表带来的问题怎么解决？"></a>分库分表带来的问题怎么解决？</h2><blockquote><h3 id="分布式事务问题"><a href="#分布式事务问题" class="headerlink" title="分布式事务问题"></a>分布式事务问题</h3><ul><li><strong>问题描述</strong>：分库分表导致执行一次事务所需的数据分布在不同服务器上，传统的单库事务无法直接应用。</li><li><strong>解决思路</strong>：使用分布式事务机制来保证事务的原子性和一致性。可以采用两阶段提交（2PC）、补偿事务、Saga模式等。另外，可以利用数据库中间件或分布式事务框架来简化事务管理和实现分布式事务。</li></ul><h3 id="分布式ID问题"><a href="#分布式ID问题" class="headerlink" title="分布式ID问题"></a>分布式ID问题</h3><ul><li><strong>问题描述</strong>：在分库分表环境中，由于数据被分散到不同的节点上，生成全局唯一的ID变得更加困难，可能会导致ID冲突或者无法满足全局唯一性的需求。</li><li><strong>解决思路</strong>：使用全局唯一标识符（UUID或GUID）作为分布式ID，或者使用数据库自增ID来生成局部唯一的ID，还可以借助第三方中间件（如Snowflake、Twitter的分布式ID生成器等）来生成全局唯一的ID。</li></ul><h3 id="数据同步问题"><a href="#数据同步问题" class="headerlink" title="数据同步问题"></a>数据同步问题</h3><ul><li><strong>问题描述</strong>：分库分表后，数据的一致性和同步变得复杂。当涉及到数据更新、删除或新增时，需要确保所有相关的分片上的数据保持一致。</li><li><strong>解决思路</strong>：使用数据同步机制，如主从复制、发布&#x2F;订阅模式、异步消息队列等，将数据的变更操作传播到所有的分片中，保证数据的一致性和同步。</li></ul><h3 id="数据迁移问题"><a href="#数据迁移问题" class="headerlink" title="数据迁移问题"></a>数据迁移问题</h3><ul><li><strong>问题描述</strong>：当需要对现有的分库分表进行扩容、重构或合并时，需要进行数据迁移，这可能会引发数据一致性问题和系统停机时间长等挑战。</li><li><strong>解决思路</strong>：采用逐步迁移的方式，将部分数据从老的分片迁移到新的分片上。可以使用增量迁移或者全量迁移的策略，并且要做好数据一致性和验证工作。同时，可以利用数据同步技术来减少迁移的停机时间和对业务的影响。</li></ul><h3 id="跨节点关联查询问题"><a href="#跨节点关联查询问题" class="headerlink" title="跨节点关联查询问题"></a>跨节点关联查询问题</h3><ul><li><strong>问题描述</strong>：分库分表之后，数据可能分布在不同的节点上，此时使用关联查询（JOIN）跨多个数据库实例或表的数据时，会增加复杂性和性能开销。</li><li><strong>解决思路</strong>：可以分多次查询进行数据组装实现业务，避免使用关联查询（JOIN）。或者在分片中的表中增加冗余字段，避免关联查询（JOIN）用空间换时间。</li></ul><h3 id="跨节点分页问题"><a href="#跨节点分页问题" class="headerlink" title="跨节点分页问题"></a>跨节点分页问题</h3><ul><li><strong>问题描述</strong>：在分库分表的环境下，进行跨节点的分页查询需要从多个分片获取数据，并对结果进行合并和排序，增加了网络传输和计算开销。</li><li><strong>解决思路</strong>：使用全局排序键，将排序键作为分片键的一部分，以保证全局有序。可以通过预取数据、并行查询等方式提高分页查询性能。同时，可以采用分页缓存技术，在应用层缓存整个分页数据，减少跨分片查询的次数。</li></ul><h3 id="跨节点排序问题"><a href="#跨节点排序问题" class="headerlink" title="跨节点排序问题"></a>跨节点排序问题</h3><ul><li><strong>问题描述</strong>：在分库分表环境中，对全局数据进行排序比较困难，需要合并多个分片的结果集，增加了计算和网络开销。</li><li><strong>解决思路</strong>：使用分布式排序算法，如归并排序、快速排序等。可以将排序操作下推至分片进行局部排序，然后通过合并操作得到全局有序结果。另外，还可以在应用层进行排序，将排序操作由数据库转移到应用程序中。</li></ul><h3 id="跨节点函数计算问题"><a href="#跨节点函数计算问题" class="headerlink" title="跨节点函数计算问题"></a>跨节点函数计算问题</h3><ul><li><strong>问题描述</strong>：在分库分表环境中，当需要进行跨节点的函数计算时，可能会面临调用多个节点的函数和结果合并等挑战。</li><li><strong>解决思路</strong>：可以将函数计算下推至分片进行局部计算，然后通过合并操作得到最终的结果。另外，还可以在应用层进行函数计算，将计算操作由数据库转移到应用程序中。</li></ul></blockquote></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://w_e_n.gitee.io/blog">wen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://w_e_n.gitee.io/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-MySQL/">https://w_e_n.gitee.io/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-MySQL/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://w_e_n.gitee.io/blog" target="_blank">远方の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><div class="post_share"><div class="social-share" data-image="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-MySQL/%E9%9D%A2%E8%AF%95%E9%A2%98.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/" title="面试题-JavaSE"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/%E9%9D%A2%E8%AF%95%E9%A2%98.png" onerror='onerror=null,src="/blog/img/404.png"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面试题-JavaSE</div></div></a></div><div class="next-post pull-right"><a href="/blog/2023/01/01/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/" title="项目相关笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3.png" onerror='onerror=null,src="/blog/img/404.png"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">项目相关笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Redis/" title="面试题-Redis"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Redis/%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-01</div><div class="title">面试题-Redis</div></div></a></div><div><a href="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/" title="面试题-微服务与中间件"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-01</div><div class="title">面试题-微服务与中间件</div></div></a></div><div><a href="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF%E5%92%8C%E5%B7%A5%E5%85%B7/" title="面试题-技术场景和工具"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF%E5%92%8C%E5%B7%A5%E5%85%B7/%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-01</div><div class="title">面试题-技术场景和工具</div></div></a></div><div><a href="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/" title="面试题-Web开发与常用框架"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-01</div><div class="title">面试题-Web开发与常用框架</div></div></a></div><div><a href="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/" title="面试题-JavaSE"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-01</div><div class="title">面试题-JavaSE</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Gitalk</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/img/%E5%A4%B4%E5%83%8F.png" onerror='this.onerror=null,this.src="/blog/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">wen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wen53231323"><i class="fab fa-github"></i><span>我的仓库</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">暂无</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86"><span class="toc-number">1.</span> <span class="toc-text">基础部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E6%9F%A5%E8%AF%A2%E5%85%B3%E9%94%AE%E8%AF%8D%E6%89%A7%E8%A1%8C%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.1.</span> <span class="toc-text">SQL查询关键词执行的顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E8%B7%9F%E8%A1%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%85%B3%E8%81%94%E7%9A%84%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">表跟表是怎么关联的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%86%85%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">说一说内连接？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%A4%96%E8%BF%9E%E6%8E%A5%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">说一说外连接？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">常见的聚合函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFSQL%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">什么是SQL注入？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E9%98%B2%E6%AD%A2SQL%E6%B3%A8%E5%85%A5%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">怎样防止SQL注入？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">视图是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">存储过程是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">存储过程的优点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">存储过程的缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">存储函数是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">存储函数的优点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">1.14.</span> <span class="toc-text">存储函数的缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.15.</span> <span class="toc-text">存储过程与存储函数的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E7%94%A8%E8%A1%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88CTE%EF%BC%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.16.</span> <span class="toc-text">共用表表达式（CTE）是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXISTS%E5%92%8CIN%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.17.</span> <span class="toc-text">EXISTS和IN的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UNION%E5%92%8CUNION-ALL%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.18.</span> <span class="toc-text">UNION和UNION ALL的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%86%E9%A1%B5%EF%BC%9F"><span class="toc-number">1.19.</span> <span class="toc-text">MySQL如何做分页？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%80%E5%BC%A0%E8%A1%A8%E7%9A%84%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E5%88%B0%E5%8F%A6%E4%B8%80%E5%BC%A0%E8%A1%A8%EF%BC%9F"><span class="toc-number">1.20.</span> <span class="toc-text">如何将一张表的部分数据更新到另一张表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Where%E5%92%8CHaving%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.21.</span> <span class="toc-text">Where和Having区别？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%9B%B8%E5%85%B3"><span class="toc-number">2.</span> <span class="toc-text">数据库设计相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%89%E8%8C%83%E5%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">数据库设计的三范式是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%8C%83%E5%BC%8F%E5%92%8C%E5%8F%8D%E8%8C%83%E5%BC%8F%EF%BC%9F"><span class="toc-number">2.2.</span> <span class="toc-text">什么是范式和反范式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E6%9C%89%E5%93%AA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="toc-number">2.3.</span> <span class="toc-text">MySQL有哪数据类型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E4%B8%AD%E4%B8%BB%E9%94%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%A2%9E%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">表中主键为什么要设置自增？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9E-ID-%E8%BF%98%E6%98%AF-UUID%EF%BC%9F"><span class="toc-number">2.5.</span> <span class="toc-text">主键使用自增 ID 还是 UUID？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NULL%E5%92%8C%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%9D%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.6.</span> <span class="toc-text">NULL和空字符串””的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%B1%82%E5%AE%9A%E4%B9%89%E4%B8%BA-NOT-NULL%EF%BC%9F"><span class="toc-number">2.7.</span> <span class="toc-text">字段为什么要求定义为 NOT NULL？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%BA%94%E8%AF%A5%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AD%98%E5%82%A8%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">固定长度的字符串应该什么数据类型存储？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CHAR-%E5%92%8C-VARCHAR-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.9.</span> <span class="toc-text">CHAR 和 VARCHAR 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CHAR-10-%E5%92%8C-VARCHAR-10-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.10.</span> <span class="toc-text">CHAR(10) 和 VARCHAR(10) 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CHAR-%E5%92%8C-VARCHAR-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%EF%BC%9F"><span class="toc-number">2.11.</span> <span class="toc-text">CHAR 和 VARCHAR 如何选择？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Text-%E4%B8%8E-Blob-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.12.</span> <span class="toc-text">Text 与 Blob 的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Datetime%E5%92%8CTimestamp%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.13.</span> <span class="toc-text">Datetime和Timestamp的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BA%A6%E6%9D%9F%EF%BC%9F"><span class="toc-number">2.14.</span> <span class="toc-text">什么是数据库约束？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">2.15.</span> <span class="toc-text">数据库的约束有哪些？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">3.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.1.</span> <span class="toc-text">数据库的事务是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%88ACID%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">事务的四大特性（ACID）?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">3.3.</span> <span class="toc-text">事务隔离级别有哪些?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">默认隔离级别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8RC%E4%B8%8D%E4%BD%BF%E7%94%A8RR%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">隔离级别为什么使用RC不使用RR？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">并发事务是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E4%BC%9A%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">3.7.</span> <span class="toc-text">并发事务会带来哪些问题?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">3.8.</span> <span class="toc-text">并发事务问题怎么解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">3.9.</span> <span class="toc-text">方式一：使用事务隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%94%81%E6%9C%BA%E5%88%B6%E6%9D%A5%E4%BF%9D%E6%8A%A4%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90"><span class="toc-number">3.10.</span> <span class="toc-text">方式二：使用锁机制来保护共享资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E4%BD%BF%E7%94%A8MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">3.11.</span> <span class="toc-text">方式三：使用MVCC多版本并发控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BD%93%E5%89%8D%E8%AF%BB%E4%B8%8E%E5%BF%AB%E7%85%A7%E8%AF%BB%EF%BC%9F"><span class="toc-number">3.12.</span> <span class="toc-text">什么是当前读与快照读？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVCC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.13.</span> <span class="toc-text">MVCC是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVCC%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">3.14.</span> <span class="toc-text">MVCC的实现原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RC%E5%92%8CRR%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%ABMVCC%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">3.15.</span> <span class="toc-text">RC和RR隔离级别MVCC有什么不同？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">4.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">MySQL 数据库的锁有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">乐观锁和悲观锁是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">乐观锁和悲观锁怎么实现？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">4.3.0.1.</span> <span class="toc-text">乐观锁的实现方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">4.3.0.2.</span> <span class="toc-text">悲观锁的实现方式：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E5%AE%83%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">共享锁和排它锁是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">全局锁是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.6.</span> <span class="toc-text">表级锁是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">4.7.</span> <span class="toc-text">表级锁有什么特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.8.</span> <span class="toc-text">元数据锁是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81%EF%BC%88Intent-Lock%EF%BC%89"><span class="toc-number">4.9.</span> <span class="toc-text">意向锁（Intent Lock）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.10.</span> <span class="toc-text">行级锁是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">4.11.</span> <span class="toc-text">行级锁有什么特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E9%94%81%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">4.12.</span> <span class="toc-text">行锁是如何实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.13.</span> <span class="toc-text">插入意向锁是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.14.</span> <span class="toc-text">自增锁是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E9%94%81%E3%80%81%E9%97%B4%E9%9A%99%E9%94%81%E5%92%8C%E4%B8%B4%E9%94%AE%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.15.</span> <span class="toc-text">记录锁、间隙锁和临键锁是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E9%94%81%E3%80%81%E9%97%B4%E9%9A%99%E9%94%81%E5%92%8C%E4%B8%B4%E9%94%AE%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.16.</span> <span class="toc-text">记录锁、间隙锁和临键锁的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E9%94%AE%E9%94%81%E6%98%AF%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E5%B9%BB%E8%AF%BB%E7%9A%84%E5%8F%91%E7%94%9F%EF%BC%9F"><span class="toc-number">4.17.</span> <span class="toc-text">临键锁是如何防止幻读的发生？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E9%94%81%E4%B8%8E%E8%A1%8C%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.18.</span> <span class="toc-text">表锁与行锁的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.19.</span> <span class="toc-text">死锁是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%AD%89%E5%BE%85%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.20.</span> <span class="toc-text">锁等待是什么？</span></a></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E7%9A%84%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">MySQL的逻辑架构？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E9%87%8D%E8%A6%81%E7%BB%84%E4%BB%B6%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">说说重要组件？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">SQL语句执行过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">什么是存储引擎？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">5.5.</span> <span class="toc-text">常见的存储引擎有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E7%9A%84%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">5.6.</span> <span class="toc-text">InnoDB的逻辑存储结构？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E4%B8%8EMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.7.</span> <span class="toc-text">InnoDB与MyISAM的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#InnoDB%E4%B8%80%E9%A2%97B-%E6%A0%91%E5%8F%AF%E4%BB%A5%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">5.8.</span> <span class="toc-text">InnoDB一颗B+树可以存放多少数据？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E6%97%A5%E5%BF%97%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">5.9.</span> <span class="toc-text">MySQL中常见的日志有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">5.10.</span> <span class="toc-text">慢查询日志有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Undo-Log%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">5.11.</span> <span class="toc-text">Undo Log有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redo-Log%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">5.12.</span> <span class="toc-text">Redo Log有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binary-Log%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="toc-number">5.13.</span> <span class="toc-text">Binary Log有什么用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Binary-Log%E5%92%8CRedo-Log%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.14.</span> <span class="toc-text">Binary Log和Redo Log有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">6.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">什么是索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%9C%A8%E6%9F%A5%E8%AF%A2%E4%B8%AD%E8%B5%B7%E5%88%B0%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">索引在查询中起到什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">索引的优缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">6.4.</span> <span class="toc-text">索引类型有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">6.5.</span> <span class="toc-text">什么情况推荐使用索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">6.6.</span> <span class="toc-text">什么情况不推荐使用索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">6.7.</span> <span class="toc-text">索引的数据结构？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash%E7%B4%A2%E5%BC%95%E5%92%8CB-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.8.</span> <span class="toc-text">Hash索引和B+树索引的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B-%E6%A0%91%E8%80%8C%E4%B8%8D%E6%98%AFB%E6%A0%91%EF%BC%9F"><span class="toc-number">6.9.</span> <span class="toc-text">为什么使用B+树而不是B树？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-number">6.10.</span> <span class="toc-text">索引的失效情况？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%A1%AE%E5%AE%9A%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-number">6.11.</span> <span class="toc-text">怎么确定索引失效？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">6.12.</span> <span class="toc-text">什么是聚集索引和非聚集索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">6.13.</span> <span class="toc-text">什么是联合索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">6.14.</span> <span class="toc-text">为什么使用联合索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">6.15.</span> <span class="toc-text">什么是覆盖索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">6.16.</span> <span class="toc-text">为什么使用覆盖索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%9F"><span class="toc-number">6.17.</span> <span class="toc-text">什么是回表查询？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-number">6.18.</span> <span class="toc-text">什么是最左前缀原则？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%81%B5%E5%BE%AA%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D"><span class="toc-number">6.19.</span> <span class="toc-text">为什么要遵循最左匹配?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">6.20.</span> <span class="toc-text">什么是前缀索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">6.21.</span> <span class="toc-text">为什么使用前缀索引？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%EF%BC%9F"><span class="toc-number">6.22.</span> <span class="toc-text">什么是索引下推？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">7.</span> <span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E7%9A%84%E7%BB%8F%E9%AA%8C%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">谈谈你对数据库优化的经验？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">7.2.</span> <span class="toc-text">常见的查询优化?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8F%92%E5%85%A5%E4%BC%98%E5%8C%96"><span class="toc-number">7.3.</span> <span class="toc-text">常见的插入优化?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%A1%B5%E5%88%86%E8%A3%82%E4%B8%8E%E9%A1%B5%E5%90%88%E5%B9%B6%EF%BC%9F"><span class="toc-number">7.4.</span> <span class="toc-text">什么是页分裂与页合并？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E8%A1%A8%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">7.5.</span> <span class="toc-text">常见的表设计优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">7.6.</span> <span class="toc-text">常见的索引优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E4%B8%AASQL%E6%89%A7%E8%A1%8C%E5%BE%88%E6%85%A2%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">7.7.</span> <span class="toc-text">有个SQL执行很慢怎么优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%EF%BC%9F"><span class="toc-number">7.8.</span> <span class="toc-text">说一说慢查询日志？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E6%80%8E%E6%A0%B7%E6%9F%A5%E7%9C%8BSQL%E6%89%A7%E8%A1%8C%E4%BF%A1%E6%81%AF"><span class="toc-number">7.9.</span> <span class="toc-text">说一说怎样查看SQL执行信息?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%EF%BC%9F"><span class="toc-number">7.10.</span> <span class="toc-text">说一说执行计划？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E5%A4%A7%E5%88%86%E9%A1%B5%E6%88%96%E6%B7%B1%E5%BA%A6%E5%88%86%E9%A1%B5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">7.11.</span> <span class="toc-text">超大分页或深度分页如何处理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E6%95%B0%E6%8D%AE"><span class="toc-number">7.12.</span> <span class="toc-text">准备数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%88%86%E9%A1%B5%E9%97%AE%E9%A2%98"><span class="toc-number">7.13.</span> <span class="toc-text">深分页问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LIMIT%E6%B7%B1%E5%88%86%E9%A1%B5%E5%8F%98%E6%85%A2%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">7.14.</span> <span class="toc-text">LIMIT深分页变慢的原因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LIMIT%E6%B7%B1%E5%88%86%E9%A1%B5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">7.15.</span> <span class="toc-text">LIMIT深分页问题解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%A0%87%E7%AD%BE%E8%AE%B0%E5%BD%95%E6%B3%95%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">7.15.1.</span> <span class="toc-text">方案一：使用标签记录法（推荐）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8BETWEEN%E2%80%A6AND%E2%80%A6%E8%8C%83%E5%9B%B4%E6%89%AB%E6%8F%8F"><span class="toc-number">7.15.2.</span> <span class="toc-text">方案二：使用BETWEEN…AND…范围扫描</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">7.15.3.</span> <span class="toc-text">方案三：使用子查询优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E5%9B%9B%EF%BC%9A%E4%BD%BF%E7%94%A8-INNER-JOIN-%E5%BB%B6%E8%BF%9F%E5%85%B3%E8%81%94"><span class="toc-number">7.15.4.</span> <span class="toc-text">方案四：使用 INNER JOIN 延迟关联</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">8.</span> <span class="toc-text">高可用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.1.</span> <span class="toc-text">主从复制是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">8.2.</span> <span class="toc-text">主从复制的作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">8.3.</span> <span class="toc-text">主从复制的原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%9E%B6%E6%9E%84%E6%96%B9%E5%BC%8F"><span class="toc-number">8.4.</span> <span class="toc-text">主从复制的架构方式?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">8.5.</span> <span class="toc-text">主从复制有哪些模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%A4%8D%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.6.</span> <span class="toc-text">并行复制是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GTID%E5%A4%8D%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.7.</span> <span class="toc-text">GTID复制是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%9F"><span class="toc-number">8.8.</span> <span class="toc-text">什么是分库分表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">8.9.</span> <span class="toc-text">为什么分库分表?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%86%E5%BA%93%EF%BC%9F"><span class="toc-number">8.10.</span> <span class="toc-text">什么时候分库？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%86%E8%A1%A8%EF%BC%9F"><span class="toc-number">8.11.</span> <span class="toc-text">什么时候分表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%EF%BC%9F"><span class="toc-number">8.12.</span> <span class="toc-text">什么时候分库分表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E7%AD%96%E7%95%A5"><span class="toc-number">8.13.</span> <span class="toc-text">分库分表的策略?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">8.14.</span> <span class="toc-text">分库分表带来的问题怎么解决？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-number">8.14.1.</span> <span class="toc-text">分布式事务问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8FID%E9%97%AE%E9%A2%98"><span class="toc-number">8.14.2.</span> <span class="toc-text">分布式ID问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-number">8.14.3.</span> <span class="toc-text">数据同步问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB%E9%97%AE%E9%A2%98"><span class="toc-number">8.14.4.</span> <span class="toc-text">数据迁移问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E8%8A%82%E7%82%B9%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E9%97%AE%E9%A2%98"><span class="toc-number">8.14.5.</span> <span class="toc-text">跨节点关联查询问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E8%8A%82%E7%82%B9%E5%88%86%E9%A1%B5%E9%97%AE%E9%A2%98"><span class="toc-number">8.14.6.</span> <span class="toc-text">跨节点分页问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E8%8A%82%E7%82%B9%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98"><span class="toc-number">8.14.7.</span> <span class="toc-text">跨节点排序问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E8%8A%82%E7%82%B9%E5%87%BD%E6%95%B0%E8%AE%A1%E7%AE%97%E9%97%AE%E9%A2%98"><span class="toc-number">8.14.8.</span> <span class="toc-text">跨节点函数计算问题</span></a></li></ol></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/CSS/" title="CSS笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/CSS/CSS.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="CSS笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/CSS/" title="CSS笔记">CSS笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/HTML/" title="HTML笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/HTML/HTML.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="HTML笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/HTML/" title="HTML笔记">HTML笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/JavaScript/" title="JavaScript笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/JavaScript/JavaScript.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="JavaScript笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/JavaScript/" title="JavaScript笔记">JavaScript笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/JavaWeb/" title="JavaWeb笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/JavaWeb/JavaWeb.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="JavaWeb笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/JavaWeb/" title="JavaWeb笔记">JavaWeb笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/Linux/" title="Linux笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/Linux/Linux.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="Linux笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/Linux/" title="Linux笔记">Linux笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By wen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '701b8bc001a40a760558',
      clientSecret: 'a51b436adc471c3949a8f41be05c2d58cccab10a',
      repo: 'Hexo-Butterfly-Comment',
      owner: 'wen53231323',
      admin: ['wen53231323'],
      id: '9d804f17e6ed7102c91966581b805e64',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'VI32wmbmMoxvlhpTpoDBNeOk-MdYXbMMI',
      appKey: 'oFstfBFkCQIkjuk4ibCpbGqz',
      avatar: 'monsterid',
      serverURLs: 'https://vi32wmbm.api.lncldglobal.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Gitalk' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/blog/js/search/local-search.js"></script></div></div></body></html>