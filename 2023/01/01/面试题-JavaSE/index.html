<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>面试题-JavaSE | 远方の博客</title><meta name="author" content="wen"><meta name="copyright" content="wen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="[TOC] Java基础相关面试题JDK、JRE、JVM的关系？ JDK提供了开发Java程序所需的工具和资源；JRE提供了运行Java程序所需的最小环境；而JVM则是Java程序的运行平台  JVM：  Java虚拟机，负责解释和执行Java字节码 JRE：Java运行时环境，是在计算机上执行Java应用程序所需的最小环境，包含JVM和类库。JRE &#x3D; JVM + JavaSE标准类库 JDK："><meta property="og:type" content="article"><meta property="og:title" content="面试题-JavaSE"><meta property="og:url" content="https://w_e_n.gitee.io/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/index.html"><meta property="og:site_name" content="远方の博客"><meta property="og:description" content="[TOC] Java基础相关面试题JDK、JRE、JVM的关系？ JDK提供了开发Java程序所需的工具和资源；JRE提供了运行Java程序所需的最小环境；而JVM则是Java程序的运行平台  JVM：  Java虚拟机，负责解释和执行Java字节码 JRE：Java运行时环境，是在计算机上执行Java应用程序所需的最小环境，包含JVM和类库。JRE &#x3D; JVM + JavaSE标准类库 JDK："><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://w_e_n.gitee.io/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/%E9%9D%A2%E8%AF%95%E9%A2%98.png"><meta property="article:published_time" content="2022-12-31T16:00:00.000Z"><meta property="article:modified_time" content="2023-09-06T15:01:14.246Z"><meta property="article:author" content="wen"><meta property="article:tag" content="面试题"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://w_e_n.gitee.io/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/%E9%9D%A2%E8%AF%95%E9%A2%98.png"><link rel="shortcut icon" href="/blog/img/favicon.png"><link rel="canonical" href="https://w_e_n.gitee.io/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//static.cloudflareinsights.com"><link rel="preconnect" href="//www.clarity.ms"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?[object Object]";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=[object Object]"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","[object Object]")</script><script defer data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;[object Object]&quot;}"></script><script>!function(t,e,c,n,a,r){t[c]=t[c]||function(){(t[c].q=t[c].q||[]).push(arguments)},(a=e.createElement(n)).async=1,a.src="https://www.clarity.ms/tag/[object Object]",(r=e.getElementsByTagName(n)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><script>const GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: {"path":"/blog/search.xml","preload":true,"top_n_per_article":5,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"面试题-JavaSE",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-09-06 23:01:14"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/img/%E5%A4%B4%E5%83%8F.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/picture/"><i class="fa-fw fas fa-images"></i><span> 图片库</span></a></li><li><a class="site-page child" href="/blog/music/"><i class="fa-fw fas fa-music"></i><span> 音乐库</span></a></li><li><a class="site-page child" href="/blog/movies/"><i class="fa-fw fas fa-video"></i><span> 视频库</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/link/"><span>导航链接</span></a></li><li><a class="site-page child" href="/blog/comment_loading/"><span>评论管理</span></a></li><li><a class="site-page child" href="/blog/custom/"><span>自定义页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/blog/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/%E9%9D%A2%E8%AF%95%E9%A2%98.png)"><nav id="nav"><span id="blog-info"><a href="/blog/" title="远方の博客"><span class="site-name">远方の博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/picture/"><i class="fa-fw fas fa-images"></i><span> 图片库</span></a></li><li><a class="site-page child" href="/blog/music/"><i class="fa-fw fas fa-music"></i><span> 音乐库</span></a></li><li><a class="site-page child" href="/blog/movies/"><i class="fa-fw fas fa-video"></i><span> 视频库</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/link/"><span>导航链接</span></a></li><li><a class="site-page child" href="/blog/comment_loading/"><span>评论管理</span></a></li><li><a class="site-page child" href="/blog/custom/"><span>自定义页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/blog/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试题-JavaSE</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-06T15:01:14.246Z" title="更新于 2023-09-06 23:01:14">2023-09-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="面试题-JavaSE"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p><h1 id="Java基础相关面试题"><a href="#Java基础相关面试题" class="headerlink" title="Java基础相关面试题"></a>Java基础相关面试题</h1><h2 id="JDK、JRE、JVM的关系？"><a href="#JDK、JRE、JVM的关系？" class="headerlink" title="JDK、JRE、JVM的关系？"></a>JDK、JRE、JVM的关系？</h2><blockquote><p>JDK提供了开发Java程序所需的工具和资源；JRE提供了运行Java程序所需的最小环境；而JVM则是Java程序的运行平台</p><ul><li><strong>JVM</strong>： <code>Java虚拟机</code>，负责解释和执行Java字节码</li><li><strong>JRE</strong>：<code>Java运行时环境</code>，是在计算机上执行Java应用程序所需的最小环境，包含JVM和类库。<code>JRE = JVM + JavaSE标准类库</code></li><li><strong>JDK</strong>：<code>Java开发工具包</code>，它包含了用于开发、编译和调试Java程序的工具。<code>JDK = JRE + 开发工具集</code></li></ul><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/JVM、JRE、JDK的关系.png" style="zoom:50%"></blockquote><h2 id="Java八种数据类型有哪些？"><a href="#Java八种数据类型有哪些？" class="headerlink" title="Java八种数据类型有哪些？"></a>Java八种数据类型有哪些？</h2><blockquote><p>byte（字节型）short（短整型）int（整型）long（长整型）float（单精度浮点型）double（双精度浮点型）char（字符型）boolean（布尔型）</p><table><thead><tr><th>基本数据类型</th><th>占用存储空间（字节）</th><th>默认值</th></tr></thead><tbody><tr><td>byte</td><td>1</td><td>0</td></tr><tr><td>short</td><td>2</td><td>0</td></tr><tr><td>int</td><td>4</td><td>0</td></tr><tr><td>long</td><td>8</td><td>0L</td></tr><tr><td>float</td><td>4</td><td>0.0f</td></tr><tr><td>double</td><td>8</td><td>0.0d</td></tr><tr><td>char</td><td>2</td><td>‘\u0000’（空字符）</td></tr><tr><td>boolean</td><td>1</td><td>false</td></tr></tbody></table></blockquote><h2 id="说一说八种数据类型的包装类？"><a href="#说一说八种数据类型的包装类？" class="headerlink" title="说一说八种数据类型的包装类？"></a>说一说八种数据类型的包装类？</h2><blockquote><p>在Java中，包装类（Wrapper Class）是一种用于将基本数据类型转换为对象的类。Java是一个面向对象的编程语言，但是Java中的八种基本数据类型却是不面向对象的，无法直接参与面向对象的操作，于是Java提供了八种基本数据类型对应的包装类（封装类），使得基本数据类型的变量具有类的特征。有了类的特点，就可以调用类中的方法，Java才是真正的面向对象。除了Integer和Character类以外，其它六个类的类名和基本数据类型一致，只是类名的第一个字母大写即可。</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table></blockquote><h2 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h2><blockquote><p><strong>声明方式不同</strong>：基本类型的声明不需要使用 new 关键字，可以直接声明一个变量并赋初始值。而包装类型需要使用 new 关键字来在堆中分配存储空间，并且需要使用构造函数来初始化对象。</p><p><strong>初始值不同</strong>：基本类型有默认值但不能不能赋值为null；包装类型可以赋值为 null。</p><p><strong>使用方式不同</strong>：基本类型不可以使用泛型；包装类型可使用泛型。</p><p><strong>存储方式及位置不同</strong>：基本类型的值直接存储在栈中，占用固定的内存空间。而包装类型存储的是堆中的对象引用，该引用指向实际存储在堆中的对象。</p></blockquote><h2 id="什么是自动装箱与自动拆箱？"><a href="#什么是自动装箱与自动拆箱？" class="headerlink" title="什么是自动装箱与自动拆箱？"></a>什么是自动装箱与自动拆箱？</h2><blockquote><p>自动装箱（Autoboxing）和自动拆箱（Unboxing）是Java语言中的特性，用于在基本数据类型和对应的包装类之间进行自动的转换。</p><ul><li><strong>自动装箱</strong>：<code>基本数据类型 --&gt; 包装类</code>，将基本数据类型自动转换为对应的包装类对象。</li><li><strong>自动拆箱</strong>：<code>包装类 --&gt; 基本数据类型</code>，将包装类对象自动转换为对应的基本数据类型。</li></ul></blockquote><h2 id="String属于基础的数据类型吗？"><a href="#String属于基础的数据类型吗？" class="headerlink" title="String属于基础的数据类型吗？"></a>String属于基础的数据类型吗？</h2><blockquote><p>String 不是基本数据类型，而是引用数据类型，是Java中的一个类。</p></blockquote><h2 id="String常用的方法有哪些？"><a href="#String常用的方法有哪些？" class="headerlink" title="String常用的方法有哪些？"></a>String常用的方法有哪些？</h2><blockquote><p><code>split()</code>：字符串分隔</p><p><code>substring()</code>：字符串截取</p><p><code>concat()</code>：字符串拼接</p><p><code>replace()</code>：字符串替换</p><p><code>equals()</code>：字符串比较</p><p><code>trim()</code>：字符串去空白</p><p><code>toLowerCase()</code>：字符串大写转小写</p><p><code>toUpperCase()</code>：字符串小写转大写</p></blockquote><h2 id="Java中操作字符串都有哪些类？"><a href="#Java中操作字符串都有哪些类？" class="headerlink" title="Java中操作字符串都有哪些类？"></a>Java中操作字符串都有哪些类？</h2><blockquote><p>String、StringBuffer、StringBuilder</p><ol><li><code>String</code>类：用于创建和操作字符串。</li><li><code>StringBuffer</code>类：用于可变字符串，与<code>StringBuilder</code>类类似，不同之处在于线程安全性</li><li><code>StringBuilder</code>类：用于可变字符串，支持在字符串中进行插入、删除、替换等操作，并且比<code>StringBuffer</code>类更高效。</li></ol></blockquote><h2 id="String、StringBuffer、StringBuilder的区别？"><a href="#String、StringBuffer、StringBuilder的区别？" class="headerlink" title="String、StringBuffer、StringBuilder的区别？"></a>String、StringBuffer、StringBuilder的区别？</h2><blockquote><p>String、StringBuffer和StringBuilder是Java中用于处理字符串的三个类，它们之间有以下区别：</p><ul><li><strong>可变性</strong>：<code>String</code>是不可变类，一旦创建，其值就不可更改。任何对<code>String</code>执行的操作实际上都会创建一个新的<code>String</code>对象。而<code>StringBuffer</code>和<code>StringBuilder</code>都是可变类，可以在已有对象的基础上进行修改而不创建新的对象。<code>StringBuffer</code>和<code>StringBuilder</code>之间的区别在于线程安全性。</li><li><strong>线程安全性</strong>：<code>String</code>是不可变类，因此是线程安全的，多个线程可以同时访问和共享<code>String</code>对象。<code>StringBuffer</code>是可变类，并且使用了同步机制，因此是线程安全的，适用于多线程环境。<code>StringBuilder</code>是可变类，但没有使用同步机制，因此在多线程环境中不是线程安全的。</li><li><strong>性能对比</strong>：StringBuilder&gt;StringBuffer&gt;String。由于<code>String</code>是不可变类，每次对<code>String</code>进行修改都会创建新的对象，因此在大量修改字符串的场景下，性能较差。<code>StringBuffer</code>使用同步机制来保证线程安全，因此相对于<code>StringBuilder</code>会有一些性能损失。<code>StringBuilder</code>没有同步机制，因此在单线程环境下，性能最好。</li></ul></blockquote><h2 id="什么是字符串常量池？"><a href="#什么是字符串常量池？" class="headerlink" title="什么是字符串常量池？"></a>什么是字符串常量池？</h2><blockquote><p>字符串常量是在代码中直接使用双引号括起来的字符串字面量，它们是不可变的，一旦创建，其值无法被修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;<span class="comment">// 在字符串常量池中创建一个&quot;Hello&quot;字符串对象，并将其引用赋值给str</span></span><br></pre></td></tr></table></figure><p>字符串常量池（String Pool）是Java中用于存储字符串常量的一块特殊内存区域，是在堆内存中的一个固定区域。当创建一个字符串常量时，虚拟机会首先检查字符串常量池中是否存在相同内容的字符串，如果存在则返回已存在的字符串对象的引用，否则将该字符串加入到常量池中，并返回它的引用。这样可以避免创建多个相同内容的字符串对象，节省内存空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;<span class="comment">// 在字符串常量池中创建一个&quot;Hello&quot;字符串对象，并将其引用赋值给str1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;<span class="comment">// 直接使用同样的字符串常量，并将其引用赋值给str2</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> (str1 == str2);<span class="comment">// 比较str1和str2的引用是否指向同一个对象</span></span><br><span class="line">System.out.println(result); <span class="comment">// 输出结果为 true，因为它们引用的是同一个字符串常量</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="怎样将字符串添加到常量池？"><a href="#怎样将字符串添加到常量池？" class="headerlink" title="怎样将字符串添加到常量池？"></a>怎样将字符串添加到常量池？</h2><blockquote><p>以下情况下，可以将字符串添加到字符串常量池中：</p><ol><li><strong>字符串常量直接赋值</strong>：当使用双引号括起来的字符串字面量直接赋值给一个字符串变量时，如果常量池中不存在相同值的字符串，JVM 会将该字符串对象的引用自动加入字符串常量池。</li><li><strong>调用 intern() 方法</strong>：通过在字符串对象上调用 <code>intern()</code> 方法，可以将该字符串对象的引用手动添加到字符串常量池中。如果常量池中已经存在相同值的字符串，会返回常量池中的引用。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 在字符串常量池中创建一个&quot;Hello&quot;字符串对象，并将其引用赋值给str1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 创建一个新的字符串对象，在堆内存中分配空间存储&quot;Hello&quot;，并将其引用赋值给str2</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> str2.intern(); <span class="comment">// 将str2所引用的字符串对象添加到字符串常量池中，并返回该字符串在常量池中的引用</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result1</span> <span class="operator">=</span> (str1 == str2);<span class="comment">// 比较str1和str2的引用是否指向同一个对象</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result2</span> <span class="operator">=</span> (str1 == str3);<span class="comment">// 比较str1和str3的引用是否指向同一个对象</span></span><br><span class="line">System.out.println(result1); <span class="comment">// 输出：false，因为str1和str2引用的是不同的对象，一个在常量池中，一个在堆内存中</span></span><br><span class="line">System.out.println(result2); <span class="comment">// 输出：true，因为str3引用的是常量池中的字符串对象，与str1引用的对象相同</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="说一说-amp-与-amp-amp-的区别？"><a href="#说一说-amp-与-amp-amp-的区别？" class="headerlink" title="说一说&amp;与&amp;&amp;的区别？"></a>说一说&amp;与&amp;&amp;的区别？</h2><blockquote><p><code>&amp;</code>表示按位与，可以用于布尔类型或者整数类型。</p><ul><li><p><strong>用于布尔类型</strong>：对于布尔类型，当两个操作数都为<code>true</code>时，结果为<code>true</code>，否则结果为<code>false</code>。无论第一个表达式的结果如何，第二个表达式总会被计算。</p></li><li><p><strong>用于整数类型</strong>：对于整数类型，会将两个操作数的二进制表示的每一位进行逻辑与运算，得到的结果为一个新的整数。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">a</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        System.out.println(a &amp; b);  <span class="comment">// 输出结果为 false</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;  <span class="comment">// 二进制表示为 00000101</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">3</span>;  <span class="comment">// 二进制表示为 00000011</span></span><br><span class="line">        System.out.println(x &amp; y);<span class="comment">// 按位与运算得到结果 00000001，即 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&amp;&amp;</code>表示短路与，只能用于两个布尔类型。</p><ul><li><strong>用于布尔类型</strong>：对于布尔类型，当第一个操作数为<code>false</code>时，不会对第二个操作数进行求值，直接返回<code>false</code>，因此它可以避免不必要的计算。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">a</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        System.out.println(a &amp;&amp; b);  <span class="comment">// 输出结果为 false，因为第一个操作数为 false，不会对第二个操作数进行求值，直接返回 false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="说一说-与-的区别？"><a href="#说一说-与-的区别？" class="headerlink" title="说一说|与||的区别？"></a>说一说|与||的区别？</h2><blockquote><p><code>|</code>表示按位或，可以用于布尔类型或者整数类型。</p><ul><li><strong>用于布尔类型</strong>：对于布尔类型，当两个操作数中至少有一个为<code>true</code>时，结果为<code>true</code>，否则结果为<code>false</code>。</li><li><strong>用于整数类型</strong>：对于整数类型，会将两个操作数的二进制表示的每一位进行逻辑或运算，得到的结果为一个新的整数。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">a</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        System.out.println(a | b); <span class="comment">// 输出结果为 true</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>; <span class="comment">// 二进制表示为 00000101</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">3</span>; <span class="comment">// 二进制表示为 00000011</span></span><br><span class="line">        System.out.println(x | y); <span class="comment">// 按位或运算得到结果 00000111，即 7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>||</code>表示逻辑或，只能用于两个布尔类型。</p><ul><li><strong>用于布尔类型</strong>：当第一个操作数为<code>true</code>时，不会对第二个操作数进行求值，直接返回<code>true</code>，因此它可以避免不必要的计算。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">a</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        System.out.println(a || b);  <span class="comment">// 输出结果为 true，因为第一个操作数为 true，不会对第二个操作数进行求值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="说一说-x3D-与-x3D-x3D-的区别？"><a href="#说一说-x3D-与-x3D-x3D-的区别？" class="headerlink" title="说一说&#x3D;与&#x3D;&#x3D;的区别？"></a>说一说&#x3D;与&#x3D;&#x3D;的区别？</h2><blockquote><p><code>=</code>是赋值运算符，用于将右侧的值赋给左侧的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;  <span class="comment">// 将 a + b 的结果赋给变量 c</span></span><br><span class="line">           System.out.println(c);<span class="comment">// 输出 30</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>==</code>是相等运算符，用于比较两个操作数的值（对于基本数据类型）或对象引用（对于引用类型）是否相等，并返回一个布尔值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">           <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">           <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">           <span class="type">boolean</span> <span class="variable">result1</span> <span class="operator">=</span> (x == y); <span class="comment">// 检查 x 和 y 的值是否相等，得到的结果为 false</span></span><br><span class="line">           System.out.println(result1); <span class="comment">// 输出结果为 false</span></span><br><span class="line"></span><br><span class="line">           <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">           <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">           <span class="type">boolean</span> <span class="variable">result2</span> <span class="operator">=</span> (str1 == str2); <span class="comment">// 检查 str1 和 str2 引用的对象是否相等</span></span><br><span class="line">           System.out.println(result2); <span class="comment">// 输出结果为 true，因为它们引用的是同一个字符串常量</span></span><br><span class="line"></span><br><span class="line">           <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">           <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">           <span class="type">boolean</span> <span class="variable">result3</span> <span class="operator">=</span> (str3 == str4); <span class="comment">// 检查 str3 和 str4 引用的对象是否相等</span></span><br><span class="line">           System.out.println(result3); <span class="comment">// 输出结果为 false，因为它们引用的是两个不同的字符串对象</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="为什么str1-x3D-x3D-str2输出结果为-true-？"><a href="#为什么str1-x3D-x3D-str2输出结果为-true-？" class="headerlink" title="为什么str1 &#x3D;&#x3D; str2输出结果为 true ？"></a>为什么str1 &#x3D;&#x3D; str2输出结果为 true ？</h2><blockquote><p>在 Java 中，字符串常量池是一个特殊的存储区域，用于存储字符串常量。当我们使用 String str &#x3D; “Hello” 这种方式创建字符串对象时，Java 会首先检查常量池中是否存在值为 “Hello” 的字符串对象，如果存在，则将引用指向该对象，如果不存在，则在常量池中创建一个新的字符串对象，并将引用指向它。因此，在常量池中只会存在一个值为 “Hello” 的字符串对象。而 &#x3D;&#x3D; 运算符在比较引用数据类型时，比较的是引用地址是否一致，str1与str2引用都指向一个 “Hello” 的字符串对象，所以str1 &#x3D;&#x3D; str2输出结果为 true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 在字符串常量池中创建一个&quot;Hello&quot;字符串对象，并将其引用赋值给str1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 直接使用同样的字符串常量，并将其引用赋值给str2</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> (str1 == str2); <span class="comment">// 比较str1和str2的引用是否指向同一个对象</span></span><br><span class="line">System.out.println(result); <span class="comment">// 输出结果为 true，因为它们引用的是同一个字符串常量</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="为什么str3-x3D-x3D-str4输出结果为-false-？"><a href="#为什么str3-x3D-x3D-str4输出结果为-false-？" class="headerlink" title="为什么str3 &#x3D;&#x3D; str4输出结果为 false ？"></a>为什么str3 &#x3D;&#x3D; str4输出结果为 false ？</h2><blockquote><p>使用 new 关键字会在堆内存中分配新的内存空间，每次都会创建一个新的对象。因此使用 String str &#x3D; new String(“Hello”) 这种方式创建字符串对象时，不管常量池中是否已经存在值为 “Hello” 的字符串对象，都会在堆内存中创建一个新的字符串对象。而 &#x3D;&#x3D; 运算符在比较引用数据类型时，比较的是引用地址是否一致，str3与str4的引用会指向堆内存中不同的字符串对象，所以str3 &#x3D;&#x3D; str4输出结果为 false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 创建一个新的字符串对象，在堆内存中分配空间存储&quot;Hello&quot;，并将其引用赋值给str3</span></span><br><span class="line">&gt;<span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 创建一个新的字符串对象，在堆内存中分配空间存储&quot;Hello&quot;，并将其引用赋值给str4</span></span><br><span class="line">&gt;<span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> (str3 == str4); <span class="comment">// 比较str3和str4的引用是否指向同一个对象</span></span><br><span class="line">&gt;System.out.println(result); <span class="comment">// 输出结果为 false，因为它们引用的是两个不同的字符串对象</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="说一说-x3D-x3D-与equals-有什么区别？"><a href="#说一说-x3D-x3D-与equals-有什么区别？" class="headerlink" title="说一说&#x3D;&#x3D;与equals()有什么区别？"></a>说一说&#x3D;&#x3D;与equals()有什么区别？</h2><blockquote><h2 id="x3D-x3D-运算符"><a href="#x3D-x3D-运算符" class="headerlink" title="&#x3D;&#x3D;运算符"></a>&#x3D;&#x3D;运算符</h2><p>&#x3D;&#x3D;是一个运算符</p><ul><li><p><strong>对于基本数据类型</strong>：&#x3D;&#x3D;比较的是值是否相等</p></li><li><p><strong>对于引用数据类型</strong>：&#x3D;&#x3D;比较的是引用地址是否一致</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result1</span> <span class="operator">=</span> (a == b); <span class="comment">// 使用==运算符比较两个整数的值</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result2</span> <span class="operator">=</span> (str1 == str2); <span class="comment">// 使用==运算符比较两个字符串的引用地址</span></span><br><span class="line">        System.out.println(result1); <span class="comment">// 输出：true</span></span><br><span class="line">        System.out.println(result2); <span class="comment">// 输出：false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h2><p>equals()是Object类中的一个方法</p><ul><li><p><strong>对于基本数据类型</strong>：不能使用equals()进行比较，因为基本数据类型的变量并不是对象，所以不继承于Object，不能调用equals()</p></li><li><p><strong>对于引用数据类型</strong>：equals()默认比较的是引用地址，因为equals()底层是使用&#x3D;&#x3D;运算符，通常我们希望比较引用类型的对象内容是否相等，所以一般自定义的Bean都会重写equals()方法</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="说一说Object类中的常见方法？"><a href="#说一说Object类中的常见方法？" class="headerlink" title="说一说Object类中的常见方法？"></a>说一说Object类中的常见方法？</h2><blockquote><ol><li><code>equals(Object obj)</code>：用于比较两个对象是否相等，默认实现比较的是对象的内存地址，通常需要重写该方法来比较对象的属性值。</li><li><code>hashCode()</code>：返回对象的哈希码值，用于在哈希表等数据结构中高效地存储和检索对象，默认实现根据对象的内存地址计算哈希码。</li><li><code>toString()</code>：返回对象的字符串表示，通常会在输出对象时使用，默认实现返回类名和对象的哈希码。</li><li><code>getClass()</code>：返回对象的运行时类对象，用于获取对象所属的类。</li><li><code>clone()</code>：创建并返回对象的副本，通常需要实现Cloneable接口并重写该方法。</li><li><code>instanceof</code>：用于判断对象是否属于某个类或接口的实例。</li><li><code>wait()</code>：使当前线程进入等待状态。</li><li><code>notify()、notifyAll()</code>：用于唤醒在该对象上等待的线程</li></ol></blockquote><h2 id="hashCode-和equals-的区别？"><a href="#hashCode-和equals-的区别？" class="headerlink" title="hashCode()和equals()的区别？"></a>hashCode()和equals()的区别？</h2><blockquote><p>hashCode()和equals()是Java中Object类的两个方法，用于处理对象的相等性判断。</p><ul><li><p><strong>hashCode()方法</strong>：返回对象的哈希码（散列码），是一个int类型的整数。它用于在哈希表等数据结构中快速定位对象。</p></li><li><p><strong>equals()方法</strong>：用于判断两个对象是否相等。默认情况下，equals()方法与”&#x3D;&#x3D;”操作符具有相同的行为，即判断两个对象的引用是否相同。</p></li></ul></blockquote><h2 id="为什么重写equals-要重写hashCode-？"><a href="#为什么重写equals-要重写hashCode-？" class="headerlink" title="为什么重写equals()要重写hashCode()？"></a>为什么重写equals()要重写hashCode()？</h2><blockquote><p>在每个类中，在重写equals()方法的时侯，一定要重写hashcode()方法。</p><ol><li>Object规范要求：如果两个对象通过equals()方法比较相等，那么它们的hashCode()方法返回的值必须相等。这意味着，在重写equals()方法时，如果判断两个对象相等，就必须确保它们的hashCode()方法返回相同的值。</li><li>equals()方法的目的是用于比较两个对象是否在逻辑上相等。默认的equals()方法比较的是对象的内存地址，也就是判断两个对象是否引用同一个实例。在重写equals()方法时，通常是根据需要比较对象的属性值，而不是仅仅比较内存地址。</li><li>hashCode()方法返回对象的哈希码值，用于在哈希表等数据结构中高效地存储和检索对象。默认的hashCode()方法根据对象的内存地址计算哈希码。</li><li>在equals()方法与hashCode()方法都未重写的情况下，假如有两个对象的内存地址相同，对象的属性值也相同，equals()方法会比较内存地址判断为true，hashCode()方法根据对象的内存地址计算的哈希码会相同，符合Object规范要求</li><li>在equals()方法重写但hashCode()方法未重写的情况下，假如对象的内存地址不相同，但对象的属性值相同，此时equals()方法会比较对象的属性值同样判断为true，但hashCode()方法根据对象的内存地址计算的哈希码可能不相同，不符合Object规范要求</li></ol></blockquote><h1 id="Java面向对象相关面试题"><a href="#Java面向对象相关面试题" class="headerlink" title="Java面向对象相关面试题"></a>Java面向对象相关面试题</h1><h2 id="什么是面向对象思想？"><a href="#什么是面向对象思想？" class="headerlink" title="什么是面向对象思想？"></a>什么是面向对象思想？</h2><blockquote><h2 id="面向过程思想"><a href="#面向过程思想" class="headerlink" title="面向过程思想"></a>面向过程思想</h2><h3 id="什么是过程？"><a href="#什么是过程？" class="headerlink" title="什么是过程？"></a>什么是过程？</h3><p><code>过程</code>是指一系列的<code>操作步骤或算法</code>，每个步骤按照特定的顺序执行，直至达到预期的结果。比如现在要制作一杯咖啡，可以将制作咖啡的过程进行分解</p><ol><li>研磨咖啡豆：将咖啡豆研磨成粉末状。</li><li>加水：将适量的水倒入咖啡壶中。</li><li>冲泡咖啡：将咖啡粉末放入滤网中，然后将滤网放入咖啡壶中，倒入热水冲泡。</li><li>倒出咖啡：将冲泡好的咖啡倒入杯子中。</li><li>加调料：根据个人口味加入糖、牛奶等调料。</li></ol><h3 id="什么是面向过程？"><a href="#什么是面向过程？" class="headerlink" title="什么是面向过程？"></a>什么是面向过程？</h3><p>面向过程是一种基于功能的编程思想，强调了<code>解决问题的步骤和流程</code>，以过程&#x2F;函数为最小单位，考虑<code>怎么做</code>。</p><p>对于一个问题，在面向过程编程中，问题会被划分为多个步骤或函数，每个步骤或函数负责完成特定的功能，函数之间通过参数传递数据进行交互，通过调用函数来实现功能。这种方式更注重解决问题的步骤和流程，将问题划分为多个子任务，并按照一定的顺序执行这些子任务来解决问题。</p><p>假如现在有一个问题：如何把大象塞进冰箱？以面向过程的思想解决问题，可能需要以下的步骤：</p><ul><li>第一步：打开冰箱门。</li><li>第二步：把大象放进冰箱。</li><li>第三步：关闭冰箱门。</li></ul><h2 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h2><h3 id="什么是对象？"><a href="#什么是对象？" class="headerlink" title="什么是对象？"></a>什么是对象？</h3><p><code>对象</code>是对现实世界中<code>具体事物或概念</code>的抽象，每个对象都有自身的<code>特征</code>和<code>行为</code>，现实世界中每一个<code>具体事物或概念</code>都可以看做是一个对象</p><ul><li>比如现实世界中的一只<code>猫</code>或者一只<code>狗</code>，他们都可以看做是一个<code>对象</code></li><li>猫或者狗一般都具有颜色、体重等等<code>特征</code>和吃饭、睡觉等<code>行为</code></li><li>把现实世界中的对象抽象地体现在编程世界中，可以定义<code>类来描述对象</code>，定义<code>属性描述特征</code>，定义<code>方法描述行为</code></li></ul><h3 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h3><p>面向对象是一种编程思想，强调了<code>具备功能的对象</code>，以类&#x2F;对象为最小单位，考虑<code>谁来做</code>。</p><p>对于一个问题，在面向对象编程中，问题会被抽象为一组相互关联的功能对象，每个对象具有属性和方法。对象之间通过消息传递进行交互，通过调用对象的方法来实现功能。这种方式更注重问题领域中的对象和它们之间的关系，对象拥有自己的状态和行为，通过协同工作来解决问题。</p><p>假如现在有一个问题：如何把大象塞进冰箱？以面向对象的思想解决问题可能需要以下的步骤：</p><ol><li>第一步：创建一个冰箱对象。冰箱对象具有方法：<code>打开门()</code>和<code>关闭门()</code>。</li><li>第二步：创建一个大象对象。大象对象具有方法：<code>移动()</code>。</li><li>第三步：调用冰箱对象的<code>打开门()</code>方法。</li><li>第四步：调用大象对象的<code>移动()</code>方法，使其进入冰箱。</li><li>第五步：调用冰箱对象的<code>关闭门()</code>方法。</li></ol></blockquote><h2 id="面向对象的三大特征？"><a href="#面向对象的三大特征？" class="headerlink" title="面向对象的三大特征？"></a>面向对象的三大特征？</h2><blockquote><h2 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h2><p>（1）封装也称为信息隐藏，是指将数据以及对数据的操作，封装在一个操作单元（类）中，通过访问修饰符来控制数据的访问权限，仅对外公开必要的接口，从而隐藏对象的内部实现细节，增强了代码的可维护性和安全性。</p><p>（2）四个访问修饰符：private类访问级别、default包访问级别、protected子类访问级别、public公共访问级别</p><h2 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h2><p>（1）继承是指通过已有的类创建新类，实现代码的重用，减少重复编写相同的代码</p><p>（2）继承一般使用extends关键字来实现</p><p>（3）子类继承父类之后，子类会拥有父类的非私有属性和非私有方法，并且可以扩展或修改父类的功能，形成类之间的层次结构</p><h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><p>（1）定义：多态是指一个类的实例（对象）可以表现出多种形态</p><p>（2）实现多态的三要素：继承、重写、父类引用指向子类对象</p><p>（3）特点：编译看左边、运行看右边</p><ul><li><strong>编译看左边</strong>：当造对象时，父类的引用需要指向子类的对象</li><li><strong>运行看右边</strong>：当通过引用调用方法时，执行的是子类中的方法</li></ul></blockquote><h2 id="谈谈你对多态的理解？"><a href="#谈谈你对多态的理解？" class="headerlink" title="谈谈你对多态的理解？"></a>谈谈你对多态的理解？</h2><blockquote><p>（1）定义：多态是指一个类的实例（对象）可以表现出多种形态</p><p>（2）实现多态的三要素：继承、重写、父类引用指向子类对象</p><p>（3）特点：编译看左边、运行看右边</p><ul><li><strong>编译看左边</strong>：当造对象时，父类的引用需要指向子类的对象</li><li><strong>运行看右边</strong>：当通过引用调用方法时，执行的是子类中的方法</li></ul></blockquote><h2 id="构造方法有哪些特征？"><a href="#构造方法有哪些特征？" class="headerlink" title="构造方法有哪些特征？"></a>构造方法有哪些特征？</h2><blockquote><p>构造方法（Constructor）是一种特殊类型的方法，主要用于创建和初始化对象，具有以下特性：</p><ul><li><strong>构造方法名字与类名相同</strong>：构造方法的名称必须与类名完全相同</li><li><strong>构造方法没有返回值</strong>：构造方法没有返回类型，包括 <code>void</code>，也不需要使用 <code>return</code> 关键字。</li><li><strong>默认构造方法</strong>：如果一个类没有显式定义任何构造方法，编译器会自动提供一个默认的无参构造方法，它什么也不做。默认构造方法的访问修饰符通常为 public</li><li><strong>构造方法的重载</strong>：可以根据需要在类中定义多个构造方法，可以有不同的参数列表（参数的个数、顺序、类型不同），称为构造方法的重载。每个构造方法可以根据参数的不同来完成不同的初始化任务</li><li><strong>构造方法自动执行</strong>：当使用 <code>new</code> 关键字创建对象时，构造方法会自动执行，用于初始化新创建的对象，<code>只会执行一次</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>  &#123; </span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;<span class="comment">// 构造器中调用属性</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;<span class="comment">// 构造器中调用属性</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法的重载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;<span class="comment">// 构造器中调用属性</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;<span class="comment">// 构造器中调用属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></blockquote><h2 id="接口和抽象类有什么区别？"><a href="#接口和抽象类有什么区别？" class="headerlink" title="接口和抽象类有什么区别？"></a>接口和抽象类有什么区别？</h2><blockquote><ol><li><strong>定义方式</strong>：抽象类使用<code>abstract</code>关键字来修饰，接口使用<code>interface</code>关键字来修饰。</li><li><strong>构造函数</strong>：抽象类可以有构造函数，而接口不能有构造函数。</li><li><strong>代码块</strong>：抽象类中可以包含代码块，而接口中不能有代码块。</li><li><strong>成员变量</strong>：抽象类可以定义各种类型的成员变量，而接口中的变量默认为<code>public static final</code>型常量。</li><li><strong>方法</strong>：抽象类可以包含非抽象方法和抽象方法，而接口只能包含抽象方法、默认方法和静态方法。</li><li><strong>单继承与多实现</strong>：一个类可以继承一个抽象类，但只能实现多个接口。</li><li><strong>主要作用</strong>：抽象类用于作为其他类的基类，定义了一些通用行为和属性，子类可以继承这些通用行为和属性，并在需要的基础上进行扩展或修改。接口用于定义一组规范，描述了一个对象应该具备的行为</li></ol></blockquote><h2 id="重载（Overload）和重写（Override）的区别？"><a href="#重载（Overload）和重写（Override）的区别？" class="headerlink" title="重载（Overload）和重写（Override）的区别？"></a>重载（Overload）和重写（Override）的区别？</h2><blockquote><h2 id="重载（Overload）"><a href="#重载（Overload）" class="headerlink" title="重载（Overload）"></a>重载（Overload）</h2><p>发生在同一个类中，通过定义具有相同名称但参数列表不同的多个方法来实现</p><p>重载方法在编译时根据参数类型和数量进行静态绑定，编译器根据调用时传递的参数类型和数量确定要调用的具体方法。</p><h2 id="重写（Override）"><a href="#重写（Override）" class="headerlink" title="重写（Override）"></a>重写（Override）</h2><p>发生在子类与父类之间，子类重新定义了父类中已经存在的方法</p><p>重写方法必须具有与父类方法相同的名称、参数列表和兼容的返回类型，提供了对父类方法的替换实现</p><p>重写方法在运行时根据对象的实际类型进行动态绑定，当通过父类引用调用重写方法时，实际上会根据对象的类型执行相应的子类方法。</p><p>重写方法还需要遵循里氏代换原则，即子类对象可以替代父类对象出现的任何地方，并且不会影响程序的正确性。</p><h2 id="重载（Overload）和重写（Override）的区别"><a href="#重载（Overload）和重写（Override）的区别" class="headerlink" title="重载（Overload）和重写（Override）的区别"></a>重载（Overload）和重写（Override）的区别</h2><ul><li><strong>重载</strong>：发生在同一个类中，方法名称相同，参数列表不同，静态绑定，编译时多态。</li><li><strong>重写</strong>：发生在父类与子类之间，方法名称、参数列表和返回类型相同，动态绑定，运行时多态。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">    <span class="comment">// 父类的 printMessage() 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的 printMessage() 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类的重载方法 printMessage(String message)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的重载方法 printMessage(String message)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span> <span class="keyword">extends</span> <span class="title class_">ParentClass</span> &#123;</span><br><span class="line">    <span class="comment">// 子类重写了父类的 printMessage() 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类重写了父类的 printMessage() 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类重写了父类的 printMessage(String message) 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类重写了父类的重载方法 printMessage(String message)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类特有的重载方法 printMessage(int number)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printMessage</span><span class="params">(<span class="type">int</span> number)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类特有的重载方法 printMessage(int number)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="说说this与super的区别？"><a href="#说说this与super的区别？" class="headerlink" title="说说this与super的区别？"></a>说说this与super的区别？</h2><blockquote><p>在Java中，<code>this</code>和<code>super</code>都是关键字，用于访问对象的成员或调用父类的构造方法。</p><ul><li><strong>this关键字</strong>：<code>this</code>表示当前对象的引用，可以使用<code>this</code>关键字访问当前对象的成员变量、成员方法和构造方法。</li><li><strong>super关键字</strong>：<code>super</code>表示当前对象的父类（超类）的引用，可以使用<code>super</code>关键字访问父类的成员变量、成员方法和构造方法</li></ul></blockquote><h2 id="break、continue、return-的区别及作用？"><a href="#break、continue、return-的区别及作用？" class="headerlink" title="break、continue、return 的区别及作用？"></a>break、continue、return 的区别及作用？</h2><blockquote><p>在Java中，<code>break</code>、<code>continue</code> 和 <code>return</code> 是用于控制流程的关键字</p><ul><li><strong>break（结束当前循环）</strong>：break语句只能用于switch语句和循环语句中，用于终止某个语句块的执行，<code>结束当前循环</code></li><li><strong>continue（结束当次循环）</strong>：continue语句只能使用在循环结构中，<code>结束当次循环</code>，用于跳过其所在循环语句块的一次执行，继续下一次循环</li><li><strong>return（结束一个方法）</strong>：return语句并非专门用于结束循环的，用于<code>结束一个方法</code>。当一个方法执行到一个return语句时，这个方法将被结束。与break和continue不同的是，return直接结束整个方法，不管这个return处于多少层循环之内</li></ul></blockquote><h2 id="static关键字有什么作用？"><a href="#static关键字有什么作用？" class="headerlink" title="static关键字有什么作用？"></a>static关键字有什么作用？</h2><blockquote><p>static关键字可以用来修饰属性、方法、代码块、内部类。</p><ul><li><strong>修饰属性</strong>：用<code>static</code>修饰的属性为静态属性，也称为类变量。静态属性属于类本身，可以直接通过类名调用，无需创建类的实例对象。</li><li><strong>修饰方法</strong>：用<code>static</code>修饰的方法为静态方法，也称为类方法。静态方法属于类本身，可以直接通过类名调用，无需创建类的实例对象。静态方法中&#96;&#96;不能直接访问实例方法和实例变量，也不能使用this关键字、super关键字<code>。静态方法</code>不能被重写&#96;</li><li><strong>修饰代码块</strong>：用<code>static</code>修饰的代码块称为静态代码块。静态代码块在类加载时执行，并且只会执行一次。它可用于进行静态变量的初始化或其他静态操作。</li><li><strong>修饰内部类</strong>：用<code>static</code>修饰的内部类称为静态内部类。静态内部类与外部类间没有直接的关联，可以直接创建静态内部类的实例对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyClass.staticVariable = <span class="number">2</span>;<span class="comment">// 通过类名调用静态属性</span></span><br><span class="line">        MyClass.staticMethod();<span class="comment">// 通过类名调用静态方法</span></span><br><span class="line">        MyClass.StaticInnerClass.staticInnerMethod();<span class="comment">// 通过类名调用静态内部类中的静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> staticVariable;</span><br><span class="line">    <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> instanceVariable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 静态方法不能直接访问实例变量和实例方法</span></span><br><span class="line">        <span class="comment">// MyClass.instanceVariable = 2; // 直接访问实例变量会报错</span></span><br><span class="line">        <span class="comment">// MyClass.instanceMethod(); // 直接访问实例方法也会报错</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态方法不能使用this关键字、super关键字</span></span><br><span class="line">        <span class="comment">// System.out.println(MyClass.this.getClass()); // 使用this关键字会报错</span></span><br><span class="line">        <span class="comment">// System.out.println(MyClass.super.getClass()); // 使用super关键字也会报错</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">instanceMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实例方法可以直接访问静态变量和调用静态方法</span></span><br><span class="line">        MyClass.staticVariable = <span class="number">2</span>;</span><br><span class="line">        MyClass.staticMethod();</span><br><span class="line">        <span class="comment">// 也可以使用this关键字、super关键字</span></span><br><span class="line">        System.out.println(MyClass.<span class="built_in">this</span>.getClass());</span><br><span class="line">        System.out.println(MyClass.<span class="built_in">super</span>.getClass());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块，类加载时执行，仅执行一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 可用于进行静态变量的初始化或其他静态操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类，与外部类间没有直接的关联，可以直接创建静态内部类的实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticInnerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;静态内部方法被执行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">instanceInnerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;实例内部方法被执行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="final关键字有什么作用？"><a href="#final关键字有什么作用？" class="headerlink" title="final关键字有什么作用？"></a>final关键字有什么作用？</h2><blockquote><p>final关键字可以用来修饰的结构：类、方法、变量（成员变量、局部变量、形参、引用地址）</p><ul><li><strong>修饰类</strong>：用<code>final</code>修饰的类不能被其他类继承</li><li><strong>修饰方法</strong>：用<code>final</code>修饰的方法不能被子类重写</li><li><strong>修饰变量</strong>：用<code>final</code>修饰的变量表示常量，即其值一旦被初始化后就不能被修改。对于基本数据类型的变量，该值是不可变的；对于引用类型的变量，该引用不能再指向其他对象，但是该对象的内容可以被修改。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;<span class="comment">// 使用final修饰的 类MyClass，不能被继承</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">30</span>; <span class="comment">// 使用final修饰的 成员变量age，值不能被修改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用final修饰的 方法myMethod，不能被子类重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> num)</span> &#123;<span class="comment">// 使用final修饰方法的 形参num，值不能被修改</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 使用final修饰的 局部变量message，值不能被修改</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">// 使用final修饰的 引用地址obj，不能再指向其他对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="深拷贝和浅拷贝的区别？"><a href="#深拷贝和浅拷贝的区别？" class="headerlink" title="深拷贝和浅拷贝的区别？"></a>深拷贝和浅拷贝的区别？</h2><blockquote><h2 id="引用拷贝"><a href="#引用拷贝" class="headerlink" title="引用拷贝"></a>引用拷贝</h2><blockquote><p>引用拷贝只复制了对象的引用，新旧对象将指向同一块内存地址，修改新对象会影响到原对象，因为它们共享相同的数据</p></blockquote><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/引用拷贝.png" style="zoom:50%"><h2 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h2><blockquote><p>对象拷贝是通过调用对象的拷贝构造函数或克隆方法创建一个新的对象的副本。新对象与原对象是完全独立的，修改新对象不会影响到原对象。</p></blockquote><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/对象拷贝.png" style="zoom:50%"><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><blockquote><p>浅拷贝是创建一个新对象，然后将原始对象中的所有非静态成员变量的值复制给新对象。对于引用类型的成员变量，只复制了引用，而不是创建副本。所以，新对象和原对象中的引用类型成员变量仍然指向相同的对象。</p></blockquote><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/浅拷贝.png" style="zoom:50%"><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><blockquote><p>深拷贝是在创建新对象时，不仅复制原始对象中的基本类型成员变量的值，还复制引用类型成员变量所引用的对象。换句话说，深拷贝会递归地复制对象及其所有子对象，新对象和原对象完全独立。对象拷贝是通过调用对象的拷贝构造函数或克隆方法创建一个新的对象的副本。新对象与原对象是完全独立的，修改新对象不会影响到原对象。</p></blockquote><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/深拷贝.png" style="zoom:50%"></blockquote><h2 id="实现深拷贝的方法？"><a href="#实现深拷贝的方法？" class="headerlink" title="实现深拷贝的方法？"></a>实现深拷贝的方法？</h2><blockquote><h2 id="深拷贝实现方式一：继承Cloneable重写clone方法"><a href="#深拷贝实现方式一：继承Cloneable重写clone方法" class="headerlink" title="深拷贝实现方式一：继承Cloneable重写clone方法"></a>深拷贝实现方式一：继承Cloneable重写clone方法</h2><p>Java中的<code>clone()</code>方法支持对象的复制，但默认仅实现了浅拷贝。如果要实现深拷贝，需要将对象实现<code>Cloneable</code>接口，并重写<code>clone()</code>方法。在<code>clone()</code>方法内部，将对象及其内部所有属性全部复制一份即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 深拷贝</span></span><br><span class="line"> <span class="keyword">public</span> Person <span class="title function_">deepCopy</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">     List&lt;String&gt; clonedHobbies = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.hobbies);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="built_in">this</span>.name, clonedHobbies);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> class 深拷贝 &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">     List&lt;String&gt; hobbies = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">     hobbies.add(<span class="string">&quot;读书&quot;</span>);</span><br><span class="line">     hobbies.add(<span class="string">&quot;游泳&quot;</span>);</span><br><span class="line">     <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小明&quot;</span>, hobbies);</span><br><span class="line"></span><br><span class="line">     <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> person1.deepCopy();<span class="comment">// 深拷贝</span></span><br><span class="line">     person2.setName(<span class="string">&quot;小刚&quot;</span>);</span><br><span class="line"></span><br><span class="line">     System.out.println(person1);<span class="comment">// copy.浅拷贝.Person@7f31245a</span></span><br><span class="line">     System.out.println(person2);<span class="comment">// copy.浅拷贝.Person@6d6f6e28</span></span><br><span class="line">     System.out.println(person1 == person2); <span class="comment">// 输出 false 说明引用地址不一样</span></span><br><span class="line"></span><br><span class="line">     System.out.println(person1.getName()); <span class="comment">// 输出 小明</span></span><br><span class="line">     System.out.println(person2.getName()); <span class="comment">// 输出 小明</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 修改person2的hobbies列表</span></span><br><span class="line">     person2.getHobbies().add(<span class="string">&quot;唱歌&quot;</span>);</span><br><span class="line"></span><br><span class="line">     System.out.println(person1.getHobbies()); <span class="comment">// 输出 [读书, 游泳]</span></span><br><span class="line">     System.out.println(person2.getHobbies()); <span class="comment">// 输出 [读书, 游泳, 唱歌]</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深拷贝实现方式二：使用序列化"><a href="#深拷贝实现方式二：使用序列化" class="headerlink" title="深拷贝实现方式二：使用序列化"></a>深拷贝实现方式二：使用序列化</h2><p>通过将对象序列化为字节流，再将字节流反序列化为新的对象，就可以实现深拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"> <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 深拷贝</span></span><br><span class="line"> <span class="keyword">public</span> Person <span class="title function_">deepCopy</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">     <span class="type">ByteArrayOutputStream</span> <span class="variable">byteOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">     <span class="type">ObjectOutputStream</span> <span class="variable">objectOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteOut);</span><br><span class="line">     objectOut.writeObject(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">     <span class="type">ByteArrayInputStream</span> <span class="variable">byteIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteOut.toByteArray());</span><br><span class="line">     <span class="type">ObjectInputStream</span> <span class="variable">objectIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteIn);</span><br><span class="line">     <span class="keyword">return</span> (Person) objectIn.readObject();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 深拷贝 &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">     List&lt;String&gt; hobbies = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">     hobbies.add(<span class="string">&quot;读书&quot;</span>);</span><br><span class="line">     hobbies.add(<span class="string">&quot;游泳&quot;</span>);</span><br><span class="line">     <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小明&quot;</span>, hobbies);</span><br><span class="line"></span><br><span class="line">     <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> person1.deepCopy(); <span class="comment">// 深拷贝</span></span><br><span class="line">     person2.setName(<span class="string">&quot;小刚&quot;</span>);</span><br><span class="line"></span><br><span class="line">     System.out.println(person1); <span class="comment">// 输出 copy.深拷贝.Person@7f31245a</span></span><br><span class="line">     System.out.println(person2); <span class="comment">// 输出 copy.深拷贝.Person@6d6f6e28</span></span><br><span class="line">     System.out.println(person1 == person2); <span class="comment">// 输出 false，说明引用地址不一样</span></span><br><span class="line"></span><br><span class="line">     System.out.println(person1.getName()); <span class="comment">// 输出 小明</span></span><br><span class="line">     System.out.println(person2.getName()); <span class="comment">// 输出 小刚</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 修改person2的hobbies列表</span></span><br><span class="line">     person2.getHobbies().add(<span class="string">&quot;唱歌&quot;</span>);</span><br><span class="line"></span><br><span class="line">     System.out.println(person1.getHobbies()); <span class="comment">// 输出 [读书, 游泳]</span></span><br><span class="line">     System.out.println(person2.getHobbies()); <span class="comment">// 输出 [读书, 游泳, 唱歌]</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深拷贝实现方式三：使用工具"><a href="#深拷贝实现方式三：使用工具" class="headerlink" title="深拷贝实现方式三：使用工具"></a>深拷贝实现方式三：使用工具</h2><p>Spring包下的org.springframework.beans.BeanUtils.copyProperties()；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyProperties</span><span class="params">(Object source, Object target)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"> copyProperties(source, target, <span class="literal">null</span>, (String[]) <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Apeche包下的org.apache.commons.beanutils.BeanUtils.copyProperties();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyProperties</span><span class="params">(Object dest, Object orig)</span> <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException &#123;</span><br><span class="line"> BeanUtilsBean.getInstance().copyProperties(dest, orig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="说一说Java的四种引用方式？"><a href="#说一说Java的四种引用方式？" class="headerlink" title="说一说Java的四种引用方式？"></a>说一说Java的四种引用方式？</h2><blockquote><h2 id="强引用（Strong-Reference）"><a href="#强引用（Strong-Reference）" class="headerlink" title="强引用（Strong Reference）"></a>强引用（Strong Reference）</h2><p>强引用是最常见的引用类型，如果一个对象具有强引用，就表示垃圾回收器不会对其进行回收。即使内存空间不足时，垃圾回收器也不会回收被强引用关联的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 强引用</span></span><br></pre></td></tr></table></figure><h2 id="软引用（Soft-Reference）"><a href="#软引用（Soft-Reference）" class="headerlink" title="软引用（Soft Reference）"></a>软引用（Soft Reference）</h2><p>软引用用于描述还有用但并非必需的对象。在系统内存不足时，垃圾回收器可能会回收软引用关联的对象来释放内存。可以使用<code>SoftReference</code>类来创建软引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;Object&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 软引用</span></span><br></pre></td></tr></table></figure><h2 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a>弱引用（Weak Reference）</h2><p>弱引用用于描述非必需对象。无论系统内存是否充足，只要发生垃圾回收操作，垃圾回收器都会回收掉只被弱引用关联的对象。可以使用<code>WeakReference</code>类来创建弱引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;Object&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 弱引用</span></span><br></pre></td></tr></table></figure><h2 id="虚引用（Phantom-Reference）"><a href="#虚引用（Phantom-Reference）" class="headerlink" title="虚引用（Phantom Reference）"></a>虚引用（Phantom Reference）</h2><p>虚引用用于管理对象被垃圾回收器回收的时机。虚引用与其他引用类型的主要区别在于，无法通过虚引用访问对象，也无法通过虚引用获取对对象的引用。可以使用<code>PhantomReference</code>类来创建虚引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;Object&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>(), referenceQueue); <span class="comment">// 虚引用</span></span><br></pre></td></tr></table></figure><h2 id="四种引用的区别"><a href="#四种引用的区别" class="headerlink" title="四种引用的区别"></a>四种引用的区别</h2><table><thead><tr><th>引用类型</th><th>垃圾回收行为</th><th>生存时间</th><th>用途</th></tr></thead><tbody><tr><td>强引用 (Strong Reference)</td><td>不会被回收</td><td>长期存在，直到引用被显式释放</td><td>主要引用类型，常用于对象的正常引用</td></tr><tr><td>软引用 (Soft Reference)</td><td>在内存不足时可能被回收</td><td>长期存在，直到内存不足时回收</td><td>用于缓存或者需要某些操作前的临时引用</td></tr><tr><td>弱引用 (Weak Reference)</td><td>在垃圾回收时可能被回收</td><td>长期存在，直到没有强引用</td><td>用于实现缓存、监控和弱关联等功能</td></tr><tr><td>虚引用 (Phantom Reference)</td><td>在垃圾回收时可能被回收</td><td>一旦被垃圾回收器处理完毕即消失</td><td>用于对象被回收前的清理工作或跟踪回收状态</td></tr></tbody></table></blockquote><h2 id="什么是序列化与反序列化？"><a href="#什么是序列化与反序列化？" class="headerlink" title="什么是序列化与反序列化？"></a>什么是序列化与反序列化？</h2><blockquote><p>在 Java 中，序列化和反序列化是一种用于对象与字节流互相转换，以便存储或传输的机制。</p><ul><li><strong>序列化</strong>：对象—&gt;字节序列</li><li><strong>反序列化</strong>：字节序列—&gt;对象</li></ul></blockquote><h2 id="什么情况需要序列化与反序列化"><a href="#什么情况需要序列化与反序列化" class="headerlink" title="什么情况需要序列化与反序列化?"></a>什么情况需要序列化与反序列化?</h2><blockquote><p>当 Java 对象需要在网络传输或持久化存储到文件中时，需要序列化</p><ul><li><strong>网络传输</strong>：当需要将 Java 对象在网络上进行传输时，可以使用序列化将对象转换为字节流，然后通过网络发送给接收方。例如，在客户端和服务器之间进行通信时，可以将请求或响应对象序列化并通过网络传输。这样，对象的信息就可以在不同的计算机或进程之间传递，实现分布式系统的协作。</li><li><strong>持久化存储</strong>：当需要将 Java 对象保存到磁盘或数据库中以供以后使用时，可以使用序列化将对象写入文件或数据库字段。序列化后的对象可以被存储，稍后可以从存储位置读取并恢复为原始对象。这种持久化存储方式适用于需要长期保留对象状态的情况，比如保存用户配置、缓存数据、日志等。</li></ul></blockquote><h2 id="序列化与反序列化有什么前提？"><a href="#序列化与反序列化有什么前提？" class="headerlink" title="序列化与反序列化有什么前提？"></a>序列化与反序列化有什么前提？</h2><blockquote><p>在 Java 中，让一个对象可序列化与反序列化，需要满足以下要求：</p><ol><li><strong>实现 <code>Serializable</code> 接口</strong>：将要序列化的类实现 <code>Serializable</code> 接口，<code>Serializable</code> 接口是 Java 提供的一个标记接口，接口中没有任何方法定义，用于标识一个类可以被序列化和反序列化。</li><li><strong>提供 <code>private static final long serialVersionUID</code> 常量</strong>：这个常量用于表示类的版本号，它在反序列化时用于判断对象和字节流之间的兼容性。如果没有显式地定义该字段，Java 编译器会自动生成一个版本号。</li><li><strong>内部所有属性也必须是可序列化的</strong>：将类的内部所有属性都标记为可序列化，这意味着它们要么是基本数据类型（如 <code>int</code>、<code>boolean</code> 等），要么是实现了 <code>Serializable</code> 接口的类。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Long id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SerializationExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个Person对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1L</span>, <span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将对象序列化到文件</span></span><br><span class="line">        serializeObject(person, <span class="string">&quot;person.ser&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从文件中反序列化对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">deserializedPerson</span> <span class="operator">=</span> (Person) deserializeObject(<span class="string">&quot;person.ser&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印反序列化后的对象信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;名字: &quot;</span> + deserializedPerson.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;年龄: &quot;</span> + deserializedPerson.getAge());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化对象到文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">serializeObject</span><span class="params">(Object obj, String filename)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileOutputStream</span> <span class="variable">fileOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filename);</span><br><span class="line">            <span class="type">ObjectOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOut);</span><br><span class="line">            out.writeObject(obj);</span><br><span class="line">            out.close();</span><br><span class="line">            fileOut.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;序列化的对象并保存到：&quot;</span> + filename);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件中反序列化对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title function_">deserializeObject</span><span class="params">(String filename)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fileIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename);</span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileIn);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> in.readObject();</span><br><span class="line">            in.close();</span><br><span class="line">            fileIn.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;反序列化的对象： &quot;</span> + filename);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="如果某些数据不想序列化与反序列化怎么办"><a href="#如果某些数据不想序列化与反序列化怎么办" class="headerlink" title="如果某些数据不想序列化与反序列化怎么办?"></a>如果某些数据不想序列化与反序列化怎么办?</h2><blockquote><h2 id="方式一：使用transient关键字"><a href="#方式一：使用transient关键字" class="headerlink" title="方式一：使用transient关键字"></a>方式一：使用transient关键字</h2><p>在Java中，<code>transient</code>是一个关键字，用来修饰类的成员变量。当一个变量被声明为<code>transient</code>时，它表示该变量不参与对象的序列化过程，将被跳过，不会被序列化，通常用于一些敏感信息或者不需要被序列化和传输的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"> <span class="keyword">private</span> String name; <span class="comment">// 使用transient关键字标识name字段不能被序列化与反序列化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方式二：自定义序列化方式"><a href="#方式二：自定义序列化方式" class="headerlink" title="方式二：自定义序列化方式"></a>方式二：自定义序列化方式</h2><p>可以实现Serializable接口，并在其中自定义序列化和反序列化过程，通过编写writeObject()和readObject()方法来控制序列化和反序列化的行为，在这些方法中可以决定哪些数据要被序列化，哪些数据要被忽略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"> <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 自定义序列化方法</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(ObjectOutputStream out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">     out.defaultWriteObject(); <span class="comment">// 默认的序列化操作</span></span><br><span class="line">     out.writeObject(name.toUpperCase()); <span class="comment">// 将 name 字段以大写形式写入输出流</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 自定义反序列化方法</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">     in.defaultReadObject(); <span class="comment">// 默认的反序列化操作</span></span><br><span class="line">     name = ((String) in.readObject()).toLowerCase(); <span class="comment">// 从输入流中读取字符串，并将其转换为小写形式</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方式三：使用Externalizable接口自定义序列化方式"><a href="#方式三：使用Externalizable接口自定义序列化方式" class="headerlink" title="方式三：使用Externalizable接口自定义序列化方式"></a>方式三：使用Externalizable接口自定义序列化方式</h2><p><code>Externalizable</code>接口是Java提供的一个用于实现自定义序列化的接口，相比Serializable接口更加灵活，使用步骤如下</p><ol><li>在类上实现<code>Externalizable</code>接口，并实现<code>writeExternal()</code>和<code>readExternal()</code>方法。</li><li>在<code>writeExternal()</code>方法中定义需要序列化的成员变量。</li><li>在<code>readExternal()</code>方法中定义如何从流中恢复成员变量的值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Externalizable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 自定义序列化过程，在这里定义哪些成员变量需要序列化</span></span><br><span class="line">        out.writeObject(name);<span class="comment">// // 将name字段手动写入到输出流中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 自定义反序列化过程，在这里恢复成员变量的值</span></span><br><span class="line">        name = (String) in.readObject();<span class="comment">// // 从输入流中手动读取name字段，并赋值给对象的相应字段</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h1 id="Java集合相关面试题"><a href="#Java集合相关面试题" class="headerlink" title="Java集合相关面试题"></a>Java集合相关面试题</h1><h2 id="有数组为什么还要有集合？"><a href="#有数组为什么还要有集合？" class="headerlink" title="有数组为什么还要有集合？"></a>有数组为什么还要有集合？</h2><blockquote><p>在Java中，数组（Array）是一种固定长度、连续的数据结构，用于保存多个相同类型的对象或数据。数组（Array）在创建时长度就固定，无法动态改变长度，如果需要改变数组的长度，需要通过数组拷贝的方式操作，不太方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure><p>为了解决数组长度固定和操作不便的问题，Java提供了一些集合类用于存储、操作和处理数据集合，这些集合类属于Java集合框架（Collections Framework），相比数组，集合具有以下优势：</p><ul><li><strong>动态改变长度</strong>：集合的长度是动态可变的，可以根据需要自动扩展或缩小。</li><li><strong>提供丰富的操作方法</strong>：集合类提供了许多方便的方法来添加、删除、查找、遍历等操作，简化了对集合的操作。</li><li><strong>支持泛型</strong>：集合类支持泛型，可以在编译时强制类型检查，提高代码的安全性和可读性。</li><li><strong>提供迭代器</strong>：集合类提供了迭代器（Iterator）来遍历集合元素，可以方便地进行循环操作。</li><li><strong>内置算法和排序</strong>：集合类内置了各种算法和排序方法，可以方便地对集合元素进行排序、查找和比较等操作。</li></ul></blockquote><h2 id="Java集合框架的基础接口有哪些？"><a href="#Java集合框架的基础接口有哪些？" class="headerlink" title="Java集合框架的基础接口有哪些？"></a>Java集合框架的基础接口有哪些？</h2><blockquote><p>在 Java 集合框架中，有两个基本的根接口，分别是 <code>Collection</code> 单列集合接口和 <code>Map</code> 双列集合接口。</p><h2 id="Collection单列集合接口"><a href="#Collection单列集合接口" class="headerlink" title="Collection单列集合接口"></a>Collection单列集合接口</h2><p><code>Collection</code> 接口是存储单列集合对象的根接口，其中包括 <code>List</code>、<code>Set</code> 和 <code>Queue</code> 接口</p><ul><li><strong>List接口</strong>：单列有序集合，存储<code>有序</code>、<code>可重复</code>的对象，对象按插入顺序有序排列，元素可重复。常用的实现类有ArrayList、LinkedList、Vector</li><li><strong>Set接口</strong>：单列无序集合，存储<code>无序</code>、<code>不可重复</code>的对象，对象按一定规则无序排列，元素不可重复。常用的实现类有HashSet、LinkedHashSet、TreeSet</li><li><strong>Queue接口</strong>：队列，存储<code>有序</code>、<code>可重复</code>的对象，对象按照先进先出（FIFO）的原则进行操作。常用的实现类有：ArrayDeque、ArrayBlockingQueue、PriorityQueue</li></ul><h2 id="Map双列集合接口"><a href="#Map双列集合接口" class="headerlink" title="Map双列集合接口"></a>Map双列集合接口</h2><ul><li><strong>Map接口</strong>：双列集合，存储键值对映射，键和值可以是任意类型的对象，可以根据键（key）来获取对应的值（value）。常用的实现类有HashMap、LinkedHashMap、TreeMap、Hashtable、Properties</li></ul></blockquote><h2 id="这些接口常见的实现类有哪些？"><a href="#这些接口常见的实现类有哪些？" class="headerlink" title="这些接口常见的实现类有哪些？"></a>这些接口常见的实现类有哪些？</h2><blockquote><h2 id="List接口常见实现类"><a href="#List接口常见实现类" class="headerlink" title="List接口常见实现类"></a>List接口常见实现类</h2><p>单列有序集合，存储<code>有序</code>、<code>可重复</code>的对象，对象按插入顺序有序排列，元素可重复。常用的实现类有ArrayList、LinkedList、Vector</p><table><thead><tr><th>名称</th><th>底层数据结构</th><th>特点</th><th>线程安全性</th></tr></thead><tbody><tr><td>ArrayList</td><td>数组</td><td>查询快（支持随机访问），增删慢</td><td>不安全</td></tr><tr><td>LinkedList</td><td>双向链表</td><td>查询慢，增删快（支持快速插入和删除）</td><td>不安全</td></tr><tr><td>Vector</td><td>数组</td><td>查询快，增删慢，线程安全</td><td>安全</td></tr></tbody></table><h2 id="Set接口常见实现类"><a href="#Set接口常见实现类" class="headerlink" title="Set接口常见实现类"></a>Set接口常见实现类</h2><p>单列无序集合，存储<code>无序</code>、<code>不可重复</code>的对象，对象按一定规则无序排列，元素不可重复。常用的实现类有HashSet、LinkedHashSet、TreeSet</p><table><thead><tr><th>名称</th><th>底层数据结构</th><th>特点</th><th>线程安全性</th></tr></thead><tbody><tr><td>HashSet</td><td>哈希表（数组+链表&#x2F;红黑树）</td><td>不允许重复元素，不保证元素顺序</td><td>不安全</td></tr><tr><td>LinkedHashSet</td><td>哈希表（数组+双向链表）</td><td>不允许重复元素，但使用双向链表维护元素插入顺序</td><td>不安全</td></tr><tr><td>TreeSet</td><td>红黑树</td><td>不允许重复元素，元素可以自然顺序或指定Comparator排序</td><td>不安全</td></tr></tbody></table><h2 id="Queue接口常见实现类"><a href="#Queue接口常见实现类" class="headerlink" title="Queue接口常见实现类"></a>Queue接口常见实现类</h2><p>队列，存储<code>有序</code>、<code>可重复</code>的对象，对象按照先进先出（FIFO）的原则进行操作。常用的实现类有：ArrayDeque、ArrayBlockingQueue、PriorityQueue</p><table><thead><tr><th>名称</th><th>底层数据结构</th><th>特点</th><th>线程安全性</th></tr></thead><tbody><tr><td>ArrayDeque</td><td>数组</td><td>双端队列，支持在队头和队尾进行元素操作</td><td>不安全</td></tr><tr><td>ArrayBlockingQueue</td><td>数组</td><td>有界阻塞队列，支持并发操作具有固定容量限制</td><td>安全</td></tr><tr><td>PriorityQueue</td><td>堆（数组&#x2F;树）</td><td>优先级队列，按照元素的优先级进行排序</td><td>不安全</td></tr></tbody></table><h2 id="Map接口常见实现类"><a href="#Map接口常见实现类" class="headerlink" title="Map接口常见实现类"></a>Map接口常见实现类</h2><p>双列集合，存储键值对映射，键和值可以是任意类型的对象，可以根据键（key）来获取对应的值（value）。常用的实现类有HashMap、LinkedHashMap、TreeMap、Hashtable、Properties</p><table><thead><tr><th>名称</th><th>底层数据结构</th><th>特点</th><th>线程安全性</th></tr></thead><tbody><tr><td>HashMap</td><td>哈希表（数组+链表&#x2F;红黑树）</td><td>存储键值对映射，通过键的哈希值快速查找对应的值</td><td>不安全</td></tr><tr><td>LinkedHashMap</td><td>哈希表（数组+双向链表）</td><td>存储键值对映射，在HashMap的基础上使用双向链表维护键值对的插入顺序</td><td>不安全</td></tr><tr><td>TreeMap</td><td>红黑树</td><td>存储键值对映射，元素可以按照键自然顺序或指定Comparator排序</td><td>不安全</td></tr><tr><td>Hashtable</td><td>哈希表（数组+链表）</td><td>存储键值对映射，内部使用synchronized关键字实现同步</td><td>安全</td></tr><tr><td>Properties</td><td>哈希表（数组+链表）</td><td>存储键值对映射，继承自Hashtable类，主要用于处理属性文件</td><td>安全</td></tr></tbody></table></blockquote><h2 id="List、Set、Map-之间的区别是什么？"><a href="#List、Set、Map-之间的区别是什么？" class="headerlink" title="List、Set、Map 之间的区别是什么？"></a>List、Set、Map 之间的区别是什么？</h2><blockquote><h2 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h2><p>继承Collection接口，单列有序集合接口</p><p>允许重复的对象</p><p>具有顺序性，可以按照元素的插入顺序或索引进行访问。</p><p>常见实现类：ArrayList、LinkedList 和 Vector</p><h2 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h2><p>继承Collection接口，单列无序集合接口</p><p>不允许重复元素，每个元素在Set中是唯一的。</p><p>不保证元素的顺序性，即无法按照特定顺序访问元素。</p><p>常见实现类：HashSet、LinkedHashSet、TreeSet</p><h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><p>不继承Collection接口，双列集合接口</p><p>存储键值对的映射关系，可以根据键快速查找值</p><p>允许存在相同的值，但不允许存在相同的键。</p><p>常见实现类：HashMap、TreeMap、HashTable</p></blockquote><h2 id="数组（Array）-和-列表（List）-如何转换"><a href="#数组（Array）-和-列表（List）-如何转换" class="headerlink" title="数组（Array） 和 列表（List） 如何转换?"></a>数组（Array） 和 列表（List） 如何转换?</h2><blockquote><h2 id="Array-转-List"><a href="#Array-转-List" class="headerlink" title="Array 转 List"></a>Array 转 List</h2><p>数组（Array） 转 列表（List），使用<code>JDK提供的java.util.Arrays工具类中的asList()方法</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     String[] array = &#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;orange&quot;</span>&#125;;</span><br><span class="line">     List&lt;String&gt; list = Arrays.asList(array);</span><br><span class="line">     System.out.println(list);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="List-转-Array"><a href="#List-转-Array" class="headerlink" title="List 转 Array"></a>List 转 Array</h2><p>列表（List） 转 数组（Array） ，使用<code>List接口</code>中提供的<code>toArray()方法</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">     list.add(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">     list.add(<span class="string">&quot;banana&quot;</span>);</span><br><span class="line">     list.add(<span class="string">&quot;orange&quot;</span>);</span><br><span class="line">     String[] array = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">     <span class="keyword">for</span> (String s: array) &#123;</span><br><span class="line">         System.out.println(s);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="ArrayList的底层实现原理？"><a href="#ArrayList的底层实现原理？" class="headerlink" title="ArrayList的底层实现原理？"></a>ArrayList的底层实现原理？</h2><blockquote><ol><li>ArrayList底层是用 Object 类型的动态数组来存储元素。</li><li>当创建ArrayList集合时，ArrayList默认创建一个容量为0的空数组。</li><li>当第一次向 ArrayList 中添加元素时，会将空数组初始化为容量为10的数组。</li><li>后续向 ArrayList 中添加元素时，会先检查当前数组是否已满，如果数组未满，则直接将元素添加到数组的末尾。</li><li>如果数组已满，会触发扩容机制创建一个新数组（新数组的容量是旧集合容量的1.5倍），然后将旧数组中的元素拷贝到新数组中。</li><li>如果扩容时数组容量是偶数，那么新容量就是旧容量的1.5倍；</li><li>如果扩容时数组容量是奇数，会先将数组容量右移一位，然后再乘以1.5，得到新容量。</li><li>虽然扩容过程中数组的容量会逐渐增大，但并不会无限增大，不能超过MAX_ARRAY_SIZE（约为2^31-1）</li></ol></blockquote><h2 id="ArrayList扩容是怎么实现的"><a href="#ArrayList扩容是怎么实现的" class="headerlink" title="ArrayList扩容是怎么实现的?"></a>ArrayList扩容是怎么实现的?</h2><blockquote><p>ArrayList在添加元素时，如果达到了数组容量，会进行扩容操作</p><ol><li><strong>初始化数组容量</strong>：在创建ArrayList对象时，如果没有指定初始容量，默认会创建一个长度为10的数组。</li><li><strong>添加元素触发扩容</strong>：每当向ArrayList中添加元素时，都会检查当前元素数量是否已经达到了数组的容量。如果达到了数组容量，则触发扩容操作。</li><li><strong>创建新数组</strong>：一旦需要进行扩容，ArrayList会创建一个更大的新数组。新数组的大小通常是原始容量的1.5倍（即原始容量的*3&#x2F;2），这样可以提供更多的空间存储元素，并减少频繁扩容的次数。</li><li><strong>将元素拷贝到新数组</strong>：在扩容阶段，ArrayList会将原数组中的元素拷贝到新数组中。这个过程通过使用<code>System.arraycopy()</code>方法或者循环遍历原数组并逐个拷贝来实现。</li><li><strong>更新引用和容量</strong>：拷贝完成后，ArrayList会更新内部的数组引用指向新的数组，并更新容量信息。这样，后续的操作就可以使用新的数组以及更新后的容量信息了。</li></ol></blockquote><h2 id="ArrayList-和-LinkedList-有什么区别？"><a href="#ArrayList-和-LinkedList-有什么区别？" class="headerlink" title="ArrayList 和 LinkedList 有什么区别？"></a>ArrayList 和 LinkedList 有什么区别？</h2><blockquote><p><strong>数据结构</strong>：ArrayList数据结构是数组；LinkedList数据结构是双向链表</p><p><strong>访问效率</strong>：ArrayList访问效率高于LinkedList。数组通过下标方法，如果已经知道下标进行访问，时间复杂度为O(1)；链表如果有序可以使用二分法查找时间复杂度是O(log n)，如果链表无序，需要遍历查找元素，那么时间复杂度会降为O(n)</p><p><strong>增删效率</strong>：ArrayList增删效率低于LinkedList。数组如果不是尾插法，增删需要左右移动数组，效率低；链表增删只需要修改记录指针，效率高</p><p><strong>适用场景</strong>：ArrayList适用于频繁读取数据的场景；LinkedList适用于频繁插入和删除元素的场景</p></blockquote><h2 id="ArrayList-和-Vector-有什么区别？"><a href="#ArrayList-和-Vector-有什么区别？" class="headerlink" title="ArrayList 和 Vector 有什么区别？"></a>ArrayList 和 Vector 有什么区别？</h2><blockquote><p>ArrayList 和 Vector 都是List单列有序集合的接口实现类</p><ul><li><strong>线程安全性</strong>：ArrayList线程不安全；Vector线程安全</li><li><strong>性能对比</strong>：ArrayList性能比Vector高，因为Vector中的大部分方法会加同步锁，有开销</li></ul></blockquote><h2 id="HashSet-的底层实现原理？"><a href="#HashSet-的底层实现原理？" class="headerlink" title="HashSet 的底层实现原理？"></a>HashSet 的底层实现原理？</h2><blockquote><p>HashSet的底层实现原理是基于HashMap，HashSet实际上是使用了HashMap的key来存储元素，特点如下：</p><ul><li>HashSet是一个无序的集合，不允许存储重复元素，只允许存储一个 null 值</li><li>插入、删除、查找等操作的时间复杂度为O(1)，具有较高的性能。</li></ul><p>HashSet的底层实现利用了HashMap的键值对存储结构，但是在HashSet中只使用了HashMap的key部分。具体实现步骤如下：</p><ul><li>创建一个底层是HashMap的HashSet对象。</li><li>当向HashSet中插入一个元素时，实际上是以该元素作为HashMap的键（key），而将一个固定的Object对象作为HashMap的值（value）进行存储。</li><li>当需要判断HashSet中是否存在某个元素时，实际上是通过判断该元素作为HashMap的键（key）在HashMap中是否存在来进行判断。</li><li>HashSet中的元素存储是无序的，因为它是基于HashMap实现的，HashMap中的元素顺序是根据哈希算法得出的。</li></ul></blockquote><h2 id="HashSet-和-LinkedHashSet-有什么区别？"><a href="#HashSet-和-LinkedHashSet-有什么区别？" class="headerlink" title="HashSet 和 LinkedHashSet 有什么区别？"></a>HashSet 和 LinkedHashSet 有什么区别？</h2><blockquote><p>HashSet和LinkedHashSet都是Java集合框架中的Set接口的实现类，都不允许元素重复，都不是线程安全的</p><ul><li><strong>数据结构</strong>：HashSet的底层实现原理是基于HashMap，底层数据结构是哈希表（数组+链表&#x2F;红黑树）；LinkedHashSet继承于HashSet，但数据结构使用哈希表（数组+双向链表）</li><li><strong>存储顺序</strong>：HashSet是无序的集合，不保证元素的存储顺序；而LinkedHashSet是有序的集合，使用双向链表维护元素的插入顺序。</li><li><strong>性能比较</strong>：HashSet的插入、删除和查找操作的时间复杂度为O(1)；LinkedHashSet在HashSet的基础上增加了维护插入顺序的操作，相对慢一些</li></ul></blockquote><h2 id="HashSet-和-TreeSet-有什么区别？"><a href="#HashSet-和-TreeSet-有什么区别？" class="headerlink" title="HashSet 和 TreeSet 有什么区别？"></a>HashSet 和 TreeSet 有什么区别？</h2><blockquote><p>HashSet 和 TreeSet 都是Java集合框架中的Set接口的实现类，都不允许元素重复，都不是线程安全的</p><ul><li><strong>数据结构</strong>：HashSet的底层实现原理是基于HashMap，底层数据结构是哈希表（数组+链表&#x2F;红黑树）；TreeSet使用红黑树作为底层数据结构来存储元素。</li><li><strong>存储顺序</strong>：HashSet是无序的集合，不保证元素的存储顺序；TreeSet是有序的集合，根据元素的自然顺序或自定义排序规则进行排序。</li><li><strong>存储Null值</strong>：HashSet允许存储一个Null值，TreeSet不允许存储Null值</li></ul></blockquote><h2 id="HashMap的底层实现原理？"><a href="#HashMap的底层实现原理？" class="headerlink" title="HashMap的底层实现原理？"></a>HashMap的底层实现原理？</h2><blockquote><ol><li>HashMap的底层实现原理是使用了哈希表（Hash Table），通过 put(key,value)存储元素，get(key)来获取元素。</li><li>当传入一个键（key）时，HashMap 会调用键对象的hashCode()方法（key.hashCode()）计算出哈希码（hash code），根据哈希码（hash code）将值（value）保存在桶（bucket） 里。</li><li>当计算出的哈希码（hash code）相同时，称之为 hash 冲突，HashMap 的做法是用链表和红黑树存储相同哈希码（hash code）的值（value）。当 hash 冲突的个数比较少时，使用链表，当链表长度大于8时使用红黑树。</li></ol></blockquote><h2 id="HashMap底层数据结构？"><a href="#HashMap底层数据结构？" class="headerlink" title="HashMap底层数据结构？"></a>HashMap底层数据结构？</h2><blockquote><p><strong>JDK1.7</strong>：底层数据结构使用数组+链表，当发生哈希冲突时，会使用链表存储键值对，但是某些情况链表过长导致性能下降。</p><p><strong>JDK1.8</strong>：底层数据结构使用数组+链表或红黑树，当链表长度超过某个阈值（默认为 8）且哈希桶数组长度达到某个阈值（默认为 64）时，会将链表转变为红黑树，解决了链表太长导致性能下降的问题。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/HashMap底层数据结构.png" style="zoom:67%"></blockquote><h2 id="HashMap为什么用红黑树？"><a href="#HashMap为什么用红黑树？" class="headerlink" title="HashMap为什么用红黑树？"></a>HashMap为什么用红黑树？</h2><blockquote><p>在早期的版本中，HashMap 在解决哈希冲突（即多个键映射到同一个桶位置）时，会将相同哈希值的键值对存放在链表中来解决哈希冲突。</p><p>当链表长度较短时，使用链表进行存储是高效的。但是，当链表长度过长时，查找操作的时间复杂度将接近 O(n)，其中 n 是链表的长度。</p><p>为了避免出现链表过长的情况，JDK 1.8 引入了红黑树来取代链表，将查找操作的时间复杂度由 O(n) 降低到 O(log n)。</p><p>红黑树是一种自平衡的二叉搜索树，它的特点是保持树的平衡性，从而保证了在最坏情况下，查找、插入和删除操作的时间复杂度都是 O(log n)。</p><p>当链表长度超过某个阈值（默认为 8）且哈希桶数组长度达到某个阈值（默认为 64）时，，HashMap 会将链表转换为红黑树，以提高操作效率。</p><p>当红黑树的节点数少于某个阈值（默认为 6）且哈希桶数组长度大于某个阈值（默认为 64）时，又会将红黑树转换回链表，以节省内存空间。</p></blockquote><h2 id="HashMap为什么不使用其他数据结构？"><a href="#HashMap为什么不使用其他数据结构？" class="headerlink" title="HashMap为什么不使用其他数据结构？"></a>HashMap为什么不使用其他数据结构？</h2><blockquote><p>HashMap选择使用链表和红黑树作为桶中存储键值对的数据结构，是基于对性能和实现复杂度的综合考虑。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是一种自平衡的二叉搜索树，能够保持较好的平衡性和高效的插入、删除、查找操作。在插入和删除操作时，会对节点重新染色（红色或黑色）和旋转操作（左旋、右旋、左右旋和右左旋）来保持树的平衡。红黑树需要满足以下规则：</p><ul><li>每个节点要么是红色，要么是黑色。</li><li>根节点必须是黑色。</li><li>每个叶子节点（NIL 或空节点）是黑色。</li><li>如果一个节点是红色，那么它的两个子节点都是黑色。</li><li>对于每个节点，从该节点到其子孙节点的所有路径上包含相同数量的黑色节点。</li></ul><h2 id="平衡二叉树（AVL-Tree）"><a href="#平衡二叉树（AVL-Tree）" class="headerlink" title="平衡二叉树（AVL Tree）"></a>平衡二叉树（AVL Tree）</h2><p>平衡二叉树（AVL Tree）是一种自平衡的二叉搜索树，引入了平衡因子的概念，当插入或删除一个节点后，如果导致某个节点的平衡因子的绝对值（左子树高度减右子树高度）大于1，就表示该节点失去了平衡，会采用旋转操作（左旋、右旋、左右旋和右左旋）来进行平衡调整。平衡二叉树具有良好的平衡性，能够在最坏情况下保证 O(log n) 的查找、插入和删除操作。</p><ul><li><p><strong>平衡性要求</strong>：红黑树和AVL树都具有良好的平衡性，以保持树的高度较低，从而提供较快的查找、插入和删除操作。但是，AVL树在平衡性上更为严格，它要求左子树和右子树的高度差（平衡因子）不超过1，因此在插入和删除节点时需要更多的调整操作。红黑树则放松了这个要求，允许左右子树的高度差最多为2，通过颜色标记和旋转操作来保持平衡。</p></li><li><p><strong>插入和删除性能</strong>：如果插入和删除操作比查询操作频繁且持续进行，平衡二叉树（AVL Tree）为了平衡树，可能需要进行大量的旋转操作，会导致性能下降。红黑树在插入和删除时需要的旋转操作相对较少，因此在插入和删除元素时，红黑树的性能相对更优。</p></li><li><p><strong>查询性能</strong>：在大部分情况下，红黑树和AVL树在查找操作的性能上并没有明显的差异。但由于AVL树的严格平衡性，某些情况查找性能可能略优于红黑树。</p></li></ul><h2 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h2><p>B树和B+树是多路搜索树，对于磁盘等存储介质的访问有很好的优化。它们能够减少磁盘I&#x2F;O的次数，提高访问性能。然而，在内存中的数据结构中使用B树和B+树并不是一个必要选择，因为它们引入了额外的指针和存储开销，对于内存中的存储结构来说，相对于红黑树而言，这种开销可能是不必要的。</p><ul><li><strong>数据结构复杂度</strong>：红黑树是一种自平衡二叉搜索树，而B树和B+树是多路搜索树。B树和B+树相对来说实现较为复杂，需要考虑节点分裂、合并等操作的细节。而红黑树的实现相对简单，容易理解和维护。</li><li><strong>适应场景</strong>：B树和B+树适用于需要在磁盘或其他外部存储介质上存储大量数据的场景，其中涉及到磁盘IO操作。而HashMap通常用于内存中的数据结构，对于小规模的数据集合来说，红黑树已经足够满足性能和空间的需求。</li><li><strong>存储效率</strong>：在数据量不是很多的情况下，使用B树或B+树可能会导致部分节点存储过于稀疏，比如都存在一个节点上，这个时候遍历效率就退化成了链表，时间复杂度较高。红黑树在平均情况下具有较好的查找、插入和删除操作的时间复杂度，都为O(log n)，其中n为元素数量。</li></ul></blockquote><h2 id="HashMap为什么链表大于8才进行树化？"><a href="#HashMap为什么链表大于8才进行树化？" class="headerlink" title="HashMap为什么链表大于8才进行树化？"></a>HashMap为什么链表大于8才进行树化？</h2><blockquote><p>为了避免在链表长度较小的情况下，额外的树结构转换带来的开销。红黑树需要进行左旋，右旋，变色这些操作来保持树平衡，而单链表不需要。</p><p>链表长度小于8时，性能大于红黑树，没必要树化；</p><p>链表长度大于8时，性能会不如红黑树；</p><p>所以使用8刚刚好。</p></blockquote><h2 id="HashMap扩容是怎么实现的"><a href="#HashMap扩容是怎么实现的" class="headerlink" title="HashMap扩容是怎么实现的?"></a>HashMap扩容是怎么实现的?</h2><blockquote><p>HashMap在添加键值对时，如果达到了扩容阈值，会进行扩容操作</p><ol><li><strong>初始化数组容量</strong>：在创建HashMap对象时，如果没有指定初始容量，默认会创建一个<code>长度是16的数组</code>。</li><li><strong>添加元素触发扩容</strong>：每当向HashMap中添加元素时，都会检查当前元素数量是否已经达到了扩容阈值，扩容阈值是当前容量（当前数组长度）与负载因子（默认为0.75）的乘积，如果达到了阈值，就会触发扩容操作。</li><li><strong>创建新数组</strong>：一旦需要进行扩容，HashMap会创建一个更大的新数组。新数组的大小通常是<code>原始容量的两倍</code>。这样可以提供更多的槽位用于存储元素，减少哈希冲突的概率，并保持HashMap的性能。</li><li><strong>重新哈希化元素</strong>：在扩容阶段，HashMap会遍历原数组中的每个元素，并重新计算它们的哈希值和在新数组中的位置。元素的哈希值通过与新数组大小减一的位与操作，得到在新数组中的索引位置。然后将元素放置到新数组的相应位置上。</li><li><strong>处理冲突</strong>：在重新计算元素的哈希值和重新放置元素的过程中，可能会出现多个元素计算得到相同的新索引位置，即出现哈希冲突。为了解决冲突，HashMap<code>使用链表或红黑树来解决哈希冲突</code>，将相同索引位置上的元素以链表或红黑树的方式存储起来，并保持它们在新数组中的相对顺序。</li><li><strong>更新引用</strong>：最后，在重新哈希化元素完成之后，HashMap会将内部的数组引用指向新的数组。这样，后续的操作就可以使用新的数组了。旧的数组会被垃圾回收机制回收，释放内存空间。</li></ol></blockquote><h2 id="HashMap是怎么解决哈希冲突的？"><a href="#HashMap是怎么解决哈希冲突的？" class="headerlink" title="HashMap是怎么解决哈希冲突的？"></a>HashMap是怎么解决哈希冲突的？</h2><blockquote><p>当多个元素计算得到相同的哈希值并且它们被映射到了同一个数组索引位置时，就会发生哈希冲突。HashMap使用链表和红黑树来解决哈希冲突。</p><ul><li><strong>链表解决冲突</strong>：在早期版本的HashMap中，使用链表来解决冲突。当发生哈希冲突时，新元素会被添加到该索引位置的链表尾部。这样，相同索引位置上的多个元素就会通过链表连接起来。遍历链表来查找元素的时间复杂度为O(n)，其中n是链表的长度。</li><li><strong>转换为红黑树</strong>：当链表长度超过阈值（默认为8）时，链表会自动转换为红黑树，以提高查询和插入操作的性能。红黑树是一种自平衡的二叉搜索树，保证了在最坏情况下的时间复杂度为O(log n)，其中n是树中节点的数量。</li></ul></blockquote><h2 id="HashMap-的长度为什么是-2-的幂次方？"><a href="#HashMap-的长度为什么是-2-的幂次方？" class="headerlink" title="HashMap 的长度为什么是 2 的幂次方？"></a>HashMap 的长度为什么是 2 的幂次方？</h2><blockquote><p>HashMap的长度选择为2的幂次方，一方面可以提高存取效率，另一方面可以减少哈希碰撞的概率。</p><p>数据结构哈希表工作原理是通过将关键字（Key）输入哈希函数，得到一个对应的哈希值，再将哈希值映射为数组的索引位置，以便能够快速查找、插入和删除元素。</p><ol><li><strong>输入关键字（Key）</strong>：将要存储的元素的关键字输入到哈希函数中。</li><li><strong>哈希函数计算哈希值</strong>：哈希函数根据关键字（Key）计算出一个对应的哈希值。</li><li><strong>映射为索引位置</strong>：通过对哈希值进行适当的转换映射，将哈希值映射为数组中的索引位置。</li><li><strong>存储和处理冲突</strong>：如果多个关键字产生了相同的哈希值，这就是哈希冲突。在哈希表中，通常有多种方法来处理冲突，例如链地址法、开放地址法等。</li><li><strong>插入、查找、删除元素</strong>：一旦元素的哈希值被映射为数组的索引位置，我们可以直接在该位置上执行插入、查找和删除操作。</li></ol><p><strong>注意细节</strong>：通过哈希函数计算出的哈希值的范围是-2147483648 到 2147483647，也就是说大概有 40 亿的映射空间。如果直接将 40 亿的哈希值都映射为数组中的索引，只要映射得比较均匀松散，一般很难出现碰撞（哈希冲突）。但可惜的是内存不能加载 40 亿长度的数组，所以哈希值不能直接进行映射，因此需要将哈希值范围限制在合适的数组索引范围内。一般是通过对哈希值进行取模运算来限制范围，取模运算的除数通常是数组的长度，得到的余数作为最终的索引位置。</p><p>在HashMap中，取模运算是通过<code>(n - 1) &amp; hash</code>来计算的，其中n代表数组长度，hash 是经过哈希函数计算得到的哈希值。当数组长度为2的幂次方时，取模运算<code>(n - 1) &amp; hash</code> 可以等价于传统的取模运算 <code>hash % length</code>。使用 <code>%（传统的取模操作符）</code> 取模运算时需要除法操作，计算量较大，使用<code>&amp;（按位与操作符）</code>取模运算只需对二进制数进行按位与操作，可以提高计算的效率。</p></blockquote><h2 id="HashMap中的put-方法"><a href="#HashMap中的put-方法" class="headerlink" title="HashMap中的put()方法"></a>HashMap中的put()方法</h2><blockquote><ol><li>首先，<code>put()</code>方法接收一个键和一个值作为参数。</li><li>传入的键会通过<code>hashCode()</code>方法获取键的哈希值，用于确定键值对在HashMap内部数组中的位置。</li><li>如果该位置还没有任何元素，则直接将键值对存储在该位置。</li><li>如果该位置已经有元素存在（发生了哈希冲突），则遍历该位置上的链表或红黑树，找到具有相同键的节点。</li><li>如果找到具有相同键的节点，则更新该节点的值为新的值，并返回旧的值。</li><li>如果未找到具有相同键的节点，则将新的键值对添加到链表或红黑树的末尾，根据需要转换链表为红黑树。</li><li>如果插入后，链表长度超过了阈值(默认为8)，则将链表转换为红黑树，以提高查找效率。</li><li>如果红黑树的节点数量达到了树化阈值(默认为6)，则进行树化操作，将红黑树转换为一个更高效的结构。</li><li>如果HashMap的元素数量超过扩容阈值，将进行扩容操作，重新计算键值对的位置。</li></ol></blockquote><h2 id="HashMap中的get-方法"><a href="#HashMap中的get-方法" class="headerlink" title="HashMap中的get()方法"></a>HashMap中的get()方法</h2><blockquote><ol><li>根据传入的键，调用<code>hashCode()</code>方法获取键的哈希值</li><li>根据哈希值，计算出在HashMap内部数组中的索引位置，在确定的索引位置上查找元素</li><li>如果该索引位置没有元素，则返回null，表示未找到对应的值。</li><li>如果该索引位置有元素，首先检查该位置上的元素是否与传入的键相等（使用<code>equals()</code>方法进行比较）。</li><li>如果传入的键与该位置上的键相等，说明找到了对应的值，HashMap会返回该键对应的值。</li><li>如果传入的键与该位置上的键不相等，可能存在哈希冲突，即该位置上的链表或红黑树中可能存在具有相同键但不同值的节点。</li><li>存在哈希冲突HashMap会遍历链表或红黑树，查找具有相同键的节点，如果找到则返回该节点的值。</li><li>如果遍历完链表或红黑树仍未找到具有相同键的节点，则返回null，表示未找到对应的值。</li></ol></blockquote><h2 id="HashMap-和-Hashtable-有什么区别？"><a href="#HashMap-和-Hashtable-有什么区别？" class="headerlink" title="HashMap 和 Hashtable 有什么区别？"></a>HashMap 和 Hashtable 有什么区别？</h2><blockquote><p>HashMap 和 Hashtable 底层数据结构都是哈希表，都实现了Map接口</p><ul><li><strong>线程安全性</strong>：HashMap线程不安全，Hashtable线程安全</li><li><strong>性能对比</strong>：由于 Hashtable 是线程安全的，它的操作需要进行同步处理，在多线程环境下带来一定的性能开销</li><li><strong>存储Null值</strong>：HashMap 的键值允许存储一个 null 值，Hashtable 键值不允许存储 null 值</li></ul></blockquote><h2 id="HashMap-和-TreeMap-有什么区别？"><a href="#HashMap-和-TreeMap-有什么区别？" class="headerlink" title="HashMap 和 TreeMap 有什么区别？"></a>HashMap 和 TreeMap 有什么区别？</h2><blockquote><p>HashMap 和 TreeMap 都是线程不安全的，都实现了Map接口</p><ul><li><strong>数据结构不同</strong>：HashMap数据结构是哈希表（数组+链表&#x2F;红黑树），TreeMap数据结构是红黑树</li><li><strong>性能对比</strong>：HashMap 的插入、删除和查找操作的时间复杂度为O(1)；TreeMap 的插入、删除和查找操作的时间复杂度为O(log n)；</li><li><strong>元素排序</strong>：HashMap 不保证键值对的顺序；TreeMap会根据键的自然排序或者自定义的比较器对键值对进行排序；</li><li><strong>存储Null值</strong>：HashMap 的键值允许存储一个 null 值，Hashtable 键值不允许存储 null 值</li></ul></blockquote><h2 id="HashMap-和-HashSet-有什么区别？"><a href="#HashMap-和-HashSet-有什么区别？" class="headerlink" title="HashMap 和 HashSet 有什么区别？"></a>HashMap 和 HashSet 有什么区别？</h2><blockquote><p>HashMap 和 HashSet 都是线程不安全的，底层数据结构都是哈希表。</p><ul><li><strong>实现接口不同</strong>：HashMap实现了Map双列集合接口；HashSet实现的是Set单例无序集合接口</li><li><strong>实现方式不同</strong>：HashMap内部使用哈希表（数组+链表&#x2F;红黑树）实现；HashSet内部是基于HashMap实现，将元素作为键（key），将值（value）固定为一个常量对象（通常为PRESENT或者null）。</li><li><strong>存储数据不同</strong>：HashMap存储的是键值对；HashSet存储的是对象</li><li><strong>元素访问方式</strong>：HashMap可以通过键来获取对应值，也可以遍历所有键值对；HashSet可以通过迭代器或者增强型for循环来遍历所有元素。</li><li><strong>元素唯一性</strong>：HashMap可以存储重复的值，但键必须是唯一的；HashSet 由于使用 HashMap 的键（key）存储元素，所以 HashSet 不能存放重复元素。</li></ul></blockquote><h2 id="怎么确保一个集合不被修改"><a href="#怎么确保一个集合不被修改" class="headerlink" title="怎么确保一个集合不被修改?"></a>怎么确保一个集合不被修改?</h2><blockquote><h2 id="使用不可变集合"><a href="#使用不可变集合" class="headerlink" title="使用不可变集合"></a>使用不可变集合</h2><p>不可变集合是指创建后不能被修改的集合。Java 中的 <code>java.util.Collections</code> 类提供了一系列静态方法，用于创建不可变版本的集合，例如 <code>Collections.unmodifiableList()</code>、<code>Collections.unmodifiableSet()</code> 和 <code>Collections.unmodifiableMap()</code>。这些方法返回一个只读视图，任何对其进行修改的操作都会抛出 <code>UnsupportedOperationException</code> 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; originalList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">originalList.add(<span class="string">&quot;item1&quot;</span>);</span><br><span class="line">originalList.add(<span class="string">&quot;item2&quot;</span>);</span><br><span class="line">List&lt;String&gt; unmodifiableList = Collections.unmodifiableList(originalList);</span><br><span class="line">unmodifiableList.add(<span class="string">&quot;item3&quot;</span>); <span class="comment">// 会抛出 UnsupportedOperationException 异常</span></span><br></pre></td></tr></table></figure><h2 id="使用只读接口实现"><a href="#使用只读接口实现" class="headerlink" title="使用只读接口实现"></a>使用只读接口实现</h2><p>可以定义自己的接口，只提供读取数据的方法，而不包含修改数据的方法。然后，通过实现该接口的类来创建集合对象，只暴露只读方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ReadOnlyCollection</span>&lt;E&gt; &#123;</span><br><span class="line"> List&lt;E&gt; <span class="title function_">getList</span><span class="params">()</span>; <span class="comment">// 只读方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCollection</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">ReadOnlyCollection</span>&lt;E&gt; &#123;</span><br><span class="line"> <span class="keyword">private</span> List&lt;E&gt; list;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="title function_">MyCollection</span><span class="params">(List&lt;E&gt; list)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.list = list;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> List&lt;E&gt; <span class="title function_">getList</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> Collections.unmodifiableList(list); <span class="comment">// 返回不可修改的集合</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; originalList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">originalList.add(<span class="string">&quot;item1&quot;</span>);</span><br><span class="line">originalList.add(<span class="string">&quot;item2&quot;</span>);</span><br><span class="line">ReadOnlyCollection&lt;String&gt; readOnlyCollection = <span class="keyword">new</span> <span class="title class_">MyCollection</span>&lt;&gt;(originalList);</span><br><span class="line">readOnlyCollection.getList().add(<span class="string">&quot;item3&quot;</span>); <span class="comment">// 会抛出 UnsupportedOperationException 异常</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="哪些集合类是线程安全的？"><a href="#哪些集合类是线程安全的？" class="headerlink" title="哪些集合类是线程安全的？"></a>哪些集合类是线程安全的？</h2><blockquote><p>Vector、Hashtable、Properties是线程安全的</p><ul><li><strong>Vector</strong>：底层数组，线程安全，所有方法都是同步的</li><li><strong>Hashtable</strong>：底层哈希表（数组+链表） ，线程安全，所有方法都是同步的</li><li><strong>Properties</strong>：底层哈希表（数组+链表） ，Properties类继承自Hashtable类，主要用于处理属性文件</li></ul></blockquote><h2 id="集合是否允许Null值？"><a href="#集合是否允许Null值？" class="headerlink" title="集合是否允许Null值？"></a>集合是否允许Null值？</h2><blockquote><p>List接口实现类ArrayList、LinkedList、Vector</p><ul><li><strong>ArrayList</strong>：允许存储 null 值，可以添加一个或多个 null 元素</li><li><strong>LinkedList</strong>：允许存储 null 值，可以添加一个或多个 null 元素。</li><li><strong>Vector</strong>：允许存储 null 值，可以添加一个或多个 null 元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// List接口实现类ArrayList、LinkedList、Vector</span></span><br><span class="line">        List&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">        arrayList.add(<span class="literal">null</span>);</span><br><span class="line">        arrayList.add(<span class="literal">null</span>);</span><br><span class="line">        linkedList.add(<span class="literal">null</span>);</span><br><span class="line">        linkedList.add(<span class="literal">null</span>);</span><br><span class="line">        vector.add(<span class="literal">null</span>);</span><br><span class="line">        vector.add(<span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;ArrayList: &quot;</span> + arrayList); <span class="comment">// 输出结果：ArrayList: [null, null]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;LinkedList: &quot;</span> + linkedList); <span class="comment">// 输出结果：LinkedList: [null, null]</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Vector: &quot;</span> + vector); <span class="comment">// 输出结果：Vector: [null, null]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Set接口实现类HashSet、LinkedHashSet、TreeSet</p><ul><li><strong>HashSet</strong>：只允许存储一个 null 值。</li><li><strong>LinkedHashSet</strong>：只允许存储一个 null 值。</li><li><strong>TreeSet</strong>：不允许存储 null 值，会抛出<code>NullPointerException</code>异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// Set接口实现类HashSet、LinkedHashSet、TreeSet</span></span><br><span class="line">		Set&lt;String&gt; hashSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		Set&lt;String&gt; linkedHashSet = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">		Set&lt;String&gt; treeSet = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">		hashSet.add(<span class="literal">null</span>);</span><br><span class="line">		hashSet.add(<span class="literal">null</span>);</span><br><span class="line">		linkedHashSet.add(<span class="literal">null</span>);</span><br><span class="line">		linkedHashSet.add(<span class="literal">null</span>);</span><br><span class="line">		<span class="comment">// treeSet.add(null); // 会抛出java.lang.NullPointerException异常</span></span><br><span class="line">		<span class="comment">// treeSet.add(null); // 会抛出java.lang.NullPointerException异常</span></span><br><span class="line">		System.out.println(<span class="string">&quot;HashSet: &quot;</span> + hashSet); <span class="comment">// 输出结果：HashSet: [null]</span></span><br><span class="line">		System.out.println(<span class="string">&quot;LinkedHashSet: &quot;</span> + linkedHashSet); <span class="comment">// 输出结果：LinkedHashSet: [null]</span></span><br><span class="line">		System.out.println(<span class="string">&quot;TreeSet: &quot;</span> + treeSet); <span class="comment">// 输出结果：TreeSet: []</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Map接口实现类HashMap、LinkedHashMap、Hashtable、TreeMap</p><ul><li><strong>HashMap</strong>：允许使用 null 作为键（key）和值（value），对于键（key），只能有一个为null；对于值（value），可以有多个为null。</li><li><strong>LinkedHashMap</strong>：允许使用 null 作为键（key）和值（value），对于键（key），只能有一个为null；对于值（value），可以有多个为null。</li><li><strong>TreeMap</strong>：不允许存储 null 值作为键（key），但可以存储一个或多个 null 值作为值（value）</li><li><strong>HashTable</strong>：不允许使用 null 作为键（key）和值（value），如果任意一个为null的话，会抛出<code>NullPointerException</code>异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Map接口实现类HashMap、LinkedHashMap、Hashtable、TreeMap</span></span><br><span class="line">        HashMap&lt;String, String&gt; hashMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        LinkedHashMap&lt;String, String&gt; linkedHashMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">        Hashtable&lt;String, String&gt; hashtable = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;&gt;();</span><br><span class="line">        Map&lt;String, String&gt; treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        hashMap.put(<span class="literal">null</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="literal">null</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;key1&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        hashMap.put(<span class="string">&quot;key2&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        linkedHashMap.put(<span class="literal">null</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        linkedHashMap.put(<span class="literal">null</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">&quot;key1&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        linkedHashMap.put(<span class="string">&quot;key2&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// hashtable.put(null, &quot;value1&quot;); // 会抛出java.lang.NullPointerException异常</span></span><br><span class="line">        <span class="comment">// hashtable.put(null, &quot;value2&quot;); // 会抛出java.lang.NullPointerException异常</span></span><br><span class="line">        <span class="comment">// hashtable.put(&quot;key1&quot;, null); // 会抛出java.lang.NullPointerException异常</span></span><br><span class="line">        <span class="comment">// hashtable.put(&quot;key2&quot;, null); // 会抛出java.lang.NullPointerException异常</span></span><br><span class="line">        <span class="comment">// treeMap.put(null, &quot;value1&quot;); // 会抛出java.lang.NullPointerException异常</span></span><br><span class="line">        <span class="comment">// treeMap.put(null, &quot;value2&quot;); // 会抛出java.lang.NullPointerException异常</span></span><br><span class="line">        treeMap.put(<span class="string">&quot;key1&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        treeMap.put(<span class="string">&quot;key2&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;HashMap: &quot;</span> + hashMap); <span class="comment">// 输出结果：HashMap: &#123;null=value2, key1=null, key2=null&#125;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;LinkedHashMap: &quot;</span> + linkedHashMap); <span class="comment">// 输出结果：LinkedHashMap: &#123;null=value2, key1=null, key2=null&#125;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hashtable: &quot;</span> + hashtable); <span class="comment">// 输出结果：Hashtable: &#123;&#125;</span></span><br><span class="line">        System.out.println(<span class="string">&quot;TreeMap: &quot;</span> + treeMap); <span class="comment">// 输出结果：TreeMap: &#123;key1=null, key2=null&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Comparable-和-Comparator-有什么区别？"><a href="#Comparable-和-Comparator-有什么区别？" class="headerlink" title="Comparable 和 Comparator 有什么区别？"></a>Comparable 和 Comparator 有什么区别？</h2><blockquote><p><code>Comparable</code>和<code>Comparator</code>是Java中用于排序的两个接口</p><ul><li><strong>Comparable接口</strong>：是在对象自身内部定义的比较规则，只能定义一种比较方式，并且是不可更改的。</li><li><strong>Comparator接口</strong>：是一个外部比较器，可以定义多个不同的比较规则，并且可以在不修改对象类的情况下进行扩展和排序。</li></ul></blockquote><h2 id="Collection-和-Collections-有什么区别？"><a href="#Collection-和-Collections-有什么区别？" class="headerlink" title="Collection 和 Collections 有什么区别？"></a>Collection 和 Collections 有什么区别？</h2><blockquote><p>Collection是一个接口，Collections是一个工具类。</p><ul><li><strong>Collection接口</strong>：Collection是Java集合框架中定义的顶级接口，代表一组对象的集合。</li><li><strong>Collections工具类</strong>：Collections是Java中的一个实用类，提供了一系列静态方法来操作和处理集合对象。</li></ul></blockquote><h2 id="说一说Iterator迭代器接口？"><a href="#说一说Iterator迭代器接口？" class="headerlink" title="说一说Iterator迭代器接口？"></a>说一说Iterator迭代器接口？</h2><blockquote><p>Iterator迭代器主要用于遍历Collection 集合中的元素，Collection接口继承了Iterator迭代器</p><p>Iterator迭代器是个接口，无法直接使用，一般会使用foreach增强for循环遍历集合，内部原理其实是个iterator迭代器</p></blockquote><h2 id="什么是Fail-Fast和Fail-Safe机制？"><a href="#什么是Fail-Fast和Fail-Safe机制？" class="headerlink" title="什么是Fail-Fast和Fail-Safe机制？"></a>什么是Fail-Fast和Fail-Safe机制？</h2><blockquote><p><code>Fail-Fast</code>和<code>Fail-Safe</code>是两种常见的错误处理机制，用于处理在并发环境下对集合进行操作时可能发生的并发修改错误。Fail-Fast是Java集合框架的默认策略，而Fail-Safe则是一些特定集合的策略。</p><ul><li><strong>快速失败（fail-fast）</strong>：Fail-Fast机制是指当多个线程对集合进行并发修改操作时，如果检测到集合已经被修改，迭代器立即抛出<code>ConcurrentModificationException</code>异常。这种策略提供了及时的错误反馈，确保在并发修改时不会产生不确定的行为，但可能导致程序终止。</li><li><strong>安全失败（fail-safe）</strong>：Fail-Safe机制是指当多个线程对集合进行并发修改操作时，迭代器不会直接抛出异常，而是创建并返回一个原始集合的副本，然后对副本进行操作。这样可以避免并发修改异常，但可能会出现一些非预期的结果，因为迭代器操作的是原始集合的复制品。</li></ul></blockquote><h1 id="Java泛型相关面试题"><a href="#Java泛型相关面试题" class="headerlink" title="Java泛型相关面试题"></a>Java泛型相关面试题</h1><h2 id="什么是泛型？"><a href="#什么是泛型？" class="headerlink" title="什么是泛型？"></a>什么是泛型？</h2><blockquote><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性，提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型使用一对尖括号表示，尖括号内标注类型，可以修饰在类、接口、方法上</p></blockquote><h2 id="为什么使用泛型？"><a href="#为什么使用泛型？" class="headerlink" title="为什么使用泛型？"></a>为什么使用泛型？</h2><blockquote><p>泛型是Java编程语言中的一项重要特性，它提供了以下几个主要的好处和用途：</p><ul><li><strong>保证了类型的安全性</strong>：使用泛型可以在编译时期捕获类型错误，避免在运行时期出现类型转换异常，减少了因类型不匹配而引起的潜在错误。</li><li><strong>避免频繁的类型转换操作</strong>：在泛型中，类型转换是隐式的，并不需要显式地进行类型转换，使用泛型可以避免频繁的类型转换操作（装箱、拆箱），从而减少了代码中的冗余部分，使代码更简洁易读</li><li><strong>提高了代码的可读性</strong>：通过在定义类、接口或方法时使用泛型，能够明确指定类或方法的输入和输出的数据类型，从而使得代码更加具有自描述性</li></ul></blockquote><h2 id="什么是泛型擦除？"><a href="#什么是泛型擦除？" class="headerlink" title="什么是泛型擦除？"></a>什么是泛型擦除？</h2><blockquote><p>类型擦除是指在 Java 编译器编译泛型代码时，将泛型类型信息擦除并替换为原始类型或最顶级父类的过程。简单来说，就是泛型相关信息只存在于代码的编译阶段，在编译之后的字节码文件（class 文件）中不包含任何泛型信息，泛型参数会被替换为其上界或者 Object 类型。具体来说，泛型擦除会导致以下几个变化：</p><ul><li><strong>替换泛型类型参数</strong>：在字节码中，泛型类型参数会被替换为其最顶级的边界类型或者 Object 类型。例如，一个 <code>List&lt;T&gt;</code> 类型，在类型擦除后会被替换为 <code>List</code> 或者 <code>List&lt;Object&gt;</code>。</li><li><strong>移除类型参数的具体类型</strong>：泛型类型中的具体类型信息，如泛型参数的实际类型或者参数化类型的参数，会被移除。例如，一个 <code>List&lt;String&gt;</code> 在类型擦除后会变成简单的 <code>List</code>。</li><li><strong>强制进行类型转换</strong>：由于类型擦除导致泛型参数丢失，编译器会在需要的地方插入强制类型转换以保持类型安全。这些类型转换操作可能会在运行时引发异常，因此开发人员需要注意正确处理类型转换的问题。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型擦除前</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">Example</span><span class="params">(T t1, T t2)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 泛型擦除后</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;Object&gt; List <span class="title function_">Example</span><span class="params">(Object t1, Object t2)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="为什么要进行泛型擦除？"><a href="#为什么要进行泛型擦除？" class="headerlink" title="为什么要进行泛型擦除？"></a>为什么要进行泛型擦除？</h2><blockquote><p>Java的泛型是在JDK 5中引入的，它提供了编译时类型检查和更强的类型安全性，为了保持与之前版本的兼容性，所以才使用泛型擦除。泛型擦除是Java编译器在生成字节码时的一种优化方式，它的目的是为了兼容Java的泛型和之前版本的非泛型代码。</p><ul><li><strong>编译器的兼容性</strong>：Java泛型是在JDK 5引入的，为了保持对旧版本Java的兼容性，编译器在生成字节码时将泛型类型擦除为它们的上界或者Object类型。</li><li><strong>减少重复字节码</strong>：如果不进行泛型擦除，每个具体的泛型类型都会生成一个独立的类文件，导致生成大量重复的字节码。泛型擦除可以通过类型擦除的方式减少字节码的冗余，提高了编译后的代码的效率和性能。</li><li><strong>泛型类型的互操作性</strong>：泛型擦除使得使用泛型的代码可以与不使用泛型的代码进行互操作，让泛型代码能够与之前的非泛型代码无缝地集成。</li></ul></blockquote><h1 id="Java多线程相关面试题"><a href="#Java多线程相关面试题" class="headerlink" title="Java多线程相关面试题"></a>Java多线程相关面试题</h1><h2 id="线程和进程的区别？"><a href="#线程和进程的区别？" class="headerlink" title="线程和进程的区别？"></a>线程和进程的区别？</h2><blockquote><p>一个应用程序，既可以有多个进程，也可以有多个线程，一个进程可以包含多个线程，每个线程相互独立</p><ul><li><strong>进程（Process）</strong>：进程是计算机上执行的一个程序实例，它包含了程序代码、数据和资源的集合</li><li><strong>线程（Thread）</strong>：是程序中的一个执行单元，可以独立地执行代码，并共享进程的内存空间和资源</li></ul><p>拿浏览器举例，打开一个浏览器，浏览器是一个进程，浏览器中可以打开很多标签页，每个标签页都是这个浏览器进程的子进程，每个子进程中可以有多个线程来协同完成页面的加载和渲染，比如图片、CSS 和 JS 文件等都是线程来做的</p><ul><li><strong>多进程模式</strong>：每个进程只有一个线程</li><li><strong>多线程模式</strong>：一个进程有多个线程</li><li><strong>多进程＋多线程模式</strong>：多个进程，每个进程有多个线程</li></ul></blockquote><h2 id="并行和并发有什么区别？"><a href="#并行和并发有什么区别？" class="headerlink" title="并行和并发有什么区别？"></a>并行和并发有什么区别？</h2><blockquote><ul><li><strong>并行</strong>：同一时刻，多个任务同时执行，每个任务在不同的处理单元上独立执行</li><li><strong>并发</strong>：同一时刻，多个任务交替执行，所有任务在同一个处理单元上执行</li></ul><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/并行和并发.png" style="zoom:50%"></blockquote><h2 id="并发编程三个必要因素是什么？"><a href="#并发编程三个必要因素是什么？" class="headerlink" title="并发编程三个必要因素是什么？"></a>并发编程三个必要因素是什么？</h2><blockquote><p>在Java并发编程中，存在三个必要因素：</p><ul><li><strong>原子性（Atomicity）</strong>：原子性是指操作的不可分割性。在多线程环境下，一个操作可以由多个指令组成，原子性要求这些指令要么全部执行成功，要么全部不执行，不允许出现中间状态或部分执行的情况。</li><li><strong>可见性（Visibility）</strong>：可见性是指一个线程对共享变量的修改对其他线程是可见的。在多线程环境下，每个线程都有自己的工作内存，线程之间共享数据时，可能会出现数据不一致的问题。可见性要求当一个线程修改了共享变量的值后，其他线程能够立即看到最新的值。</li><li><strong>有序性（Ordering）</strong>：有序性是指程序执行的结果要按照一定的顺序来保证。在多线程环境下，由于指令重排序或缓存导致的乱序执行，可能会影响程序的正确性。有序性要求程序执行的结果要符合程序的代码顺序。</li></ul></blockquote><h2 id="创建线程有几种方式？"><a href="#创建线程有几种方式？" class="headerlink" title="创建线程有几种方式？"></a>创建线程有几种方式？</h2><blockquote><p>共有三种方式可以创建线程，分别是：① <strong>继承Thread类</strong>② <strong>实现Runnable接口</strong>③ <strong>实现Callable接口</strong></p><h2 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h2><ol><li>创建一个继承于Thread类的子类</li><li>重写Thread类的run()</li><li>创建Thread类的子类对象</li><li>通过此子类对象调用start()启动线程</li></ol><h2 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h2><ol><li>创建一个实现Runnable接口的实现类</li><li>实现类重写Runnable接口中的抽象方法run()</li><li>创建Runnable接口实现类的对象</li><li>创建Thread类的对象，将实现类的对象作为参数，传递到Thread类的构造器中</li><li>通过Thread类的对象调用start()启动线程</li></ol><h2 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h2><ol><li>创建一个实现Callable接口的实现类</li><li>实现call方法，将此线程需要执行的操作声明在call()中</li><li>创建Callable接口实现类的对象</li><li>创建FutureTask的对象，将Callable接口实现类的对象作为参数传递到FutureTask构造器中</li><li>创建Thread对象，将FutureTask的对象作为参数传递到Thread类的构造器中，并调用start</li><li>获取Callable中call方法的返回值</li></ol></blockquote><h2 id="哪种方式创建线程更好？"><a href="#哪种方式创建线程更好？" class="headerlink" title="哪种方式创建线程更好？"></a>哪种方式创建线程更好？</h2><blockquote><p>使用实现Runnable接口创建线程的方式比继承Thread类更推荐一些，因为Java是单继承的语言，通过实现接口可以更灵活地扩展其他类或实现其他接口。如果你只需要简单地启动一个线程，并不需要获得执行结果或向上抛出异常，那么继承Thread类或实现Runnable接口都是可以的。如果你需要获得线程的执行结果，或者需要向上抛出异常，那么实现Callable接口创建线程是更好的选择。</p><ul><li><strong>继承 Thread 类创建线程</strong>：简单直观，但 Java 语言是单继承的，如果继承了 Thread 类，那就不能再继承其他类了。</li><li><strong>实现Runnable接口创建线程</strong>：可以解决单继承的问题，同时继承其他类或实现其他接口，但不能向上抛出异常，不能获得线程的执行结果。</li><li><strong>实现Callable接口创建线程</strong>：可以解决以上问题，可以向上抛出异常，可以通过返回值来获取任务的执行结果。</li></ul></blockquote><h2 id="Runnable接口和Callable接口有什么区别？"><a href="#Runnable接口和Callable接口有什么区别？" class="headerlink" title="Runnable接口和Callable接口有什么区别？"></a>Runnable接口和Callable接口有什么区别？</h2><blockquote><p>Runnable接口和Callable接口是Java中用于实现多线程的接口，主要有以下区别：</p><ul><li><strong>返回值类型</strong>： Runnable接口的 run()方法<code>没有返回值</code>，而Callable接口的call()方法<code>有一个泛型返回值</code>，可以通过<code>Future</code>对象获取。</li><li><strong>异常处理</strong>：Runnable接口的run()方法不能抛出任何受检查异常，<code>只能在方法内部进行捕获和处理</code>。而Callable接口的call()方法<code>可以抛出受检查异常</code>，需要在方法的声明中声明抛出异常或者在方法内部进行捕获和处理。</li></ul></blockquote><h2 id="线程的-run-和-start-有什么区别？"><a href="#线程的-run-和-start-有什么区别？" class="headerlink" title="线程的 run()和 start()有什么区别？"></a>线程的 run()和 start()有什么区别？</h2><blockquote><p>在Java中，<code>run()</code>和<code>start()</code>都是Thread类中的方法，其中的区别如下：</p><ul><li><strong>run()方法</strong>：是线程的执行体，定义了线程要执行的操作，可以被调用多次</li><li><strong>start()方法</strong>：用来启动线程，并使其进入就绪状态，只能被调用一次。</li></ul></blockquote><h2 id="怎样停止线程？"><a href="#怎样停止线程？" class="headerlink" title="怎样停止线程？"></a>怎样停止线程？</h2><blockquote><p>在Java中，要停止线程有几种常见的方法：</p><ul><li><strong>等待线程执行完毕</strong>：当线程任务执行完毕后，使线程正常退出。</li><li><strong>使用标志位</strong>：在线程的任务代码中，设置一个布尔类型的标志位，通过修改标志位的值来控制线程的停止。</li><li><strong>调用stop()方法（已废弃）</strong>：当执行此方法时，强制结束当前线程（不推荐，方法已作废）</li><li><strong>调用interrupt()方法</strong>：用来通知线程停止正在进行的工作，会抛出InterruptedException异常并转移到运行状态</li></ul></blockquote><h2 id="线程包括哪些状态，状态之间是如何变化的？"><a href="#线程包括哪些状态，状态之间是如何变化的？" class="headerlink" title="线程包括哪些状态，状态之间是如何变化的？"></a>线程包括哪些状态，状态之间是如何变化的？</h2><blockquote><p>线程的生命周期是指线程从创建到终止的整个过程，可以分为以下几个阶段：</p><ol><li><strong>新建（New）</strong>：当一个 Thread 类型的实例被创建（new），处于新建状态，此时该线程还没有被启动</li><li><strong>就绪（Runnable）</strong>：新建状态的线程调用 start() 方法后，线程进入就绪状态，等待系统分配 CPU 使用权，此时线程有执行资格，但是没有执行权</li><li><strong>运行（Running）</strong>：就绪的线程被调度并获得CPU资源时，便进入运行状态，开始执行 run() 方法中的操作和功能，此时线程有执行资格，同时也有执行权</li><li><strong>阻塞（Blocked）</strong>：当线程因为某些原因被阻塞时，例如线程在等待获取锁时，如果锁已经被其他线程占用，会等待其他线程释放锁，进入阻塞状态，此时线程没有执行资格，也没有执行权</li><li><strong>等待（Waiting）</strong>：线程调用了 Object.wait()、Thread.join() 等方法时，将进入等待状态，等待其他线程调用相应的 notify()、notifyAll() 方法唤醒或等待Thread.join()插队完毕，如果线程在等待一定时间后，如果还没有接收到唤醒信号，就会一直处于等待状态，如果线程使用 interrupt() 方法中断，它会抛出InterruptedException异常并转移到运行状态，此时线程没有执行资格，也没有执行权</li><li><strong>限时等待（Timed Waiting）</strong>：线程调用了Thread.sleep()、Object.wait(timeout)、Thread.join(timeout)等方法后，将进入限时等待状态，等调用的时间到达或者等待其他线程调用相应的唤醒方法，如果线程使用 interrupt() 方法中断，会抛出InterruptedException异常并转移到运行状态，此时线程没有执行资格，也没有执行权</li><li><strong>终止（Terminated）</strong>：当线程执行完毕（run() 方法 &#x2F; call() 方法执行完毕）、发生了异常而导致线程停止、调用Thread.stop()方法，线程将进入终止状态，此时线程死亡，变成垃圾，不能再重复使用</li></ol><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/线程的生命周期.png" style="zoom:50%"></blockquote><h2 id="新建-T1、T2、T3-三个线程，如何保证线程按顺序执行？"><a href="#新建-T1、T2、T3-三个线程，如何保证线程按顺序执行？" class="headerlink" title="新建 T1、T2、T3 三个线程，如何保证线程按顺序执行？"></a>新建 T1、T2、T3 三个线程，如何保证线程按顺序执行？</h2><blockquote><p>使用线程的插队（join）保证它们按顺序执行</p><ul><li>在前一个线程的任务代码中，调用后一个线程的<code>join()</code>方法。</li><li><code>join()</code>方法的作用是等待被调用线程执行完毕，并加入到当前线程中。</li><li>这样可以确保前一个线程执行完毕后，后一个线程才会开始执行。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadOrderExample</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="comment">// 执行 T1 相关操作</span></span><br><span class="line">               System.out.println(<span class="string">&quot;线程 T1 正在执行&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   t1.join();  <span class="comment">// 等待 T1 执行完成</span></span><br><span class="line">                   <span class="comment">// 执行 T2 相关操作</span></span><br><span class="line">                   System.out.println(<span class="string">&quot;线程 T2 正在执行&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   t2.join();  <span class="comment">// 等待 T2 执行完成</span></span><br><span class="line">                   <span class="comment">// 执行 T3 相关操作</span></span><br><span class="line">                   System.out.println(<span class="string">&quot;线程 T3 正在执行&quot;</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       t1.start();</span><br><span class="line">       t2.start();</span><br><span class="line">       t3.start();</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="什么是死锁？"><a href="#什么是死锁？" class="headerlink" title="什么是死锁？"></a>什么是死锁？</h2><blockquote><p>多个线程相互等待对方释放持有的资源，但不肯相让，导致的互相等待（死锁）</p><p>死锁的产生有如下原因</p><ul><li><strong>互斥条件</strong>：资源不能被同时占用，即在某一时刻只能由一个进程使用</li><li><strong>请求与保持条件</strong>：进程已经保持至少一个资源，并且正在等待获取其他的资源，但是这些资源可能被其他进程占用</li><li><strong>不可剥夺条件</strong>：进程已经获得的资源，在未使用完之前，不能被其他进程强制抢占</li><li><strong>循环等待条件</strong>：若干进程之间形成一种头尾相接的循环等待资源关系</li></ul></blockquote><h2 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h2><blockquote><ul><li><strong>加锁顺序</strong>：确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。</li><li><strong>超时机制</strong>：当请求资源的等待时间超过一定阈值时，放弃请求并进行回退策略。</li><li><strong>死锁检测</strong>：JDK提供了两种方式来给我们检测死锁位置，图形化工具JConsole和命令行工具Jstack</li></ul></blockquote><h2 id="多线程之间如何进行通信？"><a href="#多线程之间如何进行通信？" class="headerlink" title="多线程之间如何进行通信？"></a>多线程之间如何进行通信？</h2><blockquote><p>在 Java 中，多线程之间可以使用以下几种方式进行通信：</p><ul><li><strong>共享变量</strong>：多个线程可以共享同一个变量，并通过读写该变量来进行通信。需要注意的是，多线程同时访问共享变量时，要保证线程之间的可见性和一致性，可以使用 <code>synchronized</code> 关键字或 <code>volatile</code> 关键字来实现。</li><li><strong>等待&#x2F;通知机制</strong>：使用 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code> 方法来实现等待和通知。当线程需要等待某个条件满足时，调用 <code>wait()</code> 方法使线程进入等待状态，而其他线程在某个条件满足时调用 <code>notify()</code> 或 <code>notifyAll()</code> 方法通知等待的线程继续执行。</li></ul></blockquote><h2 id="synchronized关键字的作用"><a href="#synchronized关键字的作用" class="headerlink" title="synchronized关键字的作用?"></a>synchronized关键字的作用?</h2><blockquote><p>synchronized关键字用于在Java程序中实现线程同步，确保同一时间，只有一个线程可以访问被保护的代码块（同步代码块）或方法（同步方法），避免出现数据竞争和不一致的情况。</p></blockquote><h2 id="synchronized和Lock有什么区别"><a href="#synchronized和Lock有什么区别" class="headerlink" title="synchronized和Lock有什么区别 ?"></a>synchronized和Lock有什么区别 ?</h2><blockquote><p>synchronized 和 Lock 都是用来保证线程安全的一种手段，但是他们有些区别</p><ul><li><strong>语法区别</strong>：synchronized是一个关键字，而Lock是一个接口</li><li><strong>获得锁的方式</strong>：synchronized关键字声明的锁是自动获取和释放的，由Java虚拟机自动完成；而Lock需要显式地调用lock()方法获取锁，并且必须在finally块中调用unlock()方法来释放锁。</li><li><strong>粒度区别</strong>：synchronized关键字粒度较粗，只能锁住整个方法或代码块；而Lock锁颗粒度相对细，在代码内部手动开启和释放。</li></ul></blockquote><h2 id="sleep-和-wait-有什么区别？"><a href="#sleep-和-wait-有什么区别？" class="headerlink" title="sleep() 和 wait() 有什么区别？"></a>sleep() 和 wait() 有什么区别？</h2><blockquote><p>sleep()和wait()都可以暂停线程的执行，但是他们有些区别</p><ul><li><p><strong>所属类不同</strong>：sleep()方法是Thread类中的方法，而wait()是Object 类中的方法</p></li><li><p><strong>作用不同</strong>：sleep()是让线程进入睡眠状态，到指定时间会恢复执行；wait()是让线程进入等待通知状态，需要其他线程调用 notify() 或 notifyAll() 方法来通知该线程继续执行</p></li><li><p><strong>使用方式不同</strong>：sleep()方法是静态的，可以在任何地方调用，而wait()只能在synchronized同步代码块或同步方法中使用，否则会抛出IllegalMonitorStateException异常。</p></li></ul></blockquote><h2 id="notify-和-notifyAll-有什么区别？"><a href="#notify-和-notifyAll-有什么区别？" class="headerlink" title="notify() 和 notifyAll() 有什么区别？"></a>notify() 和 notifyAll() 有什么区别？</h2><blockquote><p>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</p><p>notify()和notifyAll()都是用于唤醒被wait()方法挂起的线程，notifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。</p></blockquote><h2 id="多线程安全问题怎么解决？"><a href="#多线程安全问题怎么解决？" class="headerlink" title="多线程安全问题怎么解决？"></a>多线程安全问题怎么解决？</h2><blockquote><p>在多线程编程中，当多个线程同时访问和修改同一个变量时，可能会导致数据竞争和不一致的问题。为了解决这个线程安全问题，可以采用两种常见的解决方案：</p><ul><li><strong>时间换空间</strong>：通过使用同步机制（如synchronized关键字或Lock对象），确保在同一时间只有一个线程可以访问共享变量。当一个线程正在访问共享变量时，其他线程需要等待，从而避免了并发访问导致的线程安全问题。这种方式以时间换取了空间，但可能会引入线程竞争和上下文切换的开销。</li><li><strong>空间换时间</strong>：通过使用ThreadLocal将共享变量复制多份，每个线程都拥有自己独立的副本。这样，各个线程之间相互独立，彼此的操作不会相互干扰，避免了数据竞争和不一致的问题。虽然这种方式增加了内存消耗，但提高了程序的并发性能。</li></ul></blockquote><h2 id="volatile关键字的作用"><a href="#volatile关键字的作用" class="headerlink" title="volatile关键字的作用?"></a>volatile关键字的作用?</h2><blockquote><p>volatile关键字是一种轻量级的同步机制，使用volatile修饰的变量对所有线程可见，即一个线程修改了该变量的值，其他线程能够立即看到最新的值。</p><ol><li>为了提高程序的运行效率，编译器会对经常访问的变量进行缓存优化，将其缓存在寄存器或高速缓存中。当程序读取这些变量时，可以直接从缓存中获取值，而不需要每次都去访问内存，从而提高程序的执行效率。</li><li>然而，在多线程环境下，由于每个线程都有自己的缓存，当一个线程修改了变量的值时，其他线程可能仍然使用旧的缓存值，导致数据不一致。为了解决这个问题，可以使用volatile关键字修饰需要共享的变量。</li><li>使用volatile修饰的变量，编译器不会对该变量进行缓存优化，每次访问时都直接从主内存中读取值或写入值。当一个线程修改了volatile修饰的变量，其他线程立即能够看到最新的值，从而避免了数据不一致的问题。</li><li>需要注意的是，volatile关键字只保证变量的可读性和可写性，并不能保证对volatile变量的操作是原子性。如果需要保证多个操作的原子性，仍然需要使用锁或其他的同步机制。</li></ol></blockquote><h2 id="ThreadLocal是什么？"><a href="#ThreadLocal是什么？" class="headerlink" title="ThreadLocal是什么？"></a>ThreadLocal是什么？</h2><blockquote><p>ThreadLocal是Java中的一个类，用于在多线程环境下实现线程局部变量。它提供了一种机制，使得每个线程都可以拥有自己独立的变量副本，而不会与其他线程共享。</p></blockquote><h2 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a>什么是线程池？</h2><blockquote><p>线程池是指预先创建一定数量的线程，放置到一个池中，等待调用任务，任务完成后，该线程并不会被销毁，而是重新放回线程池中等待下一次调用</p></blockquote><h2 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h2><blockquote><p>在高并发情况下，需要频繁地创建线程和销毁线程，对性能影响很大。有了线程池，可以提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁，实现重复利用，提高系统性能和效率，以下是线程池的优点：</p><ul><li><strong>降低系统消耗</strong>：重复利用已经创建的线程降低线程创建和销毁造成的资源消耗</li><li><strong>提高响应速度</strong>：当任务到达时，任务不需要等到线程创建就可以立即执行</li><li><strong>提供线程管理</strong>：可以通过设置合理分配、调优、监控</li></ul></blockquote><h2 id="怎样创建线程池"><a href="#怎样创建线程池" class="headerlink" title="怎样创建线程池?"></a>怎样创建线程池?</h2><blockquote><p>线程池的创建方式共包含七种（其中六种是通过 <code>Executors</code> 创建的，一种是通过<code>ThreadPoolExecutor</code> 创建的）根据阿里巴巴的Java技术手册（编码规约），不推荐使用<code>Executors</code>工具类去创建线程池，而是推荐直接使用<code>ThreadPoolExecutor</code>的方式进行创建。</p><h2 id="通过Executors创建线程池"><a href="#通过Executors创建线程池" class="headerlink" title="通过Executors创建线程池"></a>通过<code>Executors</code>创建线程池</h2><p>创建线程池可以通过 <code>java.util.concurrent.Executors</code> 类中提供的静态方法来完成</p><ol><li><code>newFixedThreadPool(int nThreads)</code>：创建固定大小的线程池，线程池中的线程数量固定为 <code>nThreads</code>。当任务提交到线程池时，如果所有线程都在忙碌，那么任务会被放入等待队列中，直到有线程可用。</li><li><code>newSingleThreadExecutor()</code>：创建只有一个线程的线程池。该线程池保证任务按照先进先出的顺序执行。</li><li><code>newCachedThreadPool()</code>：创建可缓存的线程池。线程池的大小可以根据需要自动调整。当任务提交到线程池时，如果有空闲线程可用，则立即执行任务；如果没有可用线程，则创建新的线程执行任务。当线程空闲一段时间后，如果没有任务可执行，线程将被终止并从线程池中移除。</li><li><code>newScheduledThreadPool(int corePoolSize)</code>：创建定时执行任务的线程池。线程池中的线程数量固定为 <code>corePoolSize</code>。可以使用线程池提供的方法按照固定频率或者固定延迟执行任务。</li><li><code>newSingleThreadScheduledExecutor()</code>：创建只有一个线程的定时执行任务的线程池。该线程池保证任务按照固定频率或者固定延迟执行。</li><li><code>newWorkStealingPool()</code>：创建一个工作窃取线程池，Java 8 中新增的方法，该线程池可以根据系统的处理能力自动调整线程的数量，并且可以充分利用多核处理器的优势。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建固定大小的线程池，线程池中的线程数量为3</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">fixedThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 创建只有一个线程的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">singleThreadExecutor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="comment">// 创建可缓存的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">cachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 创建定时执行任务的线程池，线程池中的线程数量为3</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledThreadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 创建只有一个线程的定时执行任务的线程池</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">singleThreadScheduledExecutor</span> <span class="operator">=</span> Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">        <span class="comment">// 创建工作窃取线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">workStealingPool</span> <span class="operator">=</span> Executors.newWorkStealingPool();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过ThreadPoolExecutor创建线程池"><a href="#通过ThreadPoolExecutor创建线程池" class="headerlink" title="通过ThreadPoolExecutor创建线程池"></a>通过<code>ThreadPoolExecutor</code>创建线程池</h2><p>除了使用<code>Executors</code>类提供的方法外，我们还可以直接使用<code>ThreadPoolExecutor</code>类来创建线程池，这样可以更加灵活地配置线程池的属性。<code>ThreadPoolExecutor</code>构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">int</span> corePoolSize, // 线程池的核心线程数，即线程池中同时可以执行的线程数量。</span></span><br><span class="line"><span class="params">        <span class="type">int</span> maximumPoolSize, // 线程池的最大线程数，即线程池中最多可以创建的线程数量。</span></span><br><span class="line"><span class="params">        <span class="type">long</span> keepAliveTime,  // 空闲线程的存活时间，当线程数大于核心线程数时，多余的空闲线程在终止之前等待新任务的最长时间。</span></span><br><span class="line"><span class="params">        TimeUnit unit, // 空闲线程存活时间的单位，例如 TimeUnit.SECONDS 表示以秒为单位。</span></span><br><span class="line"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue, // 用于存放待执行任务的阻塞队列。</span></span><br><span class="line"><span class="params">        ThreadFactory threadFactory, // 用于创建新线程的工厂。</span></span><br><span class="line"><span class="params">        RejectedExecutionHandler handler // 线程池的饱和策略，即当线程池和阻塞队列都满了之后，如何处理新提交的任务。</span></span><br><span class="line"><span class="params">)</span> &#123; &#125;</span><br></pre></td></tr></table></figure><p>创建线程池代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池，核心线程数为2，最大线程数为5，等待队列容量为10</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>,  <span class="comment">// 核心线程数</span></span><br><span class="line">                <span class="number">5</span>,  <span class="comment">// 最大线程数</span></span><br><span class="line">                <span class="number">1</span>,  <span class="comment">// 线程空闲时间</span></span><br><span class="line">                TimeUnit.MINUTES,  <span class="comment">// 空闲时间单位</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>),  <span class="comment">// 等待队列</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()  <span class="comment">// 拒绝策略（当线程池和等待队列都满了时，由提交任务的线程来执行该任务）</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向线程池中添加任务并执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; System.out.println(<span class="string">&quot;任务&quot;</span> + taskId + <span class="string">&quot;正在执行，线程&quot;</span> + Thread.currentThread().getName()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池，不再接收新的任务，并等待已经提交的任务执行完毕</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="线程池的核心参数？"><a href="#线程池的核心参数？" class="headerlink" title="线程池的核心参数？"></a>线程池的核心参数？</h2><blockquote><p>Java 中的线程池由 <code>java.util.concurrent.Executors</code> 类提供。下面是线程池的一些核心参数：</p><ol><li><strong>核心线程数（Core Pool Size）</strong>：线程池中保持的最小线程数。即使线程处于空闲状态，核心线程也不会被销毁。当提交任务时，如果活动线程数小于核心线程数，则会创建新的线程来执行任务。</li><li><strong>最大线程数（Maximum Pool Size）</strong>：线程池允许存在的最大线程数。当活动线程数达到最大线程数时，后续提交的任务会进入任务队列等待执行（如果任务队列未满）。如果任务队列已满，且活动线程数已达到最大线程数，则根据拒绝策略来处理新提交的任务。</li><li><strong>任务队列（Blocking Queue）</strong>：用于存储待执行的任务的队列。当线程池中的线程都处于忙碌状态时，新提交的任务会被放入任务队列等待执行。</li><li><strong>线程空闲时间（Keep Alive Time）</strong>：当线程池中的线程数量超过核心线程数，并且空闲时间超过指定时间时，多余的线程会被销毁，直到线程数不超过核心线程数为止。</li><li><strong>线程工厂（Thread Factory）</strong>：用于创建新线程的工厂类。可以自定义线程的名称、优先级、线程组等属性。</li><li><strong>拒绝策略（Rejected Execution Handler）</strong>：当任务无法被线程池执行时的处理策略。常用的拒绝策略有：抛出异常、直接丢弃任务、丢弃队列中最旧的任务、将任务分发给调用者线程来执行等。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="type">int</span> corePoolSize, // 线程池的核心线程数，即线程池中同时可以执行的线程数量。</span></span><br><span class="line"><span class="params">        <span class="type">int</span> maximumPoolSize, // 线程池的最大线程数，即线程池中最多可以创建的线程数量。</span></span><br><span class="line"><span class="params">        <span class="type">long</span> keepAliveTime,  // 空闲线程的存活时间，当线程数大于核心线程数时，多余的空闲线程在终止之前等待新任务的最长时间。</span></span><br><span class="line"><span class="params">        TimeUnit unit, // 空闲线程存活时间的单位，例如 TimeUnit.SECONDS 表示以秒为单位。</span></span><br><span class="line"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue, // 用于存放待执行任务的阻塞队列。</span></span><br><span class="line"><span class="params">        ThreadFactory threadFactory, // 用于创建新线程的工厂。</span></span><br><span class="line"><span class="params">        RejectedExecutionHandler handler // 线程池的饱和策略，即当线程池和阻塞队列都满了之后，如何处理新提交的任务。</span></span><br><span class="line"><span class="params">)</span> &#123; &#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h2><blockquote><ol><li><strong>创建线程池</strong>：首先，创建一个线程池对象。可以使用 <code>java.util.concurrent.Executors</code> 类提供的静态方法来创建不同类型的线程池，如 <code>newFixedThreadPool()</code>、<code>newCachedThreadPool()</code> 等。</li><li><strong>提交任务</strong>：通过调用线程池对象的 <code>submit()</code> 或 <code>execute()</code> 方法来提交任务。任务可以是实现了 <code>Runnable</code> 接口或者 <code>Callable</code> 接口的对象。</li><li><strong>任务接收</strong>：线程池接收到任务后，会根据线程池的状态和配置来确定如何处理任务。如果线程池中的线程数小于核心线程数，会创建新的线程来执行任务；如果线程池中的线程数已达到核心线程数，任务会被放入任务队列等待执行；如果任务队列已满且线程池中的线程数未达到最大线程数，则会创建新的线程来执行任务；如果线程池中的线程数已达到最大线程数，且任务队列已满，根据拒绝策略来处理任务（如抛出异常、丢弃任务等）。</li><li><strong>任务执行</strong>：线程池中的线程从任务队列中取出任务，执行任务的逻辑。执行的方式取决于具体的任务类型，可以是 <code>Runnable</code> 对象的 <code>run()</code> 方法或 <code>Callable</code> 对象的 <code>call()</code> 方法。</li><li><strong>结果返回（仅适用于 <code>Callable</code> 任务）</strong>：如果任务是 <code>Callable</code> 类型的，并且需要返回结果，线程执行任务后会将结果返回。</li><li><strong>线程回收</strong>：任务执行完毕后，线程池中的线程可能会被回收。具体回收的条件取决于线程池的配置，例如空闲时间超过一定阈值、线程池关闭等。</li><li><strong>关闭线程池</strong>：当不再需要线程池时，可以调用 <code>shutdown()</code> 方法请求关闭线程池。这会停止接受新的任务，并等待线程池中正在执行的任务执行完毕。然后可以选择调用 <code>awaitTermination()</code> 方法等待线程池中的任务执行完毕，或者直接终止尚未完成的任务。</li></ol><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/线程池的执行流程.png" style="zoom:50%"></blockquote><h2 id="线程池都有哪几种工作队列？"><a href="#线程池都有哪几种工作队列？" class="headerlink" title="线程池都有哪几种工作队列？"></a>线程池都有哪几种工作队列？</h2><blockquote><ul><li><strong>直接提交队列（SynchronousQueue）：</strong> 这是一个<code>没有容量的队列</code>，任务提交给线程池后，如果没有空闲线程可用，则会立即创建一个新线程来执行任务，如果有多余的线程，则会尝试将任务直接交给空闲线程处理，而不将任务放入队列中。</li><li><strong>有界任务队列（LinkedBlockingQueue）：</strong> 这是一个<code>基于链表实现的有界队列</code>，可以指定队列的最大容量。当任务提交给线程池后，如果线程池中的线程数小于corePoolSize，则会创建新线程来处理任务；如果线程池中的线程数达到了corePoolSize，则任务会被放入队列中等待执行；如果队列已满，但线程池中的线程数小于maximumPoolSize，则会创建新线程来处理任务；如果队列已满且线程池中的线程数达到了maximumPoolSize，则会根据拒绝策略来处理任务。</li><li><strong>无界任务队列（LinkedBlockingDeque）：</strong> 这也是一个<code>基于链表实现的队列</code>，但是它的容量是无界的，可以无限地添加任务。当任务提交给线程池后，如果线程池中的线程数小于corePoolSize，则会创建新线程来处理任务；如果线程池中的线程数达到了corePoolSize，则任务会被放入队列中等待执行；由于队列是无界的，所以不会拒绝任务，只要有新任务到来，就会继续添加到队列中。</li><li><strong>优先级队列（PriorityBlockingQueue）：</strong> 这是一个<code>基于堆实现的优先级队列</code>，可以根据任务的优先级来决定执行顺序。任务提交给线程池后，会根据任务的优先级将任务放入对应的位置，并按照优先级顺序进行执行。</li></ul></blockquote><h1 id="Java-IO流相关面试题"><a href="#Java-IO流相关面试题" class="headerlink" title="Java IO流相关面试题"></a>Java IO流相关面试题</h1><h2 id="Java-中-IO-流分为几种？"><a href="#Java-中-IO-流分为几种？" class="headerlink" title="Java 中 IO 流分为几种？"></a>Java 中 IO 流分为几种？</h2><blockquote><p><strong>按流向来分</strong>：输入流和输出流。</p><p><strong>按类型来分</strong>：字节流和字符流。</p><p><strong>按功能来分</strong>：节点流和处理流。</p></blockquote><h2 id="字节流和字符流的区别是什么？"><a href="#字节流和字符流的区别是什么？" class="headerlink" title="字节流和字符流的区别是什么？"></a>字节流和字符流的区别是什么？</h2><blockquote><p><strong>字节流</strong>： 操作的单元是数据单元是8位的字节，例如图片、音乐、视频等文件，可以对二进制文件进行处理</p><p><strong>字符流</strong>：操作的是数据单元为16位的字符，例如.txt、.java、.c、.cpp等文本文件，.doc、excel、ppt这些不是文本文件</p></blockquote><h2 id="常见的五种-IO-模型？"><a href="#常见的五种-IO-模型？" class="headerlink" title="常见的五种 IO 模型？"></a>常见的五种 IO 模型？</h2><blockquote><p>IO模型（Input&#x2F;Output Model）是描述在计算机系统中，如何处理输入和输出操作的一种模型，常见的有如下几种</p><ol><li><strong>阻塞IO模型（Blocking IO Model）</strong>：当应用程序执行IO操作时，整个进程会被阻塞，直到操作完成。在等待IO完成期间无法执行其他任务，效率较低。</li><li><strong>非阻塞IO模型（Non-blocking IO Model）</strong>：当应用程序执行IO操作时，可以立即返回，而不必等待操作完成。通过轮询或异步通知方式，应用程序可以继续执行其他任务，并周期性地检查IO操作是否完成，但仍然需要主动轮询，效率仍然有限。</li><li><strong>多路复用IO模型（Multiplexing IO Model）</strong>：通过使用系统调用（如select、poll、epoll等），可以同时监听多个IO操作的完成情况。应用程序将IO操作注册给内核，内核会通知应用程序哪些IO操作已经完成，从而避免了轮询的开销，提高了效率。</li><li><strong>信号驱动IO模型（Signal-driven IO Model）</strong>：应用程序将IO操作注册给内核，并指定一个信号处理函数。当IO操作完成时，内核会向应用程序发送一个信号，应用程序在信号处理函数中进行相应的处理。这种模型可以避免轮询，但需要处理信号的开销。</li><li><strong>异步IO模型（Asynchronous IO Model）</strong>：应用程序发起IO操作后，不需要等待操作完成，可以继续执行其他任务。当IO操作完成时，系统会通知应用程序，应用程序可以回调相应的处理函数进行后续处理。异步IO模型相对于其他模型较为复杂，但具有较高的性能和灵活性。</li></ol><p>为了方便理解IO模型，可以拿现实中的例子来比喻这个过程，假设一个老师正在收取学生的作业。</p><ol><li><strong>同步阻塞方式（Blocking）</strong>：老师逐个学生地等待每个学生完成作业再继续收下一个学生的作业。当一个学生没有完成作业时，老师会一直等待，直到该学生完成作业后才能继续收取下一个学生的作业。这种方式下，老师需要阻塞等待每个学生完成作业，效率较低。</li><li><strong>同步非阻塞方式（Non-blocking）</strong>：老师逐个学生地收取作业，但如果某个学生还没完成作业，老师会暂时跳过该学生继续收取下一个学生的作业，直到之前的学生完成作业后再回来收取。这种方式下，老师不会阻塞在每个学生上，但仍然需要轮询每个学生是否完成作业。</li><li><strong>IO多路复用方式（select和poll）</strong>：老师相当于在询问所有的学生是否完成作业，但并不知道具体哪个学生完成了。老师持续地询问每个学生是否完成作业，直到所有学生中有学生举手表示完成作业为止。这种方式下，老师需要不断地轮询每个学生来确定是否完成作业，存在一定的性能开销。</li><li><strong>IO多路复用方式（epoll）</strong>：学生举手相当于触发了一个事件，并告诉老师是哪个学生举手了。老师只需要关注那些举手的学生，而不需要轮询询问每个学生，从而提高了效率。这种方式下，老师能够直接知道具体是哪个学生完成了作业，避免了轮询和性能开销。</li><li><strong>异步IO方式（Async）</strong>：老师委托一位助教负责收取学生的作业，然后可以继续进行其他工作。助教负责等待学生完成作业，当有学生完成作业时，助教会通知老师。这种方式下，老师完全不需要关注学生的作业进度，只需等待助教的通知即可。与其他模型相比，异步IO方式能够充分利用时间，提高效率。</li></ol></blockquote><h2 id="BIO、NIO、AIO-有什么区别？"><a href="#BIO、NIO、AIO-有什么区别？" class="headerlink" title="BIO、NIO、AIO 有什么区别？"></a>BIO、NIO、AIO 有什么区别？</h2><blockquote><p><strong>BIO（同步阻塞I&#x2F;O）</strong>：简单方便，并发处理能力低。</p><p><strong>NIO（同步非阻塞I&#x2F;O）</strong>：是传统 IO 的升级，实现了IO多路复用。</p><p><strong>AIO（异步非阻塞I&#x2F;O）</strong>：对NIO的升级，采用了异步的方式处理I&#x2F;O操作</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/BIO、NIO、AIO.png" style="zoom:50%"></blockquote><h1 id="Java反射相关面试题"><a href="#Java反射相关面试题" class="headerlink" title="Java反射相关面试题"></a>Java反射相关面试题</h1><h2 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h2><blockquote><p>在Java中，反射是一种机制，通过反射，可以在运行时获取类的信息（例如字段、方法、构造函数等），并且可以动态地操作类、对象和成员。</p><ul><li><strong>动态地创建和访问对象</strong>：使用反射可以实例化一个类的对象，即使在编译时并不知道具体的类名。</li><li><strong>动态地调用方法</strong>：反射可以在运行时调用一个对象的方法，甚至通过反射来调用私有方法。</li><li><strong>获取和设置字段的值</strong>：通过反射可以获取和设置对象中的字段的值，即使这些字段是私有的。</li><li><strong>获取和操作类、接口、构造函数等</strong>：反射还可以获取和操作类的信息，如获取类的注解、实现的接口、父类等。</li></ul></blockquote><h2 id="反射的优缺点？"><a href="#反射的优缺点？" class="headerlink" title="反射的优缺点？"></a>反射的优缺点？</h2><blockquote><p>反射的优点：</p><ul><li><strong>动态性</strong>：反射使得程序能够在运行时动态地获取和操作类的信息，而不需要在编译期间确定，提高了灵活性和可扩展性</li><li><strong>框架工具开发</strong>：反射机制为一些框架和工具提供了基础。例如，测试框架可以使用反射来自动化测试对象的属性和方法，而依赖注入框架可以通过反射来自动注入依赖。</li></ul><p>反射的缺点：</p><ul><li><strong>性能开销</strong>：反射机制通常比直接调用代码的方式更慢。由于反射需要在运行时进行类型检查、方法查找等操作，因此会引入一定的性能开销。</li><li><strong>安全性问题</strong>：反射机制可以绕过访问修饰符（如私有、受保护等），并允许访问和修改本来不应该被暴露的成员。这可能导致程序的安全性问题。</li><li><strong>代码可读性和维护性</strong>：反射的代码通常较为复杂，可读性较差。由于反射操作的灵活性，一些错误可能直到运行时才能被发现，不利于排查问题和维护代码。</li></ul></blockquote><h2 id="哪里用到反射机制？"><a href="#哪里用到反射机制？" class="headerlink" title="哪里用到反射机制？"></a>哪里用到反射机制？</h2><blockquote><ul><li><strong>JDBC</strong>：动态加载数据库的驱动，进行连接</li><li><strong>Spring IOC</strong>：基于XML配置文件，动态地读取并实例化Bean对象</li><li><strong>动态代理</strong>：反射机制可以在运行时创建代理类对象</li></ul></blockquote><h1 id="Java异常相关面试题"><a href="#Java异常相关面试题" class="headerlink" title="Java异常相关面试题"></a>Java异常相关面试题</h1><h2 id="Error和Exception有什么区别？"><a href="#Error和Exception有什么区别？" class="headerlink" title="Error和Exception有什么区别？"></a>Error和Exception有什么区别？</h2><blockquote><p><strong>Error（错误）</strong>：Error类及其子类用于表示严重的程序错误或系统错误，通常由虚拟机（JVM）抛出，无法通过代码处理来修复的，它们通常表示严重的问题，例如内存溢出（OutOfMemoryError）或栈溢出（StackOverflowError）。</p><p><strong>Exception（异常）</strong>： Exception类及其子类用于表示在程序执行期间发生的非正常情况或错误。分为两种类型：编译时异常（Checked Exception）和运行时异常（Unchecked Exception）。编译时异常需要在代码编写阶段处理，否则会导致编译错误。</p></blockquote><h2 id="异常的分类？"><a href="#异常的分类？" class="headerlink" title="异常的分类？"></a>异常的分类？</h2><blockquote><p>异常主要分为两种，分别是编译时异常和运行时异常（只要一个异常类的祖先类中有RuntimeException，那么就是运行时异常，否则是编译时异常）</p><p><strong>编译时异常</strong>：编译时异常需要在代码编写阶段处理，否则会导致编译错误，继承自<code>Exception</code>类。常见的编译时异常包括IO异常（IOException）、SQL异常（SQLException）等。</p><p><strong>运行时异常</strong>：运行时异常是指那些不需要在代码中强制处理的异常，继承自<code>RuntimeException</code>类或其子类。在代码中可以处理，但不要求强制处理。通常由程序逻辑错误引起，例如空指针异常（NullPointerException）、数组越界异常（ArrayIndexOutOfBoundsException）等。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/异常体系.png" style="zoom:50%"></blockquote><h2 id="怎么处理异常？"><a href="#怎么处理异常？" class="headerlink" title="怎么处理异常？"></a>怎么处理异常？</h2><blockquote><p><strong>捕获异常</strong>：使用try-catch-finally或try-with-resources捕获异常</p><p><strong>抛出异常</strong>：使用throw或throws抛出异常</p></blockquote><h2 id="try-catch-finally-和-try-with-resources的区别？"><a href="#try-catch-finally-和-try-with-resources的区别？" class="headerlink" title="try-catch-finally 和 try-with-resources的区别？"></a>try-catch-finally 和 try-with-resources的区别？</h2><blockquote><p>try-catch-finally和try-with-resources是Java中用于异常处理的两种不同的语法结构</p><p>try-catch-finally：try块中包含可能抛出异常的代码。如果发生异常，会根据异常类型进入相应的catch块进行处理。无论是否发生异常，finally块中的代码都会执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType1 exception1) &#123;</span><br><span class="line">    <span class="comment">// 处理 ExceptionType1 类型的异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType2 exception2) &#123;</span><br><span class="line">    <span class="comment">// 处理 ExceptionType2 类型的异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 无论是否发生异常，都会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try-with-resources除了拥有try-catch-finally的所有功能，还提供了自动关闭资源的能力，能够在代码执行完毕后自动关闭 try 块中声明的资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (</span><br><span class="line">    <span class="type">ResourceType</span> <span class="variable">resource1</span> <span class="operator">=</span> initialization1; <span class="comment">// 声明并初始化第一个资源</span></span><br><span class="line">    <span class="type">ResourceType</span> <span class="variable">resource2</span> <span class="operator">=</span> initialization2; <span class="comment">// 声明并初始化第二个资源</span></span><br><span class="line">    <span class="comment">// 声明更多的资源（more resources...）</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// 在try块中使用资源对象（use resources here）</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType1 e1) &#123;</span><br><span class="line">    <span class="comment">// 捕获try块抛出的ExceptionType1异常（catch exceptions thrown from try block）</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExceptionType2 e2) &#123;</span><br><span class="line">    <span class="comment">// 捕获try块抛出的ExceptionType2异常（catch exceptions thrown from try block）</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 总是会被执行的清理操作（be executed always）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="throw和throws的区别"><a href="#throw和throws的区别" class="headerlink" title="throw和throws的区别?"></a>throw和throws的区别?</h2><blockquote><p><strong>throw 关键字</strong>：用在方法内部，只能用于抛出一种异常，用来抛出方法或代码块中 的异常，受查异常和非受查异常都可以被抛出。<br><strong>throws 关键字</strong>：用在方法声明上，可以抛出多个异常，用来标识该方法可能抛出 的异常列表。一个方法用 throws 标识了可能抛出的异常列表，调用该方法的方法中 必须包含可处理异常的代码，否则也要在方法签名中用 throws 关键字声明相应的异常。</p></blockquote><h2 id="final、finally、finalize的区别"><a href="#final、finally、finalize的区别" class="headerlink" title="final、finally、finalize的区别?"></a>final、finally、finalize的区别?</h2><blockquote><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p>final是一个关键字，可以用来修饰的结构：类、方法、变量（成员变量、局部变量、形参、引用地址）</p><ul><li><strong>修饰类</strong>：用<code>final</code>修饰的类不能被其他类继承</li><li><strong>修饰方法</strong>：用<code>final</code>修饰的方法不能被子类重写</li><li><strong>修饰变量</strong>：用<code>final</code>修饰的变量表示常量，即其值一旦被初始化后就不能被修改。对于基本数据类型的变量，该值是不可变的；对于引用类型的变量，该引用不能再指向其他对象，但是该对象的内容可以被修改。</li></ul><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>finally也是一个关键字，用于定义一个代码块，通常与try-catch结构一起使用。finally通常用于释放资源，如关闭数据库连接、文件IO等操作，以确保资源的正常释放。不论是否发生异常，finally中的代码块始终会执行</p><h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h2><p>finalize是Object类中的一个方法，用于在垃圾回收器回收对象之前调用，Jdk9中废弃</p></blockquote><h2 id="如何自定义异常？"><a href="#如何自定义异常？" class="headerlink" title="如何自定义异常？"></a>如何自定义异常？</h2><blockquote><p>所有异常都必须是Throwable 的子类，自定义异常类需要创建一个类并继承Exception或RuntimeException类</p><ul><li><p><strong>自定义编译时异常类</strong>：继承Exception类。</p></li><li><p><strong>自定义运行时异常类</strong>：继承 RuntimeException类。</p></li></ul><p>使用自定义异常类时，可以像使用其他异常一样使用它，可以抛出或者捕获</p></blockquote><h1 id="Java新特性相关面试题"><a href="#Java新特性相关面试题" class="headerlink" title="Java新特性相关面试题"></a>Java新特性相关面试题</h1><h2 id="什么是Lambda表达式？"><a href="#什么是Lambda表达式？" class="headerlink" title="什么是Lambda表达式？"></a>什么是Lambda表达式？</h2><blockquote><p>Lambda表达式是Java 8引入的一项重要的新特性，主要受到函数式编程思想的影响。函数式编程思想强调的是对数据进行操作的方式，而不关注具体的对象是什么。Lambda表达式可以被理解为一种匿名函数，它基于数学中的λ演算而得名，也可以称为闭包（Closure）。</p><ul><li><strong>优点</strong>：简化代码，开发迅速，使得函数式编程更加方便。</li><li><strong>缺点</strong>：代码可读性变差，不容易进行调试。</li></ul></blockquote><h2 id="Lambda表达式的语法？"><a href="#Lambda表达式的语法？" class="headerlink" title="Lambda表达式的语法？"></a>Lambda表达式的语法？</h2><blockquote><p>Lambda表达式由Lambda参数、箭头符号（<code>-&gt;</code>）和方法体组成，语法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( paramaters ) -&gt; &#123; 主体部分 &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>组成</th><th>简介</th></tr></thead><tbody><tr><td>paramaters</td><td>Lambda参数列表，可以有零个或多个参数，参数类型可以显式指定，也可以由编译器根据上下文自动推断。<br>如果没有参数，则可以使用空括号<code>()</code>表示；<br>如果只有一个参数，可以省略参数的括号；<br>如果有多个参数，需要使用括号<code>()</code>包裹，并用逗号将参数分隔。</td></tr><tr><td>-&gt;</td><td>箭头操作符，可理解为“被用于”的意思，用于分隔参数列表与Lambda表达式的主体部分</td></tr><tr><td>主体部分</td><td>可以是一个表达式，也可以是一个代码块。<br>如果是一个表达式，则可以省略return关键字，返回一个值或者什么都不返回，等同于方法的方法体；<br>如果是一个代码块，则需要使用花括号将多个语句括起来，并且需要显式使用<code>return</code>语句来返回值。</td></tr></tbody></table></blockquote><h2 id="什么是函数式接口？"><a href="#什么是函数式接口？" class="headerlink" title="什么是函数式接口？"></a>什么是函数式接口？</h2><blockquote><p>有且只有一个抽象方法的接口，称为函数式接口（Functional Interface）。<code>在Java中，Lambda表达式是对函数式接口的一种简写方式，只有一个接口是函数式接口时，才能用Lambda表达式</code>。</p></blockquote><h2 id="Stream流怎么使用？"><a href="#Stream流怎么使用？" class="headerlink" title="Stream流怎么使用？"></a>Stream流怎么使用？</h2><blockquote><ul><li><strong>创建流</strong>：将数据源转换为Stream流</li><li><strong>操作流</strong>：中间操作链，对数据源的数据进行处理（过滤、聚合等）</li><li><strong>结束流</strong>：终止操作，执行中间操作链，并产生结果</li></ul></blockquote><h2 id="新日期时间API？"><a href="#新日期时间API？" class="headerlink" title="新日期时间API？"></a>新日期时间API？</h2><blockquote><p>Java 8引入了新的日期时间API（java.time包），以替代旧的Date和Calendar类。新的日期时间API提供了更简单、更灵活和更强大的日期和时间处理功能。</p><ol><li><strong>LocalDate</strong>：用于表示日期（年、月、日）的类。它提供了丰富的日期操作方法，例如计算、比较、格式化等。</li><li><strong>LocalTime</strong>：用于表示时间（小时、分钟、秒）的类。它同样提供了多种时间操作方法。</li><li><strong>LocalDateTime</strong>：用于表示日期和时间的类，相当于同时包含了LocalDate和LocalTime的信息。</li><li><strong>Instant</strong>：用于表示时间戳的类，可以精确到纳秒级别。它可以与旧的Date类进行转换。</li><li><strong>Duration</strong>：用于表示两个时间之间的时间间隔，可以精确到纳秒级别。</li><li><strong>Period</strong>：用于表示两个日期之间的时间间隔，以年、月、日为单位。</li><li><strong>DateTimeFormatter</strong>：用于格式化和解析日期时间对象，可以将日期时间对象转换为字符串，或将字符串解析为日期时间对象。</li><li><strong>ZoneId</strong>和<strong>ZonedDateTime</strong>：用于处理时区信息的类，可以将日期时间对象与特定时区关联。</li></ol></blockquote><h2 id="Optional类？"><a href="#Optional类？" class="headerlink" title="Optional类？"></a>Optional类？</h2><blockquote><p>Java 8引入了Optional类作为新的特性，用于解决空指针异常的问题。</p><p>Optional类是一个容器类，它可以包含某个类型的对象或者表示对象不存在。</p><p>通过使用Optional类，我们可以避免显式地检查对象是否为null以及处理空指针异常的情况。</p></blockquote></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://w_e_n.gitee.io/blog">wen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://w_e_n.gitee.io/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/">https://w_e_n.gitee.io/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://w_e_n.gitee.io/blog" target="_blank">远方の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><div class="post_share"><div class="social-share" data-image="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/%E9%9D%A2%E8%AF%95%E9%A2%98.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/" title="面试题-Web开发与常用框架"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/%E9%9D%A2%E8%AF%95%E9%A2%98.png" onerror='onerror=null,src="/blog/img/404.png"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面试题-Web开发与常用框架</div></div></a></div><div class="next-post pull-right"><a href="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-MySQL/" title="面试题-MySQL"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-MySQL/%E9%9D%A2%E8%AF%95%E9%A2%98.png" onerror='onerror=null,src="/blog/img/404.png"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">面试题-MySQL</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Redis/" title="面试题-Redis"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Redis/%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-01</div><div class="title">面试题-Redis</div></div></a></div><div><a href="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/" title="面试题-微服务与中间件"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-01</div><div class="title">面试题-微服务与中间件</div></div></a></div><div><a href="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF%E5%92%8C%E5%B7%A5%E5%85%B7/" title="面试题-技术场景和工具"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF%E5%92%8C%E5%B7%A5%E5%85%B7/%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-01</div><div class="title">面试题-技术场景和工具</div></div></a></div><div><a href="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/" title="面试题-Web开发与常用框架"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-01</div><div class="title">面试题-Web开发与常用框架</div></div></a></div><div><a href="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-MySQL/" title="面试题-MySQL"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-MySQL/%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-01</div><div class="title">面试题-MySQL</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Gitalk</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/img/%E5%A4%B4%E5%83%8F.png" onerror='this.onerror=null,this.src="/blog/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">wen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wen53231323"><i class="fab fa-github"></i><span>我的仓库</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">暂无</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">Java基础相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK%E3%80%81JRE%E3%80%81JVM%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">JDK、JRE、JVM的关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%85%AB%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">Java八种数据类型有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%85%AB%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">说一说八种数据类型的包装类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">基本类型和包装类型的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">什么是自动装箱与自动拆箱？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E5%B1%9E%E4%BA%8E%E5%9F%BA%E7%A1%80%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%90%97%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">String属于基础的数据类型吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">String常用的方法有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E4%B8%AD%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">Java中操作字符串都有哪些类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E3%80%81StringBuffer%E3%80%81StringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">String、StringBuffer、StringBuilder的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">什么是字符串常量池？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B7%BB%E5%8A%A0%E5%88%B0%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">怎样将字符串添加到常量池？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4-amp-%E4%B8%8E-amp-amp-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.12.</span> <span class="toc-text">说一说&amp;与&amp;&amp;的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4-%E4%B8%8E-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">说一说|与||的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4-x3D-%E4%B8%8E-x3D-x3D-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.14.</span> <span class="toc-text">说一说&#x3D;与&#x3D;&#x3D;的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88str1-x3D-x3D-str2%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E4%B8%BA-true-%EF%BC%9F"><span class="toc-number">1.15.</span> <span class="toc-text">为什么str1 &#x3D;&#x3D; str2输出结果为 true ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88str3-x3D-x3D-str4%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E4%B8%BA-false-%EF%BC%9F"><span class="toc-number">1.16.</span> <span class="toc-text">为什么str3 &#x3D;&#x3D; str4输出结果为 false ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4-x3D-x3D-%E4%B8%8Eequals-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.17.</span> <span class="toc-text">说一说&#x3D;&#x3D;与equals()有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x3D-x3D-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.18.</span> <span class="toc-text">&#x3D;&#x3D;运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#equals-%E6%96%B9%E6%B3%95"><span class="toc-number">1.19.</span> <span class="toc-text">equals()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4Object%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">1.20.</span> <span class="toc-text">说一说Object类中的常见方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashCode-%E5%92%8Cequals-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.21.</span> <span class="toc-text">hashCode()和equals()的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99equals-%E8%A6%81%E9%87%8D%E5%86%99hashCode-%EF%BC%9F"><span class="toc-number">1.22.</span> <span class="toc-text">为什么重写equals()要重写hashCode()？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">Java面向对象相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">什么是面向对象思想？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="toc-number">2.2.</span> <span class="toc-text">面向过程思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.2.1.</span> <span class="toc-text">什么是过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">2.2.2.</span> <span class="toc-text">什么是面向过程？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3"><span class="toc-number">2.3.</span> <span class="toc-text">面向对象思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">2.3.1.</span> <span class="toc-text">什么是对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">2.3.2.</span> <span class="toc-text">什么是面向对象？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%EF%BC%9F"><span class="toc-number">2.4.</span> <span class="toc-text">面向对象的三大特征？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E6%80%A7"><span class="toc-number">2.5.</span> <span class="toc-text">封装性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%80%A7"><span class="toc-number">2.6.</span> <span class="toc-text">继承性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7"><span class="toc-number">2.7.</span> <span class="toc-text">多态性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E5%A4%9A%E6%80%81%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">2.8.</span> <span class="toc-text">谈谈你对多态的理解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E5%BE%81%EF%BC%9F"><span class="toc-number">2.9.</span> <span class="toc-text">构造方法有哪些特征？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.10.</span> <span class="toc-text">接口和抽象类有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%EF%BC%88Overload%EF%BC%89%E5%92%8C%E9%87%8D%E5%86%99%EF%BC%88Override%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.11.</span> <span class="toc-text">重载（Overload）和重写（Override）的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%EF%BC%88Overload%EF%BC%89"><span class="toc-number">2.12.</span> <span class="toc-text">重载（Overload）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%86%99%EF%BC%88Override%EF%BC%89"><span class="toc-number">2.13.</span> <span class="toc-text">重写（Override）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%EF%BC%88Overload%EF%BC%89%E5%92%8C%E9%87%8D%E5%86%99%EF%BC%88Override%EF%BC%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.14.</span> <span class="toc-text">重载（Overload）和重写（Override）的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4this%E4%B8%8Esuper%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.15.</span> <span class="toc-text">说说this与super的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#break%E3%80%81continue%E3%80%81return-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">2.16.</span> <span class="toc-text">break、continue、return 的区别及作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">2.17.</span> <span class="toc-text">static关键字有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">2.18.</span> <span class="toc-text">final关键字有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.19.</span> <span class="toc-text">深拷贝和浅拷贝的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.20.</span> <span class="toc-text">引用拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.21.</span> <span class="toc-text">对象拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.22.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.23.</span> <span class="toc-text">深拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">2.24.</span> <span class="toc-text">实现深拷贝的方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E7%BB%A7%E6%89%BFCloneable%E9%87%8D%E5%86%99clone%E6%96%B9%E6%B3%95"><span class="toc-number">2.25.</span> <span class="toc-text">深拷贝实现方式一：继承Cloneable重写clone方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">2.26.</span> <span class="toc-text">深拷贝实现方式二：使用序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">2.27.</span> <span class="toc-text">深拷贝实现方式三：使用工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4Java%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">2.28.</span> <span class="toc-text">说一说Java的四种引用方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%88Strong-Reference%EF%BC%89"><span class="toc-number">2.29.</span> <span class="toc-text">强引用（Strong Reference）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8%EF%BC%88Soft-Reference%EF%BC%89"><span class="toc-number">2.30.</span> <span class="toc-text">软引用（Soft Reference）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%88Weak-Reference%EF%BC%89"><span class="toc-number">2.31.</span> <span class="toc-text">弱引用（Weak Reference）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8%EF%BC%88Phantom-Reference%EF%BC%89"><span class="toc-number">2.32.</span> <span class="toc-text">虚引用（Phantom Reference）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.33.</span> <span class="toc-text">四种引用的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9F"><span class="toc-number">2.34.</span> <span class="toc-text">什么是序列化与反序列化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E9%9C%80%E8%A6%81%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">2.35.</span> <span class="toc-text">什么情况需要序列化与反序列化?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%89%E4%BB%80%E4%B9%88%E5%89%8D%E6%8F%90%EF%BC%9F"><span class="toc-number">2.36.</span> <span class="toc-text">序列化与反序列化有什么前提？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%9F%90%E4%BA%9B%E6%95%B0%E6%8D%AE%E4%B8%8D%E6%83%B3%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">2.37.</span> <span class="toc-text">如果某些数据不想序列化与反序列化怎么办?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8transient%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.38.</span> <span class="toc-text">方式一：使用transient关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-number">2.39.</span> <span class="toc-text">方式二：自定义序列化方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E4%BD%BF%E7%94%A8Externalizable%E6%8E%A5%E5%8F%A3%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-number">2.40.</span> <span class="toc-text">方式三：使用Externalizable接口自定义序列化方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">Java集合相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89%E9%9B%86%E5%90%88%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">有数组为什么还要有集合？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9A%84%E5%9F%BA%E7%A1%80%E6%8E%A5%E5%8F%A3%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">Java集合框架的基础接口有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.3.</span> <span class="toc-text">Collection单列集合接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.4.</span> <span class="toc-text">Map双列集合接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%99%E4%BA%9B%E6%8E%A5%E5%8F%A3%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">这些接口常见的实现类有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E6%8E%A5%E5%8F%A3%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">3.6.</span> <span class="toc-text">List接口常见实现类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%E6%8E%A5%E5%8F%A3%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">3.7.</span> <span class="toc-text">Set接口常见实现类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Queue%E6%8E%A5%E5%8F%A3%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">3.8.</span> <span class="toc-text">Queue接口常见实现类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E6%8E%A5%E5%8F%A3%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-number">3.9.</span> <span class="toc-text">Map接口常见实现类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E3%80%81Set%E3%80%81Map-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.10.</span> <span class="toc-text">List、Set、Map 之间的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.11.</span> <span class="toc-text">List接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.12.</span> <span class="toc-text">Set接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.13.</span> <span class="toc-text">Map接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%EF%BC%88Array%EF%BC%89-%E5%92%8C-%E5%88%97%E8%A1%A8%EF%BC%88List%EF%BC%89-%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.14.</span> <span class="toc-text">数组（Array） 和 列表（List） 如何转换?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array-%E8%BD%AC-List"><span class="toc-number">3.15.</span> <span class="toc-text">Array 转 List</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List-%E8%BD%AC-Array"><span class="toc-number">3.16.</span> <span class="toc-text">List 转 Array</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">3.17.</span> <span class="toc-text">ArrayList的底层实现原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E6%89%A9%E5%AE%B9%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">3.18.</span> <span class="toc-text">ArrayList扩容是怎么实现的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList-%E5%92%8C-LinkedList-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.19.</span> <span class="toc-text">ArrayList 和 LinkedList 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList-%E5%92%8C-Vector-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.20.</span> <span class="toc-text">ArrayList 和 Vector 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">3.21.</span> <span class="toc-text">HashSet 的底层实现原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet-%E5%92%8C-LinkedHashSet-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.22.</span> <span class="toc-text">HashSet 和 LinkedHashSet 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet-%E5%92%8C-TreeSet-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.23.</span> <span class="toc-text">HashSet 和 TreeSet 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">3.24.</span> <span class="toc-text">HashMap的底层实现原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">3.25.</span> <span class="toc-text">HashMap底层数据结构？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F"><span class="toc-number">3.26.</span> <span class="toc-text">HashMap为什么用红黑树？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">3.27.</span> <span class="toc-text">HashMap为什么不使用其他数据结构？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">3.28.</span> <span class="toc-text">红黑树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL-Tree%EF%BC%89"><span class="toc-number">3.29.</span> <span class="toc-text">平衡二叉树（AVL Tree）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B%E6%A0%91%E5%92%8CB-%E6%A0%91"><span class="toc-number">3.30.</span> <span class="toc-text">B树和B+树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E9%93%BE%E8%A1%A8%E5%A4%A7%E4%BA%8E8%E6%89%8D%E8%BF%9B%E8%A1%8C%E6%A0%91%E5%8C%96%EF%BC%9F"><span class="toc-number">3.31.</span> <span class="toc-text">HashMap为什么链表大于8才进行树化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E6%89%A9%E5%AE%B9%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">3.32.</span> <span class="toc-text">HashMap扩容是怎么实现的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E6%98%AF%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%EF%BC%9F"><span class="toc-number">3.33.</span> <span class="toc-text">HashMap是怎么解决哈希冲突的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-2-%E7%9A%84%E5%B9%82%E6%AC%A1%E6%96%B9%EF%BC%9F"><span class="toc-number">3.34.</span> <span class="toc-text">HashMap 的长度为什么是 2 的幂次方？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E4%B8%AD%E7%9A%84put-%E6%96%B9%E6%B3%95"><span class="toc-number">3.35.</span> <span class="toc-text">HashMap中的put()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E4%B8%AD%E7%9A%84get-%E6%96%B9%E6%B3%95"><span class="toc-number">3.36.</span> <span class="toc-text">HashMap中的get()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-%E5%92%8C-Hashtable-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.37.</span> <span class="toc-text">HashMap 和 Hashtable 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-%E5%92%8C-TreeMap-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.38.</span> <span class="toc-text">HashMap 和 TreeMap 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap-%E5%92%8C-HashSet-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.39.</span> <span class="toc-text">HashMap 和 HashSet 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E7%A1%AE%E4%BF%9D%E4%B8%80%E4%B8%AA%E9%9B%86%E5%90%88%E4%B8%8D%E8%A2%AB%E4%BF%AE%E6%94%B9"><span class="toc-number">3.40.</span> <span class="toc-text">怎么确保一个集合不被修改?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%8F%AF%E5%8F%98%E9%9B%86%E5%90%88"><span class="toc-number">3.41.</span> <span class="toc-text">使用不可变集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%AA%E8%AF%BB%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.42.</span> <span class="toc-text">使用只读接口实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E9%9B%86%E5%90%88%E7%B1%BB%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">3.43.</span> <span class="toc-text">哪些集合类是线程安全的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%98%AF%E5%90%A6%E5%85%81%E8%AE%B8Null%E5%80%BC%EF%BC%9F"><span class="toc-number">3.44.</span> <span class="toc-text">集合是否允许Null值？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Comparable-%E5%92%8C-Comparator-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.45.</span> <span class="toc-text">Comparable 和 Comparator 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection-%E5%92%8C-Collections-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.46.</span> <span class="toc-text">Collection 和 Collections 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E4%B8%80%E8%AF%B4Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="toc-number">3.47.</span> <span class="toc-text">说一说Iterator迭代器接口？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFFail-Fast%E5%92%8CFail-Safe%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">3.48.</span> <span class="toc-text">什么是Fail-Fast和Fail-Safe机制？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%B3%9B%E5%9E%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">Java泛型相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">什么是泛型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">为什么使用泛型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">什么是泛型擦除？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E6%B3%9B%E5%9E%8B%E6%93%A6%E9%99%A4%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">为什么要进行泛型擦除？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">Java多线程相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">线程和进程的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.2.</span> <span class="toc-text">并行和并发有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E4%B8%AA%E5%BF%85%E8%A6%81%E5%9B%A0%E7%B4%A0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.3.</span> <span class="toc-text">并发编程三个必要因素是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">创建线程有几种方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-number">5.5.</span> <span class="toc-text">继承Thread类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.6.</span> <span class="toc-text">实现Runnable接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.7.</span> <span class="toc-text">实现Callable接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%9B%B4%E5%A5%BD%EF%BC%9F"><span class="toc-number">5.8.</span> <span class="toc-text">哪种方式创建线程更好？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Runnable%E6%8E%A5%E5%8F%A3%E5%92%8CCallable%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.9.</span> <span class="toc-text">Runnable接口和Callable接口有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84-run-%E5%92%8C-start-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.10.</span> <span class="toc-text">线程的 run()和 start()有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">5.11.</span> <span class="toc-text">怎样停止线程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8C%85%E6%8B%AC%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%8C%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E5%8C%96%E7%9A%84%EF%BC%9F"><span class="toc-number">5.12.</span> <span class="toc-text">线程包括哪些状态，状态之间是如何变化的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA-T1%E3%80%81T2%E3%80%81T3-%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-number">5.13.</span> <span class="toc-text">新建 T1、T2、T3 三个线程，如何保证线程按顺序执行？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-number">5.14.</span> <span class="toc-text">什么是死锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-number">5.15.</span> <span class="toc-text">如何避免死锁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1%EF%BC%9F"><span class="toc-number">5.16.</span> <span class="toc-text">多线程之间如何进行通信？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">5.17.</span> <span class="toc-text">synchronized关键字的作用?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E5%92%8CLock%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">5.18.</span> <span class="toc-text">synchronized和Lock有什么区别 ?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sleep-%E5%92%8C-wait-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.19.</span> <span class="toc-text">sleep() 和 wait() 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#notify-%E5%92%8C-notifyAll-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.20.</span> <span class="toc-text">notify() 和 notifyAll() 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">5.21.</span> <span class="toc-text">多线程安全问题怎么解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">5.22.</span> <span class="toc-text">volatile关键字的作用?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.23.</span> <span class="toc-text">ThreadLocal是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">5.24.</span> <span class="toc-text">什么是线程池？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">5.25.</span> <span class="toc-text">为什么要使用线程池？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.26.</span> <span class="toc-text">怎样创建线程池?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Executors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.27.</span> <span class="toc-text">通过Executors创建线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87ThreadPoolExecutor%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.28.</span> <span class="toc-text">通过ThreadPoolExecutor创建线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%EF%BC%9F"><span class="toc-number">5.29.</span> <span class="toc-text">线程池的核心参数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">5.30.</span> <span class="toc-text">线程池的执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%83%BD%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">5.31.</span> <span class="toc-text">线程池都有哪几种工作队列？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java-IO%E6%B5%81%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">Java IO流相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E4%B8%AD-IO-%E6%B5%81%E5%88%86%E4%B8%BA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">Java 中 IO 流分为几种？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">字节流和字符流的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BA%94%E7%A7%8D-IO-%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-number">6.3.</span> <span class="toc-text">常见的五种 IO 模型？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BIO%E3%80%81NIO%E3%80%81AIO-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.4.</span> <span class="toc-text">BIO、NIO、AIO 有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">Java反射相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">什么是反射？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">7.2.</span> <span class="toc-text">反射的优缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%AA%E9%87%8C%E7%94%A8%E5%88%B0%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">7.3.</span> <span class="toc-text">哪里用到反射机制？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%BC%82%E5%B8%B8%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">Java异常相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Error%E5%92%8CException%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.1.</span> <span class="toc-text">Error和Exception有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB%EF%BC%9F"><span class="toc-number">8.2.</span> <span class="toc-text">异常的分类？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="toc-number">8.3.</span> <span class="toc-text">怎么处理异常？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-catch-finally-%E5%92%8C-try-with-resources%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">8.4.</span> <span class="toc-text">try-catch-finally 和 try-with-resources的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#throw%E5%92%8Cthrows%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.5.</span> <span class="toc-text">throw和throws的区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E3%80%81finally%E3%80%81finalize%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.6.</span> <span class="toc-text">final、finally、finalize的区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final"><span class="toc-number">8.7.</span> <span class="toc-text">final</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finally"><span class="toc-number">8.8.</span> <span class="toc-text">finally</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finalize"><span class="toc-number">8.9.</span> <span class="toc-text">finalize</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%EF%BC%9F"><span class="toc-number">8.10.</span> <span class="toc-text">如何自定义异常？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%96%B0%E7%89%B9%E6%80%A7%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">9.</span> <span class="toc-text">Java新特性相关面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%9F"><span class="toc-number">9.1.</span> <span class="toc-text">什么是Lambda表达式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95%EF%BC%9F"><span class="toc-number">9.2.</span> <span class="toc-text">Lambda表达式的语法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%EF%BC%9F"><span class="toc-number">9.3.</span> <span class="toc-text">什么是函数式接口？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream%E6%B5%81%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">9.4.</span> <span class="toc-text">Stream流怎么使用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4API%EF%BC%9F"><span class="toc-number">9.5.</span> <span class="toc-text">新日期时间API？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Optional%E7%B1%BB%EF%BC%9F"><span class="toc-number">9.6.</span> <span class="toc-text">Optional类？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/CSS/" title="CSS笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/CSS/CSS.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="CSS笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/CSS/" title="CSS笔记">CSS笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/HTML/" title="HTML笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/HTML/HTML.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="HTML笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/HTML/" title="HTML笔记">HTML笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/JavaScript/" title="JavaScript笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/JavaScript/JavaScript.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="JavaScript笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/JavaScript/" title="JavaScript笔记">JavaScript笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/JavaWeb/" title="JavaWeb笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/JavaWeb/JavaWeb.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="JavaWeb笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/JavaWeb/" title="JavaWeb笔记">JavaWeb笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/Linux/" title="Linux笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/Linux/Linux.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="Linux笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/Linux/" title="Linux笔记">Linux笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By wen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '701b8bc001a40a760558',
      clientSecret: 'a51b436adc471c3949a8f41be05c2d58cccab10a',
      repo: 'Hexo-Butterfly-Comment',
      owner: 'wen53231323',
      admin: ['wen53231323'],
      id: '363edcc1ad1a9356b22e207b3432cb91',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'VI32wmbmMoxvlhpTpoDBNeOk-MdYXbMMI',
      appKey: 'oFstfBFkCQIkjuk4ibCpbGqz',
      avatar: 'monsterid',
      serverURLs: 'https://vi32wmbm.api.lncldglobal.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Gitalk' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/blog/js/search/local-search.js"></script></div></div></body></html>