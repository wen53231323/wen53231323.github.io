<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>面试题-Web开发与常用框架 | 远方の博客</title><meta name="author" content="wen"><meta name="copyright" content="wen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="[TOC] JavaWebB&#x2F;S架构与C&#x2F;S架构是什么? B&#x2F;S架构（Browser&#x2F;Server）B&#x2F;S架构（Browser&#x2F;Server Architecture）是指浏览器&#x2F;服务器架构，也被称为Web架构。在B&#x2F;S架构中，应用程序的前端界面（通常是浏览器）与后端服务器进行交互。  交互流程：在B&#x2F;S架构"><meta property="og:type" content="article"><meta property="og:title" content="面试题-Web开发与常用框架"><meta property="og:url" content="https://w_e_n.gitee.io/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/index.html"><meta property="og:site_name" content="远方の博客"><meta property="og:description" content="[TOC] JavaWebB&#x2F;S架构与C&#x2F;S架构是什么? B&#x2F;S架构（Browser&#x2F;Server）B&#x2F;S架构（Browser&#x2F;Server Architecture）是指浏览器&#x2F;服务器架构，也被称为Web架构。在B&#x2F;S架构中，应用程序的前端界面（通常是浏览器）与后端服务器进行交互。  交互流程：在B&#x2F;S架构"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://w_e_n.gitee.io/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/%E9%9D%A2%E8%AF%95%E9%A2%98.png"><meta property="article:published_time" content="2022-12-31T16:00:00.000Z"><meta property="article:modified_time" content="2023-09-13T17:26:28.332Z"><meta property="article:author" content="wen"><meta property="article:tag" content="面试题"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://w_e_n.gitee.io/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/%E9%9D%A2%E8%AF%95%E9%A2%98.png"><link rel="shortcut icon" href="/blog/img/favicon.png"><link rel="canonical" href="https://w_e_n.gitee.io/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//static.cloudflareinsights.com"><link rel="preconnect" href="//www.clarity.ms"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?[object Object]";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=[object Object]"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","[object Object]")</script><script defer data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;[object Object]&quot;}"></script><script>!function(t,e,c,n,a,r){t[c]=t[c]||function(){(t[c].q=t[c].q||[]).push(arguments)},(a=e.createElement(n)).async=1,a.src="https://www.clarity.ms/tag/[object Object]",(r=e.getElementsByTagName(n)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><script>const GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: {"path":"/blog/search.xml","preload":true,"top_n_per_article":5,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"面试题-Web开发与常用框架",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-09-14 01:26:28"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/img/%E5%A4%B4%E5%83%8F.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/picture/"><i class="fa-fw fas fa-images"></i><span> 图片库</span></a></li><li><a class="site-page child" href="/blog/music/"><i class="fa-fw fas fa-music"></i><span> 音乐库</span></a></li><li><a class="site-page child" href="/blog/movies/"><i class="fa-fw fas fa-video"></i><span> 视频库</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/link/"><span>导航链接</span></a></li><li><a class="site-page child" href="/blog/comment_loading/"><span>评论管理</span></a></li><li><a class="site-page child" href="/blog/custom/"><span>自定义页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/blog/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/%E9%9D%A2%E8%AF%95%E9%A2%98.png)"><nav id="nav"><span id="blog-info"><a href="/blog/" title="远方の博客"><span class="site-name">远方の博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/picture/"><i class="fa-fw fas fa-images"></i><span> 图片库</span></a></li><li><a class="site-page child" href="/blog/music/"><i class="fa-fw fas fa-music"></i><span> 音乐库</span></a></li><li><a class="site-page child" href="/blog/movies/"><i class="fa-fw fas fa-video"></i><span> 视频库</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/link/"><span>导航链接</span></a></li><li><a class="site-page child" href="/blog/comment_loading/"><span>评论管理</span></a></li><li><a class="site-page child" href="/blog/custom/"><span>自定义页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/blog/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试题-Web开发与常用框架</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-13T17:26:28.332Z" title="更新于 2023-09-14 01:26:28">2023-09-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="面试题-Web开发与常用框架"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>[TOC]</p><h1 id="JavaWeb"><a href="#JavaWeb" class="headerlink" title="JavaWeb"></a>JavaWeb</h1><h2 id="B-x2F-S架构与C-x2F-S架构是什么"><a href="#B-x2F-S架构与C-x2F-S架构是什么" class="headerlink" title="B&#x2F;S架构与C&#x2F;S架构是什么?"></a>B&#x2F;S架构与C&#x2F;S架构是什么?</h2><blockquote><h3 id="B-x2F-S架构（Browser-x2F-Server）"><a href="#B-x2F-S架构（Browser-x2F-Server）" class="headerlink" title="B&#x2F;S架构（Browser&#x2F;Server）"></a>B&#x2F;S架构（Browser&#x2F;Server）</h3><p>B&#x2F;S架构（Browser&#x2F;Server Architecture）是指浏览器&#x2F;服务器架构，也被称为Web架构。在B&#x2F;S架构中，应用程序的前端界面（通常是浏览器）与后端服务器进行交互。</p><ul><li><p><strong>交互流程</strong>：在B&#x2F;S架构中，前端界面是通过浏览器上的Web页面来呈现给用户，通常使用HTML、CSS和JavaScript等技术来实现。用户通过浏览器发送请求（如点击链接、填写表单等），请求会被发送到服务器端进行处理。服务器端进行相应的业务逻辑处理，并返回数据或页面给浏览器，浏览器再将这些数据或页面展示给用户。</p></li><li><p><strong>适应场景</strong>：B&#x2F;S架构适用于跨平台和分布式环境，因为它只需要一个浏览器作为客户端界面，不需要安装额外的客户端软件</p></li><li><p><strong>示例应用</strong>：常见的网站和在线应用一般采用B&#x2F;S架构，如电子商务网站、新闻网站等</p></li></ul><h3 id="C-x2F-S架构（Client-x2F-Server）"><a href="#C-x2F-S架构（Client-x2F-Server）" class="headerlink" title="C&#x2F;S架构（Client&#x2F;Server）"></a>C&#x2F;S架构（Client&#x2F;Server）</h3><p>C&#x2F;S架构（Client&#x2F;Server Architecture）是指客户端&#x2F;服务器架构。在C&#x2F;S架构中，应用程序被分为客户端和服务器两个部分。</p><ul><li><strong>交互流程</strong>：在C&#x2F;S架构中，客户端是安装在用户本地的软件，负责用户界面的显示和用户交互，用户可以在客户端上进行各种操作，客户端会将这些操作转换为请求，发送给服务器。服务器则负责接收客户端的请求，进行相应的处理，并返回结果给客户端。</li><li><strong>适应场景</strong>：客户端软件需要在各个平台上进行开发和维护，适用于对性能和用户体验要求较高的应用场景。</li><li><strong>示例应用</strong>： 桌面应用程序和移动应用程序采用C&#x2F;S架构，如QQ、迅雷等APP。</li></ul></blockquote><h2 id="MVC是什么？"><a href="#MVC是什么？" class="headerlink" title="MVC是什么？"></a>MVC是什么？</h2><blockquote><p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分</p><ul><li><strong>模型（Model）</strong>：模型表示应用程序的数据和业务逻辑</li><li><strong>视图（View）</strong>：视图负责展示模型中的数据给用户，并接受用户的输入</li><li><strong>控制器（Controller）</strong>：控制器作为模型和视图之间的中介，处理用户的请求并协调模型和视图的交互</li></ul></blockquote><h2 id="在浏览器输入网址后请求的过程？"><a href="#在浏览器输入网址后请求的过程？" class="headerlink" title="在浏览器输入网址后请求的过程？"></a>在浏览器输入网址后请求的过程？</h2><blockquote><p>在浏览器输入一个网址后，以下是请求的一般过程：</p><ol><li><strong>DNS解析</strong>：浏览器首先会解析输入的网址中的域名部分，将域名解析为对应的IP地址。浏览器会向本地DNS服务器发送查询请求，如果本地DNS服务器没有缓存该域名对应的IP地址，则会向根DNS服务器逐级查询，最终获取到目标服务器的IP地址。</li><li><strong>建立TCP连接</strong>：浏览器使用HTTP协议与目标服务器建立TCP连接。TCP连接的建立需要进行”三次握手”，即客户端向服务器发送连接请求，服务器回复确认连接请求，最后客户端再次回复确认。</li><li><strong>向服务器发起HTTP请求</strong>：建立TCP连接后，浏览器会构建HTTP请求报文，包括请求行、请求头和请求体等信息。请求行中包含了请求方法（GET、POST等）、请求URL和协议版本等。请求头中包含了一些附加的信息，如Cookie、Referer、User-Agent等。请求体中通常包含了一些表单数据或上传的文件等内容。</li><li><strong>服务器处理请求</strong>：目标服务器接收到浏览器发送的HTTP请求后，会进行请求的处理。服务器根据请求的URL找到对应的资源（如静态文件或动态程序），执行相应的操作。这可能涉及到数据库查询、业务逻辑处理等。</li><li><strong>服务器发送HTTP响应</strong>：服务器处理完请求后，会生成HTTP响应报文，包括响应行、响应头和响应体等信息。响应行中包含了响应状态码（如200表示成功、404表示资源未找到等）和协议版本等。响应头中包含了一些附加的信息，如响应的内容类型、长度、缓存策略等。响应体中包含了服务器返回给浏览器的数据或页面内容。</li><li><strong>接收响应并渲染页面</strong>：浏览器接收到服务器发送的HTTP响应后，会根据响应的内容进行页面渲染。如果响应是一个HTML页面，浏览器会解析HTML代码，并加载其中引用的其他资源（如CSS、JavaScript文件等）。最终，浏览器将页面展示给用户。</li><li><strong>关闭TCP连接</strong>：当页面全部加载完成后，浏览器会关闭与服务器的TCP连接，释放资源。在后续的操作中，如果需要再次请求同一服务器的资源，浏览器会重新建立TCP连接。</li></ol></blockquote><h2 id="MVC工作流程是什么？"><a href="#MVC工作流程是什么？" class="headerlink" title="MVC工作流程是什么？"></a>MVC工作流程是什么？</h2><blockquote><p>MVC（Model-View-Controller）的工作流程如下：</p><ol><li><strong>用户发送请求</strong>：用户在浏览器中输入URL或者与应用程序进行交互，发送请求给服务器。</li><li><strong>控制器接收请求</strong>：服务器接收到请求后，控制器（通常是一个Servlet）负责接收并处理请求。控制器根据请求的类型和参数，选择合适的处理方法。</li><li><strong>模型处理请求</strong>：控制器根据请求的类型和参数，调用相应的模型来处理数据。模型负责处理业务逻辑，包括数据的获取、处理、验证、存储等操作。</li><li><strong>视图展示数据</strong>：模型处理完数据之后，将处理结果返回给控制器。控制器根据处理结果选择适当的视图来展示数据。视图负责将数据渲染成可视化的界面供用户查看。</li><li><strong>用户与视图交互</strong>：用户在浏览器中与视图进行交互，例如填写表单、点击按钮等。用户的操作可能会触发新的请求。</li></ol><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/MVC工作流程.png" style="zoom:50%"></blockquote><h2 id="HTTP请求方式？"><a href="#HTTP请求方式？" class="headerlink" title="HTTP请求方式？"></a>HTTP请求方式？</h2><blockquote><p>最常见的有四种：</p><ul><li><strong>GET</strong>：用于获取资源。</li><li><strong>POST</strong>：用于新增或更新资源。</li><li><strong>PUT</strong>：用于更新资源。</li><li><strong>DELETE</strong>：用于删除资源。</li></ul></blockquote><h2 id="HTTP常见响应码有哪些"><a href="#HTTP常见响应码有哪些" class="headerlink" title="HTTP常见响应码有哪些?"></a>HTTP常见响应码有哪些?</h2><blockquote><p>响应成功（200）、未找到（404）、客户端请求错误（400）、服务器内部错误（500）</p><ul><li><strong>信息类（1XX）</strong>：表示收到 http 请求，正在进行下一步处理，通常是一种瞬间的响应状态</li><li><strong>成功类（2XX）</strong>：表示用户请求被正确接收、理解和处理</li><li><strong>重定向类（3XX）</strong>：表示没有请求成功，必须采取进一步的动作</li><li><strong>客户端错误（4XX）</strong>：表示客户端提交的请求包含语法错误或不能正确执行</li><li><strong>服务端错误（5XX）</strong>：表示服务器不能正确执行一个正确的请求</li></ul></blockquote><h2 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别?"></a>GET和POST的区别?</h2><blockquote><p>GET和POST是HTTP协议中最常用的两种请求方法，它们之间有以下区别：</p><ul><li><strong>用途不同</strong>：GET一般用来获取数据，POST一般用来添加或修改数据</li><li><strong>参数传递方式</strong>：GET请求将参数放在URL的后面，而POST请求则将参数放在请求体中。</li><li><strong>请求的安全性</strong>：由于GET方法直接暴露参数在URL中，安全性低；POST方法则将数据放在请求体中，相对更为安全</li><li><strong>请求长度限制</strong>：GET请求的参数长度有限制，具体根据浏览器和Web服务器的不同而不同，通常为2048字节。而POST请求的传输数据量没有限制。</li></ul></blockquote><h2 id="POST和PUT的区别？"><a href="#POST和PUT的区别？" class="headerlink" title="POST和PUT的区别？"></a>POST和PUT的区别？</h2><blockquote><p>POST和PUT都是HTTP协议中常用的请求方法，它们之间的主要区别有以下几点：</p><ul><li><strong>用途不同</strong>：POST一般用来添加或修改数据；PUT用于更新数据</li><li><strong>覆盖请求</strong>：POST不具备幂等性，每个请求都是独立的，多次调用相同的POST请求可能会创建多个相同的资源；PUT请求具备幂等性，多次调用相同的PUT请求只会对资源进行一次更新。</li></ul></blockquote><h2 id="Session与Cookie的区别？"><a href="#Session与Cookie的区别？" class="headerlink" title="Session与Cookie的区别？"></a>Session与Cookie的区别？</h2><blockquote><p>Session与Cookie是两种用来在Web应用中保持状态的机制。</p><ul><li><strong>存储方式</strong>：Cookie的value只能存储字符串类型的数据，而Session的value可以存储任意类型的数据，包括对象和数组等复杂数据结构。</li><li><strong>存储位置</strong>：Cookie的数据存储在客户端。Session的数据存储在服务端</li><li><strong>安全性</strong>：Cookie在客户端容易受到窃取、截获和修改的风险，不安全；Session对客户端是不可见的，因此相对更安全一些。</li><li><strong>数据大小</strong>：Cookie的存储大小受到浏览器的限制，一般情况下最大只能存储约3KB的数据，而Session的数据存储大小受服务端内存的限制，一般没有明确的大小限制。</li><li><strong>销毁时机</strong>：Cookie的生命周期是当浏览器关闭的时候就消亡了，Session默认生命周期一般是30分钟，可以根据需要在服务器端进行配置。</li></ul></blockquote><h2 id="转发与重定向的区别？"><a href="#转发与重定向的区别？" class="headerlink" title="转发与重定向的区别？"></a>转发与重定向的区别？</h2><blockquote><p>转发（Forwarding）和重定向（Redirect）是两种不同的HTTP请求处理机制，区别如下：</p><ol><li><strong>请求次数</strong>：转发只涉及一次请求，服务器接收到请求后直接将请求转发给其他资源进行处理；而重定向涉及两次请求，服务器接收到请求后返回特殊响应，告诉客户端去请求新的URL。</li><li><strong>浏览器地址栏显示</strong>：转发时，浏览器地址栏仍然显示的是初始请求的URL；而重定向时，浏览器地址栏会显示新的URL。</li><li><strong>完成过程</strong>：转发是在服务器端完成的，客户端不知道有转发的存在；而重定向是在浏览器端完成的，服务器告诉客户端去请求新的URL。</li></ol></blockquote><h2 id="Tomcat是什么？"><a href="#Tomcat是什么？" class="headerlink" title="Tomcat是什么？"></a>Tomcat是什么？</h2><blockquote><p>Tomcat（全名为Apache Tomcat）是一个开源的、轻量级的Web应用服务器，由Apache软件基金会开发和维护。</p></blockquote><h2 id="Tomcat有什么特点"><a href="#Tomcat有什么特点" class="headerlink" title="Tomcat有什么特点?"></a>Tomcat有什么特点?</h2><blockquote><p>Tomcat具有以下几个主要特点：</p><ol><li><strong>轻量级</strong>：Tomcat是一个相对轻量级的Servlet容器，它具有较小的内存占用和快速启动的特点。由于其设计简单，它在资源消耗方面比一些其他大型JavaEE服务器（如WebLogic、WebSphere）更加节省。</li><li><strong>独立性</strong>：Tomcat是一个独立的服务，可以独立于其他Web服务器（如Apache HTTP Server）运行。它可以作为独立的Servlet容器使用，也可以与其他Web服务器配合使用，通过反向代理或负载均衡实现更复杂的部署架构。</li><li><strong>开源性</strong>：Tomcat是一个开源项目，代码完全公开，并且遵循Apache许可证。这意味着任何人都可以查看、使用和修改Tomcat的源代码，可以根据自己的需求进行定制和扩展，使得它具有较好的灵活性和可定制性。</li><li><strong>可扩展性</strong>：Tomcat提供了可插拔的架构，允许用户通过添加或配置插件（例如Valve、Realm、Servlet等）来扩展其功能。这使得开发人员可以根据需要增加新的功能组件，或者替换默认的组件实现，以满足特定的需求。</li><li><strong>易用性</strong>：Tomcat提供了一个简单易用的管理界面（Tomcat Manager），可以通过该界面对Web应用程序进行部署、启停和监控。它还支持热部署特性，在不重启服务器的情况下更新Web应用程序，方便开发和调试。无论是小型的个人网站还是大型的企业级应用，都可以选择Tomcat作为其运行环境。同时，许多Java Web框架都默认支持Tomcat，使得开发人员更容易上手和开发应用程序。</li><li><strong>多协议支持</strong>：Tomcat不仅支持HTTP协议，还支持其他常用的网络协议，如HTTPS、AJP（Apache JServ Protocol）等。这使得Tomcat可以与其他应用程序和Web服务器进行协同工作，提供更灵活的部署方式。</li><li><strong>多线程支持</strong>：Tomcat使用多线程技术来处理并发请求，提高系统的并发性能。它为每个请求创建一个独立的线程，这样可以同时处理多个请求，提升Web应用程序的吞吐量。</li><li><strong>安全性支持</strong>：Tomcat提供了多种安全措施，例如基于角色的访问控制、SSL&#x2F;TLS加密等。它通过配置文件和管理界面来管理用户认证、授权和安全设置，以确保Web应用程序的安全性。</li><li><strong>JSP支持</strong>：Tomcat还支持JavaServer Pages（JSP）技术。JSP是用于创建动态Web页面的Java标准，可以在其中嵌入Java代码和HTML标记。Tomcat可以编译和执行JSP页面，将其转化为Servlet并进行处理，从而生成最终的HTML响应。</li><li><strong>Java WebSocket支持</strong>：Tomcat对Java WebSocket API提供了支持，可以加载和执行WebSocket相关的类和方法，从而实现WebSocket通信功能。开发人员可以使用Tomcat来构建实时的双向通信应用程序。</li><li><strong>Servlet容器</strong>：Tomcat作为一个Servlet容器，它能够加载、实例化和管理Servlet组件。它接收来自客户端的HTTP请求，并将请求转发给相应的Servlet进行处理，然后将处理结果返回给客户端。Tomcat负责管理Servlet的生命周期、线程处理和请求-响应的过程。</li></ol></blockquote><h2 id="Tomcat有什么作用？"><a href="#Tomcat有什么作用？" class="headerlink" title="Tomcat有什么作用？"></a>Tomcat有什么作用？</h2><blockquote><p>Tomcat作为一个Servlet容器，在Java Web开发中具有以下主要作用：</p><ol><li><strong>提供Servlet容器环境</strong>：Tomcat是一个Servlet容器，遵循Java Servlet规范，能够运行Java编写的Servlet代码。</li><li><strong>提供Servlet管理</strong>：Tomcat可以管理和处理Servlet的生命周期，包括初始化、加载、调用和销毁。</li><li><strong>提供连接池管理</strong>：Tomcat可以管理数据库连接池，提供了一组API和配置选项，用于管理数据库连接的创建、复用和回收，从而提高数据库访问的效率和性能。</li><li><strong>URL映射</strong>：Tomcat接收来自客户端的HTTP请求，URL映射将客户端请求转发给相应的Servlet进行处理。这样，开发人员可以根据URL的不同将请求分发到不同的Servlet，实现灵活的请求处理机制。</li><li><strong>运行JSP页面</strong>：Tomcat内置了JSP引擎，可以将JSP页面编译成Servlet，并在运行时动态地生成HTML响应。开发人员可以使用JSP编写动态的Web页面，通过Tomcat来解析和执行这些JSP页面。</li><li><strong>处理静态资源</strong>：除了动态生成的Servlet和JSP页面，Web应用程序还可能包含静态资源，如HTML、CSS、JavaScript、图片等。Tomcat可以直接处理这些静态资源的访问，并将其发送给客户端，无需额外的配置或处理。</li><li><strong>Web应用部署</strong>：Tomcat提供了一个简单易用的管理界面（Tomcat Manager），允许用户对Web应用程序进行部署、启停和监控。开发人员可以通过Tomcat Manager来管理多个Web应用程序，进行版本管理和灰度发布等操作。</li></ol></blockquote><h2 id="Servlet是什么？"><a href="#Servlet是什么？" class="headerlink" title="Servlet是什么？"></a>Servlet是什么？</h2><blockquote><p>Servlet在Java Web开发中扮演着重要的角色，是一种用于在Web服务器上运行的Java程序组件</p><ul><li><strong>狭义Servlet</strong>：指Java语言中的javax.servlet.Servlet接口，这个接口定义了处理客户端请求和生成响应的方法</li><li><strong>广义Servlet</strong>：指任何实现了javax.servlet.Servlet接口的类，包括通过实现该接口或继承已有实现的类来创建的Servlet类。</li></ul><p>Servlet运行在服务器端，主要作用是使用Java语言与Servlet容器（如Tomcat）进行交互，处理Web请求和生成Web响应。</p><ol><li><strong>处理Web请求</strong>：Servlet可以接收来自客户端的HTTP请求，并根据请求的内容进行相应的处理。它可以读取请求参数、处理表单数据、解析请求头等。通过编写Servlet类，开发者可以定义自己的业务逻辑来处理不同类型的请求。</li><li><strong>生成Web响应</strong>：Servlet可以根据业务逻辑和请求内容动态生成HTTP响应。它可以生成HTML页面、JSON数据、XML文档等各种形式的响应内容。开发者可以通过设置响应状态码、头信息和内容体等来构建合适的响应，以满足客户端的需求。</li></ol></blockquote><h2 id="Servlet容器是什么？"><a href="#Servlet容器是什么？" class="headerlink" title="Servlet容器是什么？"></a>Servlet容器是什么？</h2><blockquote><ol><li>Servlet是一种用于在Web服务器上基于Java语言编写的服务器端程序，本身不能独立运行，需要在支持Servlet规范的容器中才能被加载和执行</li><li>Servlet容器，也称为Web容器或Servlet引擎，提供了运行和管理Servlet的环境，可以加载和执行Java编写的Servlet代码</li><li>常见的Servlet容器有Apache Tomcat、Jetty、IBM WebSphere和Oracle WebLogic等。这些容器实现了Servlet规范，可以加载和执行Java编写的Servlet代码</li></ol></blockquote><h2 id="为什么将Tomcat称为Servlet容器？"><a href="#为什么将Tomcat称为Servlet容器？" class="headerlink" title="为什么将Tomcat称为Servlet容器？"></a>为什么将Tomcat称为Servlet容器？</h2><blockquote><p>Tomcat被称为Servlet容器，是因为它是支持Java Servlet规范的Web服务器，提供了运行Servlet代码的环境，能够管理Servlet的生命周期，包括初始化、加载、调用和销毁。</p></blockquote><h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><blockquote><p>Servlet生命周期指的是Servlet对象从创建到销毁的整个过程，它由Servlet容器来管理。</p><ol><li>加载和实例化：当Servlet容器启动或者在首次请求到达时，会加载Servlet类的字节码文件，并实例化Servlet对象将其保存在内存中，以便后续使用。</li><li>初始化：在Servlet实例化后，Servlet容器会调用Servlet的<code>init()</code>方法进行初始化操作。在init()方法中，可以进行一些必要的准备工作，如读取配置文件、建立数据库连接等。<code>init()方法在Servlet的生命周期中只会被调用一次</code>。</li><li>服务：一旦Servlet初始化完成，就可以接收客户端的请求了，每当有请求到达时，Servlet容器会创建一个新的线程，并在该线程上调用Servlet的<code>service()</code>方法，service()方法会根据请求的类型（GET、POST等）调用相应的doGet()、doPost()等方法来处理具体的业务逻辑。<code>service()方法在Servlet的生命周期中每次客户端发送请求都会调用</code></li><li>销毁：当Servlet容器关闭或者Web应用程序被卸载时，会触发Servlet的销毁过程，此时，Servlet容器会调用Servlet的<code>destroy()</code>方法来销毁Servlet实例。在destroy()方法中，可以进行一些清理工作，如释放资源、关闭数据库连接等。<code>destroy()方法在Servlet的生命周期中只会被调用一次</code>。</li></ol></blockquote><h2 id="JavaWeb三大组件是什么"><a href="#JavaWeb三大组件是什么" class="headerlink" title="JavaWeb三大组件是什么?"></a>JavaWeb三大组件是什么?</h2><blockquote><p>JavaWeb 的三大组件分别是Servlet程序、Filter过滤器、Listener 监听器</p><ul><li><strong>Servlet 程序</strong>：Servlet 是在服务器端运行的 Java 类，用于接收客户端的请求并生成响应。</li><li><strong>Filter 过滤器</strong>：Filter 是用于对请求和响应进行预处理和后处理的组件。</li><li><strong>Listener 监听器</strong>：Listener 是用于监听 Web 应用中事件发生的组件。</li></ul></blockquote><h2 id="Filter是什么"><a href="#Filter是什么" class="headerlink" title="Filter是什么?"></a>Filter是什么?</h2><blockquote><p>过滤器（Filter）用于对请求和响应进行预处理和后处理。当客户端发送请求时，过滤器会先执行，然后再将请求传递给目标Servlet进行处理。同样，在目标Servlet处理完请求后，过滤器还可以对响应进行处理，最后将响应返回给客户端。</p></blockquote><h2 id="Listener是什么"><a href="#Listener是什么" class="headerlink" title="Listener是什么?"></a>Listener是什么?</h2><blockquote><p>Listener监听器用于监听Web应用中的事件，并在事件发生时执行相应的操作。它实现了一种观察者模式，用于观察和响应特定的事件。</p></blockquote><h2 id="三层架构是什么？"><a href="#三层架构是什么？" class="headerlink" title="三层架构是什么？"></a>三层架构是什么？</h2><blockquote><p>三层架构是一种软件设计模式，将应用程序按照功能和责任划分为三个独立的层次，每个层次都有自己的职责和功能，且彼此之间独立操作，提高了系统的可维护性、可扩展性和可测试性。通常由以下三个层级组成：</p><ul><li><strong>表示层（Presentation Layer）</strong>：表示层是系统与用户进行交互的界面部分，包括用户界面（如Web页面、移动应用界面、桌面应用界面等）和用户输入处理逻辑。主要作用是<code>将用户的请求传递给业务逻辑层，并将处理结果展示给用户</code></li><li><strong>业务逻辑层（Business Logic Layer）</strong>：业务逻辑层是应用程序的核心部分，包含了应用程序的业务规则、算法、流程等。主要作用是<code>处理来自表示层的请求，调用数据访问层提供的数据实现系统的业务逻辑</code></li><li><strong>数据访问层（Data Access Layer）</strong>：数据访问层是与数据存储系统（如数据库或文件系统）交互的部分，包括数据的存储、检索、更新等操作。主要作用是<code>与数据存储系统（如数据库或文件系统）交互进行交互，执行对数据的增删改查等操作，并将操作结果返回给业务逻辑层</code>。</li></ul></blockquote><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Linux常用命令？"><a href="#Linux常用命令？" class="headerlink" title="Linux常用命令？"></a>Linux常用命令？</h2><blockquote><ol><li><code>ls</code>：列出当前目录下的文件和子目录。</li><li><code>cd</code>：切换当前工作目录。</li><li><code>pwd</code>：显示当前工作目录的路径。</li><li><code>mkdir</code>：创建新目录。</li><li><code>rm</code>：删除文件或目录。</li><li><code>cp</code>：复制文件或目录。</li><li><code>mv</code>：移动文件或目录，或重命名文件或目录。</li><li><code>cat</code>：显示文件内容。</li><li><code>ps</code>：显示当前运行的进程。</li><li><code>kill</code>：终止进程。</li><li><code>chmod</code>：修改文件或目录的权限。</li><li><code>reboot</code>：重新启动系统。</li><li><code>ping</code>：向指定的目标发送网络数据包以测试连接。</li><li><code>ifconfig</code>：显示和配置网络接口。</li><li><code>wget</code>：从网络下载文件。</li></ol></blockquote><h2 id="Linux怎么看进程号"><a href="#Linux怎么看进程号" class="headerlink" title="Linux怎么看进程号?"></a>Linux怎么看进程号?</h2><blockquote><p><code>ps</code>命令：<code>ps</code>命令用于列出当前正在运行的进程信息。可以使用不同的选项来获取所需的输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以全格式显示所有进程信息，包括进程号（PID）</span></span><br><span class="line">ps aux</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">以全格式显示所有进程信息，包括进程号（PID）</span></span><br><span class="line">ps -ef</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有正在运行的进程，仅显示进程号（PID）</span></span><br><span class="line">ps -e</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">仅显示进程号（PID）和命令</span></span><br><span class="line">ps -eo pid,cmd</span><br></pre></td></tr></table></figure><p><code>top</code>命令：<code>top</code>命令用于实时查看系统资源占用情况，并且可以显示进程号（PID）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">实时查看系统资源占用情况</span></span><br><span class="line">top</span><br></pre></td></tr></table></figure><p><code>pgrep</code>命令：<code>pgrep</code>命令用于根据进程的名称查找相应的进程号（PID）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据进程名查找对应的进程号（PID）</span></span><br><span class="line">pgrep firefox</span><br></pre></td></tr></table></figure></blockquote><h2 id="Linux怎样给文件授权"><a href="#Linux怎样给文件授权" class="headerlink" title="Linux怎样给文件授权?"></a>Linux怎样给文件授权?</h2><blockquote><p>在Linux中，可以使用<code>chmod</code>命令来给文件或目录设置权限。</p><ul><li><p><strong>符号模式</strong>：每个字符代表一类用户（所有者、群组、其他用户）以及权限类型（读取、写入、执行）。所有者（u）、群组（g）、其他用户（o）、所有用户权限（a，相当于u+g+o）、添加（+）、移除（-）、设置（&#x3D;）</p></li><li><p><strong>数字模式</strong>：数字模式是使用数字来表示权限的方式。每个数字代表一类用户以及对应的权限。每个用户类别的权限可以通过将其对应的数值相加得到。其中4表示读权限、2表示写权限、1表示执行权限。而0表示没有任何权限。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给文件file.txt的所有者添加读、写、执行权限。</span></span><br><span class="line">chmod u+rwx 文件</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给文件设置权限为：所有者 具有 读、写、执行 权限（7）， 群组和其他用户 具有 读、执行 权限（5）</span></span><br><span class="line">chmod 755 文件</span><br></pre></td></tr></table></figure></blockquote><h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="Mybatis是什么？"><a href="#Mybatis是什么？" class="headerlink" title="Mybatis是什么？"></a>Mybatis是什么？</h2><blockquote><p>Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，加载驱动、创建连接、创建statement等繁杂的过程，开发者开发时只需要关注如何编写SQL语句，可以严格控制sql执行性能，灵活度高。</p></blockquote><h2 id="Mybatis的-和-区别？"><a href="#Mybatis的-和-区别？" class="headerlink" title="Mybatis的${}和#{}区别？"></a>Mybatis的${}和#{}区别？</h2><blockquote><p><code>$&#123;&#125;</code>：字符串拼接，存在SQL注入的风险。</p><p><code>#&#123;&#125;</code>：标记占位符，可以防止SQL注入攻击。</p></blockquote><h2 id="Mybatis常用标签？"><a href="#Mybatis常用标签？" class="headerlink" title="Mybatis常用标签？"></a>Mybatis常用标签？</h2><blockquote><p>MyBatis是一个Java持久化框架，提供了许多用于编写SQL映射的标签。以下是MyBatis中常用的一些标签：</p><ol><li><code>&lt;select&gt;</code>：用于执行查询操作的标签。</li><li><code>&lt;insert&gt;</code>：用于执行插入操作的标签。</li><li><code>&lt;update&gt;</code>：用于执行更新操作的标签。</li><li><code>&lt;delete&gt;</code>：用于执行删除操作的标签。</li><li><code>&lt;resultMap&gt;</code>：定义结果集的映射关系的标签。</li><li><code>&lt;association&gt;</code>：用于处理一对一关联关系的标签。</li><li><code>&lt;collection&gt;</code>：用于处理一对多或多对多关联关系的标签。</li><li><code>&lt;if&gt;</code>：条件判断标签，根据条件动态生成SQL。</li><li><code>&lt;choose&gt;</code>、<code>&lt;when&gt;</code>、<code>&lt;otherwise&gt;</code>：条件选择标签，根据多个条件选择不同的分支。</li><li><code>&lt;foreach&gt;</code>：用于循环遍历集合或数组，并在SQL语句中使用遍历的元素。</li><li><code>&lt;trim&gt;</code>、<code>&lt;where&gt;</code>、<code>&lt;set&gt;</code>：用于处理动态SQL的标签，可以去除多余的空格和逗号。</li><li><code>&lt;include&gt;</code>：用于将其他XML文件中定义的SQL片段包含进来，实现代码复用。</li><li><code>&lt;sql&gt;</code>：用于定义可重用的SQL片段的标签。</li></ol></blockquote><h2 id="ResultType和ResultMap的区别？"><a href="#ResultType和ResultMap的区别？" class="headerlink" title="ResultType和ResultMap的区别？"></a>ResultType和ResultMap的区别？</h2><blockquote><p><code>resultType</code>：用于指定查询结果的返回类型</p><p><code>resultMap</code>：用于定义复杂的对象映射关系。</p></blockquote><h2 id="Mybatis是如何实现分页的？"><a href="#Mybatis是如何实现分页的？" class="headerlink" title="Mybatis是如何实现分页的？"></a>Mybatis是如何实现分页的？</h2><blockquote><p><strong>使用数据库方言</strong>：例如使用MySQL中的<code>limit</code>关键字，在配置文件里面直接写分页SQL</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span>&gt;</span></span><br><span class="line">    SELECT * FROM user_table LIMIT #&#123;offset&#125;, #&#123;limit&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>使用 RowBounds 类</strong>：使用Mybatis提供的RowBounds对象，实现逻辑分页，也就是一次性加载所有符合查询条件的目标数据，根据分页参数值在内存中实现分页。这种方式不适合数据量较大的场景，而且有可能会频繁访问数据库造成比较大的压力</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// offset 表示起始行，limit 表示返回的行数</span></span><br><span class="line"><span class="type">RowBounds</span> <span class="variable">rowBounds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RowBounds</span>(offset, limit);  </span><br><span class="line">List&lt;User&gt; userList = sqlSession.selectList(<span class="string">&quot;getUserList&quot;</span>, <span class="literal">null</span>, rowBounds);</span><br></pre></td></tr></table></figure><p><strong>Interceptor拦截器实现</strong>：通过拦截需要分页的select语句，然后在这个sql语句里面动态拼接分页关键字，从而实现分页查询。</p><p><strong>使用插件</strong>：PageHelper是一个第三方实现的分页拦截器插件，使用起来灵活且方便。本质上也是使用Mybatis的拦截器来实现的。</p></blockquote><h2 id="Mybatis中物理分页（数据库分页）与逻辑分页（内存分页）"><a href="#Mybatis中物理分页（数据库分页）与逻辑分页（内存分页）" class="headerlink" title="Mybatis中物理分页（数据库分页）与逻辑分页（内存分页）"></a>Mybatis中物理分页（数据库分页）与逻辑分页（内存分页）</h2><blockquote><p><strong>物理分页（数据库分页）</strong>：使用SQL语句实现的分页，直接使用<code>limit</code>关键字实现的分页查询。PageHelper分页插件通过拼接 limit 实现，属于物理分页。MP的分页插件 PaginationInterceptor 通过拼接 limit 实现，属于物理分页</p><p><strong>逻辑分页（内存分页）</strong>：先查询数据到内存，在内存中进行分页。Mybatis自带的分页方案是通过 RowBounds 实现，属于逻辑分页。</p></blockquote><h2 id="Mybatis的分页插件运行原理？"><a href="#Mybatis的分页插件运行原理？" class="headerlink" title="Mybatis的分页插件运行原理？"></a>Mybatis的分页插件运行原理？</h2><blockquote><p>MyBatis插件的运行是基于JDK 动态代理 + 拦截器链实现，步骤如下</p><ul><li><strong>拦截器拦截SQL</strong>：在执行SQL之前拦截器拦截</li><li><strong>修改SQL加上分页</strong>：在拦截逻辑中，对 SQL 进行修改，添加limit 分页</li><li><strong>执行目标方法</strong>：执行目标方法</li></ul></blockquote><h2 id="Mybatis的执行流程？"><a href="#Mybatis的执行流程？" class="headerlink" title="Mybatis的执行流程？"></a>Mybatis的执行流程？</h2><blockquote><p>MyBatis的执行流程主要包括以下几个步骤：</p><ol><li><strong>加载配置文件</strong>：MyBatis会读取并解析配置文件，其中包含了数据库连接信息、映射关系配置等重要内容。</li><li><strong>创建SqlSessionFactory会话工厂对象</strong>：根据配置文件的内容，MyBatis会创建一个SqlSessionFactory对象，它是MyBatis的主要入口，用于创建SqlSession对象。</li><li><strong>会话工厂创建SqlSession会话对象</strong>：通过SqlSessionFactory打开一个SqlSession对象，SqlSession是与数据库交互的核心接口，可以进行数据库操作。</li><li><strong>创建操作数据库的接口Executor执行器对象</strong>：SqlSession内部通过Executor执行器来实际执行SQL语句，它负责与数据库进行交互，执行SQL并处理结果。</li><li><strong>构建MappedStatement对象封装映射信息</strong>：在执行SQL之前，MyBatis会根据接口方法的映射配置，构建一个MappedStatement对象，其中包含了SQL语句、参数映射、结果映射等信息。</li><li><strong>执行SQL语句</strong>：Executor执行器根据MappedStatement中的配置信息，执行相应的SQL语句，并将查询结果或影响行数返回给调用方。</li><li><strong>封装返回结果</strong>：根据配置的结果映射，MyBatis会将查询结果封装成Java对象或集合，并返回给调用方。</li><li><strong>关闭SqlSession</strong>：在完成数据库操作后，需要手动关闭SqlSession，释放资源。可以通过调用SqlSession的close()方法来关闭。</li></ol></blockquote><h2 id="Mybatis是否支持延迟加载？"><a href="#Mybatis是否支持延迟加载？" class="headerlink" title="Mybatis是否支持延迟加载？"></a>Mybatis是否支持延迟加载？</h2><blockquote><p>MyBatis支持延迟加载（Lazy Loading）的功能。延迟加载是指在访问对象的某个属性时才去加载该属性的数据，而不是一次性将所有关联数据都加载到内存中。</p><p>在MyBatis中，可以通过配置来实现延迟加载。具体的实现方式有两种：</p><p><strong>基于属性配置的延迟加载</strong>：可以在映射文件中对需要延迟加载的属性进行配置。通过在查询语句中使用<code>fetchType=&quot;lazy&quot;</code>或者<code>fetchType=&quot;lazy&quot;</code>来标识延迟加载。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">column</span>=<span class="string">&quot;authorId&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectAuthorById&quot;</span> <span class="attr">fetchType</span>=<span class="string">&quot;lazy&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><strong>基于关联关系的延迟加载</strong>：可以配置一对一、一对多等关联关系，并通过<code>association</code>和<code>collection</code>元素来添加关联属性。通过设置<code>fetchType=&quot;lazy&quot;</code>来实现延迟加载。当访问关联对象时会触发加载。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;author&quot;</span> <span class="attr">column</span>=<span class="string">&quot;authorId&quot;</span> <span class="attr">select</span>=<span class="string">&quot;selectAuthorById&quot;</span> <span class="attr">fetchType</span>=<span class="string">&quot;lazy&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="Mybatis的一级、二级缓存？"><a href="#Mybatis的一级、二级缓存？" class="headerlink" title="Mybatis的一级、二级缓存？"></a>Mybatis的一级、二级缓存？</h2><blockquote><p>默认情况下，MyBatis的二级缓存是基于内存的，但也支持集成第三方缓存框架如Redis、Ehcache等。</p><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><ul><li><p>一级缓存是MyBatis默认开启的，不需要手动配置，作用域是同一个SqlSession。</p></li><li><p>在同一个SqlSession中，如果执行相同的查询操作，MyBatis会首先去检查一级缓存中是否已经存在该查询结果。如果存在则直接从一级缓存中获取结果，而不会再向数据库发送查询请求，从而提高了查询速度。</p></li><li><p>一级缓存底层实际上是在对象中有一个数据结构（HashMap）用于存储缓存数据。不同的sqlSession之间的缓存数据区域（HashMap）是互相不影响的。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取SqlSession对象，用它来执行sql，只需要保持同一个SqlSession对象，MyBatis就会自动启用一级缓存</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取UserMapper接口的代理对象</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper</span> <span class="operator">=</span> sqlSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次查询操作，会从数据库中查询数据，并将结果保存到一级缓存中</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> userMapper.selectUserById(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次查询操作，同一个 SqlSession 中，再次执行相同的查询，会直接从一级缓存获取结果，而不会再向数据库发送查询请求</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> userMapper.selectUserById(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><ul><li><p>二级缓存需要手动配置开启，作用域是同一个命名空间（Mapper接口）下的多个SqlSession之间的共享缓存，不同的命名空间之间的缓存是独立的，同一个命名空间下的多个SqlSession可以共享缓存数据。</p></li><li><p>当执行一个查询语句时，如果启用了二级缓存，MyBatis会首先去检查二级缓存中是否已经存在该查询结果。如果命中缓存，则直接从缓存中获取结果，而不会再向数据库发送查询请求；如果未命中缓存，则执行查询操作，并将结果保存到二级缓存中。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取SqlSession对象，用它来执行sql</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession1</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession2</span> <span class="operator">=</span> sqlSessionFactory.openSession(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取UserMapper的代理实现类对象</span></span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper1</span> <span class="operator">=</span> sqlSession1.getMapper(UserMapper.class);</span><br><span class="line"><span class="type">UserMapper</span> <span class="variable">userMapper2</span> <span class="operator">=</span> sqlSession2.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次查询操作，会从数据库中查询数据，并将结果保存到二级缓存中</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> userMapper1.selectUserById(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次查询操作，不同的 SqlSession 中，再次执行相同的查询，会直接从二级缓存中获取结果，而不会再向数据库发送查询请求</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> userMapper2.selectUserById(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></blockquote><h2 id="MybatisPlus是什么？"><a href="#MybatisPlus是什么？" class="headerlink" title="MybatisPlus是什么？"></a>MybatisPlus是什么？</h2><blockquote><p>MybatisPlus（简称MP）是 Mybatis 的增强工具，在 Mybatis 的基础上封装了更多的功能，简化了开发流程，提高了开发效率。MybatisPlus 提供了许多实用的功能，包括：</p><ol><li><strong>简化的 CRUD 操作</strong>：MybatisPlus 提供了一系列的通用 CRUD 方法，无需编写 SQL 语句，只需定义实体类和 Mapper 接口即可进行数据库的增删改查操作。</li><li><strong>自动注入</strong>：MybatisPlus 可以自动生成实体类的主键策略，如自增、UUID、雪花算法等，并自动注入创建时间、更新时间等字段值。</li><li><strong>自动填充</strong>：MybatisPlus 支持自动填充功能，可以在插入或更新数据时，自动填充一些固定的字段值，如创建人、更新人等。</li><li><strong>分页查询</strong>：MybatisPlus 提供了简单易用的分页查询功能，可以方便地进行分页查询操作。</li><li><strong>条件构造器</strong>：MybatisPlus 提供了强大的条件构造器，可以通过链式调用的方式拼接查询条件，避免手动拼接 SQL 语句带来的问题。</li><li><strong>逻辑删除</strong>：MybatisPlus 支持逻辑删除功能，即在删除数据时，不是真正地删除数据，而是将删除标记设置为一个特定的值，以便后续恢复或查看删除记录。</li><li><strong>乐观锁插件</strong>：MybatisPlus 内置了乐观锁插件，可以实现乐观锁的功能，解决并发更新数据时的数据一致性问题。</li></ol></blockquote><h2 id="MybatisPlus的常用注解？"><a href="#MybatisPlus的常用注解？" class="headerlink" title="MybatisPlus的常用注解？"></a>MybatisPlus的常用注解？</h2><blockquote><p>MybatisPlus 提供了一些常用的注解，用于简化开发过程和增强功能</p><ol><li><strong>@TableName</strong>：用于指定实体类对应的数据库表名，可以在实体类上使用。示例：@TableName(“user”)</li><li><strong>@TableId</strong>：用于指定实体类的主键字段，可以与 @TableName 注解一起使用，也可以单独使用。示例：@TableId(value &#x3D; “id”, type &#x3D; IdType.AUTO)</li><li><strong>@TableField</strong>：用于指定实体类属性与数据库字段的映射关系，可以在实体类的属性上使用。示例：@TableField(“user_name”)</li></ol></blockquote><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么?"></a>Spring是什么?</h2><blockquote><p>Spring一般是指Spring Framework，是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。</p></blockquote><h2 id="Spring包含的模块有哪些？"><a href="#Spring包含的模块有哪些？" class="headerlink" title="Spring包含的模块有哪些？"></a>Spring包含的模块有哪些？</h2><blockquote><p>Spring Framework包含了很多模块，常见的有</p><ol><li><strong>Spring Core（核心）</strong>：提供了 Spring 框架的基本组成部分，包括 IoC（控制反转）和 DI（依赖注入）等功能。</li><li><strong>Spring Context（上下文）</strong>：建立在核心模块之上，为应用程序提供了大量的企业级服务，例如国际化、事件传播、资源加载和声明式事务管理等。</li><li><strong>Spring AOP（面向切面编程）</strong>：通过 AOP 提供了方法拦截和声明式事务管理等能力。</li><li><strong>Spring JDBC（数据库访问）</strong>：提供了简化的 JDBC 操作接口，使得数据库访问更加方便。</li><li><strong>Spring ORM（对象关系映射）</strong>：支持集成流行的 ORM 框架，如 Hibernate、MyBatis 等。</li><li><strong>Spring Web（Web 开发）</strong>：提供了创建 Web 应用程序的功能，包括 Web MVC、RESTful 服务等。</li><li><strong>Spring Test（测试）</strong>：提供了对 Spring 应用程序进行单元测试和集成测试的支持。</li><li><strong>Spring Security（安全）</strong>：用于身份验证和授权等安全相关的功能，帮助保护应用程序的安全性。</li><li><strong>Spring WebFlux（反应式编程）</strong>：基于 Reactor 框架提供了响应式编程模型，支持构建高性能的异步非阻塞 Web 应用程序。</li><li><strong>Spring Data（数据访问）</strong>：简化数据访问层的开发。提供了一种统一的、基于注解的编程模型，以及许多通用的功能和增强特性，使得与各种数据存储技术（如关系型数据库、NoSQL 数据库、搜索引擎等）集成变得更加容易。</li></ol></blockquote><h2 id="IOC是什么？"><a href="#IOC是什么？" class="headerlink" title="IOC是什么？"></a>IOC是什么？</h2><blockquote><p>控制反转IOC（Inversion of Control），是一种设计思想，把对象的创建、赋值、管理的工作都交给代码之外的容器（Spring容器）实现，而不是由自己来创建和管理依赖对象，使资源可以配置和集中管理，降低了使用资源双方的依赖程度（耦合度）</p><ul><li><strong>自己创建和管理对象</strong>：在面向对象编程（OOP）中，对象的创建通常会采用<code>new 类名</code>的方式手动完成，这种方式会使得调用者与被调用者之间的耦合性增加，不利于后期项目的升级和维护</li><li><strong>容器创建和管理对象</strong>：在Spring中，通过在xml配置文件（容器）中使用标签配置对象，将对象的创建、赋值和生命周期的管理等工作全部交给容器来完成，降低组件之间的耦合度，使得应用程序更加灵活、可扩展、易于维护</li></ul></blockquote><h2 id="AOP是什么？"><a href="#AOP是什么？" class="headerlink" title="AOP是什么？"></a>AOP是什么？</h2><blockquote><p>AOP（面向切面编程）是一种编程范式。通过将的代码逻辑封装成切面（Aspect），并在运行时通过动态代理技术将这些切面织入到目标方法中，从而实现<code>不修改源代码的情况下对目标方法进行增强的效果</code>，常见的应用场景有日志记录、事务管理、缓存优化、安全控制、异常处理等。在Spring框架中，提供了JDK动态代理和CGLIB动态代理两种方式来实现AOP（面向切面编程）。具体使用哪种代理方式取决于被代理的对象是否实现了接口。</p><ul><li><strong>JDK动态代理</strong>：<code>如果被代理的对象实现了接口</code>，Spring AOP会使用JDK动态代理来创建代理对象。JDK动态代理是通过反射机制，在运行时动态生成一个实现被代理接口的代理类，并将方法的调用委托给目标对象执行。</li><li><strong>CGLIB动态代理</strong>：<code>如果被代理的对象没有实现接口</code>，Spring AOP会使用CGLIB动态代理来生成一个被代理对象的子类作为代理对象。CGLIB（Code Generation Library）是一个强大的高性能代码生成库，它通过在运行时生成目标类的子类来实现代理。</li><li><strong>AspectJ框架</strong>：除了JDK动态代理和CGLIB动态代理，Spring还支持使用AspectJ框架来实现AOP。AspectJ是一个独立的AOP框架，它使用编译时或者运行时的字节码增强，可以更灵活地实现切面功能。</li></ul></blockquote><h2 id="DI是什么？"><a href="#DI是什么？" class="headerlink" title="DI是什么？"></a>DI是什么？</h2><blockquote><p>依赖注入（Dependency Injection，DI）是控制反转（IOC）技术的实现方式，其核心思想是让容器来负责对象的创建和管理，并在需要使用这些对象时主动将它们注入到目标对象中，注入一个对象时，容器会自动扫描类路径下所有的组件对象，找到与该对象类型匹配的组件对象，并将其自动注入到目标对象中</p></blockquote><h2 id="依赖注入（DI）怎么实现？"><a href="#依赖注入（DI）怎么实现？" class="headerlink" title="依赖注入（DI）怎么实现？"></a>依赖注入（DI）怎么实现？</h2><blockquote><p>在Spring框架中，有三种主要的依赖注入方式：</p><ol><li><strong>构造函数注入</strong>：通过构造函数来注入依赖。在类的构造函数中声明依赖的参数，并在创建对象时传入相应的依赖对象。</li><li><strong>Setter 方法注入</strong>：通过 setter 方法来注入依赖。在类中定义一个 setter 方法，通过该方法设置依赖对象。</li><li><strong>接口注入</strong>：通过对象实现特定接口，在接口中定义注入依赖项的方法，在程序运行时通过接口方法注入依赖项。</li><li><strong>注解注入</strong>：通过注解来注入依赖。在类中使用特定的注解标记依赖对象，并在容器或框架中进行相应的配置，以实现依赖的注入。</li></ol></blockquote><h2 id="自动装配是什么？"><a href="#自动装配是什么？" class="headerlink" title="自动装配是什么？"></a>自动装配是什么？</h2><blockquote><p>自动装配（Autuwiring）是Spring框架中实现依赖注入的一种方式。它可以自动地将需要依赖的对象注入到目标对象中，而无需手动配置每个对象之间的依赖关系。</p></blockquote><h2 id="自动装配怎么实现？"><a href="#自动装配怎么实现？" class="headerlink" title="自动装配怎么实现？"></a>自动装配怎么实现？</h2><blockquote><p>Spring的自动装配可以分为基于XML配置和基于注解两种情况</p><h2 id="基于XML配置"><a href="#基于XML配置" class="headerlink" title="基于XML配置"></a>基于XML配置</h2><p>在XML配置文件中，可以使用<code>&lt;bean&gt;</code>元素来定义Bean，并利用<code>&lt;property&gt;</code>元素或<code>&lt;constructor-arg&gt;</code>元素来指定依赖关系。通过设置<code>autowire</code>属性为”byType”或”byName”，可以实现自动装配。</p><ol><li>不使用自动注入（默认）：当不设置<code>autowire</code>属性或将其设置为默认值时，不会进行自动注入。需要手动在XML配置文件中通过<code>&lt;property&gt;</code>元素或<code>&lt;constructor-arg&gt;</code>元素指定依赖关系。</li><li>根据类型（byType）：通过将<code>autowire</code>属性设置为”byType”，容器会根据依赖类型自动装配。在需要注入的Bean类中，如果存在与依赖类型匹配的Bean，则自动将其注入。</li><li>根据名称（byName）：通过将<code>autowire</code>属性设置为”byName”，容器会根据依赖名称自动装配。在需要注入的Bean类中，如果存在与依赖名称匹配的Bean，则自动将其注入。</li><li>构造器（constructor）：使用构造函数注入依赖关系。通过<code>&lt;constructor-arg&gt;</code>元素在XML配置文件中指定构造函数参数的值或引用。这是一种主动的方式，需要显式地定义构造函数并传递依赖项。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 默认不使用自动注入，需要显式地指定依赖关系。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userRepository&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserRepositoryImpl&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 根据类型注入，通过设置autowire属性为&quot;byType&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 根据名称注入，通过设置autowire属性为&quot;byName&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用构造器注入，通过&lt;constructor-arg&gt;元素指定依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">&quot;userRepository&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="基于注解"><a href="#基于注解" class="headerlink" title="基于注解"></a>基于注解</h2><p>使用注解可以更方便地进行自动装配，减少了大量的XML配置。使用注解实现自动装配时，需要在配置文件中启用注解扫描或者使用<code>@ComponentScan</code>注解来指定扫描的基础包或类。</p><p>在配置文件中启用注解扫描：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.example&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>使用<code>@ComponentScan</code>注解来指定扫描的基础包或类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.example&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="comment">// 配置其他的Bean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用的自动装配注解有：</p><ul><li><code>@Autowired</code>：用于标记需要自动装配的字段、构造器或方法。</li><li><code>@Qualifier</code>：结合<code>@Autowired</code>使用，用于指定具体的Bean名称。</li><li><code>@Resource</code>：类似于<code>@Autowired</code>，但更灵活地支持根据名称或类型进行自动装配。</li><li><code>@Inject</code>：与<code>@Autowired</code>类似，也可以用于自动装配。但是需要注意的是，<code>@Inject</code>是Java规范提供的注解，而<code>@Autowired</code>是Spring框架特有的。</li></ul></blockquote><h2 id="Autowired和-Resouce的区别？"><a href="#Autowired和-Resouce的区别？" class="headerlink" title="@Autowired和@Resouce的区别？"></a>@Autowired和@Resouce的区别？</h2><blockquote><p><code>@Autowired</code> 和 <code>@Resource</code> 都是常见的用于依赖注入的注解</p><ul><li><code>@Autowired</code> ：Spring 框架提供的注解，按照类型进行依赖查找和注入，当多个 Bean 类型匹配时，可以通过 <code>@Qualifier</code> 注解指定具体的 Bean 名称。</li><li><code>@Resource</code> ：JDK 提供的注解，按照名称进行依赖查找和注入，当多个 Bean 名称匹配时，可以通过 <code>name</code> 属性指定具体的 Bean 名称</li></ul></blockquote><h2 id="Bean是什么？"><a href="#Bean是什么？" class="headerlink" title="Bean是什么？"></a>Bean是什么？</h2><blockquote><p>Bean 指由 Spring 容器管理的对象。Spring Bean 提供了一种依赖注入（Dependency Injection）的机制，通过将 Bean 注入到其他对象中，实现了对象之间的解耦。</p></blockquote><h2 id="Bean怎么声明？"><a href="#Bean怎么声明？" class="headerlink" title="Bean怎么声明？"></a>Bean怎么声明？</h2><blockquote><h2 id="XML-配置文件声明-Bean"><a href="#XML-配置文件声明-Bean" class="headerlink" title="XML 配置文件声明 Bean"></a>XML 配置文件声明 Bean</h2><p>在 XML 配置文件中使用 <code>&lt;bean&gt;</code> 标签来声明一个 Bean。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="注解声明-Bean"><a href="#注解声明-Bean" class="headerlink" title="注解声明 Bean"></a>注解声明 Bean</h2><p>在 Spring 4.x 版本之后，可以使用 <code>@Component</code>、<code>@Service</code>、<code>@Controller</code>、<code>@Repository</code> 和 <code>@Configuration</code> 等注解来声明 Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期?"></a>Bean生命周期?</h2><blockquote><p>实例化—&gt;依赖注入（属性赋值）—&gt;前置处理（初始化前的操作）—&gt;初始化—&gt;后置处理（初始化后的操作）—&gt;使用—&gt;销毁</p><ol><li><strong>实例化（Instantiation）</strong>：在这个阶段，Spring 容器根据配置信息创建 Bean 的实例，通常使用构造函数来实例化对象。</li><li><strong>依赖注入（Dependency Injection）</strong>：在实例创建完成后，Spring 容器会通过 setter 方法或构造函数来注入所需的依赖项，即属性赋值。</li><li><strong>前置处理（Post Process Before Initialization）</strong>：在初始化之前，Spring 提供了一些扩展点，可以在 Bean 初始化之前对其进行自定义操作。例如，可以通过实现 <code>BeanPostProcessor</code> 接口来创建前置处理器，以在初始化之前对 Bean 进行自定义修改。</li><li><strong>初始化（Initialization）</strong>：在这个阶段，Spring 容器会对 Bean 进行初始化，包括调用初始化方法和设置其他相应的配置信息。可以通过实现 <code>InitializingBean</code> 接口或在配置文件中指定 init-method 属性来定义初始化方法。</li><li><strong>后置处理（Post Process After Initialization）</strong>：在初始化完成后，Spring 提供了另一个扩展点，可以在 Bean 初始化之后对其进行自定义操作。与前置处理类似，可以通过实现 <code>BeanPostProcessor</code> 接口来创建后置处理器。</li><li><strong>使用（Bean in Use）</strong>：在初始化完成后，Bean 可以被应用程序使用。在这个阶段，Bean 将服务于它所属的对象或应用程序。可以调用 Bean 的方法、访问其属性等。</li><li><strong>销毁（Destroy）</strong>：当应用程序关闭或销毁 Spring 容器时，Spring 容器会触发 Bean 的销毁过程。可以通过实现 <code>DisposableBean</code> 接口或在配置文件中指定 destroy-method 属性来定义销毁方法。</li></ol><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/Spring Bean 生命周期.png" style="zoom:50%"></blockquote><h2 id="Bean的作用域有哪些？"><a href="#Bean的作用域有哪些？" class="headerlink" title="Bean的作用域有哪些？"></a>Bean的作用域有哪些？</h2><blockquote><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes">Spring官方文档</a>介绍的Bean作用域：单例（Singleton）原型（Prototype）、请求（Request）、会话（Session）、应用上下文（Application）、Websocket</p><ol><li><strong>Singleton（单例）</strong>：默认的作用域。在整个应用程序中，只会存在一个 Bean 实例。无论何时都会返回相同的实例引用。</li><li><strong>Prototype（原型）</strong>：每次通过容器获取该 Bean 时，都会创建一个新的实例。因此，每次获取的实例都是独立的。</li><li><strong>Request（请求）</strong>：在每次 HTTP 请求到达时，都会创建一个新的 Bean 实例。该实例仅在当前 HTTP 请求范围内有效，不同请求之间不共享。</li><li><strong>Session（会话）</strong>：在每个用户会话期间只创建一个 Bean 实例。即使是同一用户的不同请求，也会共享同一个 Bean 实例。</li><li><strong>Application（应用上下文）</strong>：在整个 Web 应用程序生命周期中，只会存在一个 Bean 实例。不同 HTTP 请求之间共享同一个 Bean 实例，但不同 Web 应用程序之间不共享。</li><li><strong>Websocket</strong>：在每个 WebSocket 连接期间只创建一个 Bean 实例。即使是同一连接的不同请求，也会共享同一个 Bean 实例。</li></ol></blockquote><h2 id="Bean是线程安全的吗？"><a href="#Bean是线程安全的吗？" class="headerlink" title="Bean是线程安全的吗？"></a>Bean是线程安全的吗？</h2><blockquote><p>Bean是否线程安全取决于Bean的作用域，默认情况下，Bean的作用域是单例作用域，线程不安全。</p><ul><li><strong>单例作用域</strong>：线程不安全。Bean只会创建一个实例，任何实例都共享这个实例。</li><li><strong>原型作用域</strong>：线程安全。每次获取时都会创建一个新的Bean，不同线程获取的实例是独立的，不会共享数据。</li><li><strong>请求作用域</strong>：线程安全。每个请求时创建一个新的实例，不同请求之间的实例不会共享。</li><li><strong>会话作用域</strong>：线程不安全。每个用户会话期间只有一个实例，多个请求共享同一个实例。</li><li><strong>应用上下文作用域</strong>：线程不安全。在整个应用程序生命周期中只有一个实例，多个线程共享同一个实例</li><li><strong>Websocket作用域</strong>：线程不安全。每个 WebSocket 连接期间只有一个实例，多个请求共享同一个实例。</li></ul></blockquote><h2 id="BeanFactory和ApplicationContext有什么区别？"><a href="#BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="BeanFactory和ApplicationContext有什么区别？"></a>BeanFactory和ApplicationContext有什么区别？</h2><blockquote><p>BeanFactory和ApplicationContext都是Spring框架中用于管理和创建Bean对象的接口</p><ul><li><strong>BeanFactory</strong>：Spring的早期接口，称为Spring的Bean工厂，提供了最基本的Bean容器功能，包括Bean的注册、创建、依赖注入和生命周期管理等</li><li><strong>ApplicationContext</strong>：是BeanFactory的扩展，对BeanFactory进行了封装，提供了更多的功能，例如自动装配、AOP支持等。</li></ul></blockquote><h2 id="循环依赖是什么？"><a href="#循环依赖是什么？" class="headerlink" title="循环依赖是什么？"></a>循环依赖是什么？</h2><blockquote><p>循环依赖是指在Spring容器中，两个或两个以上Bean之间相互依赖，形成环形依赖结构的情况。</p></blockquote><h2 id="循环依赖怎么解决？"><a href="#循环依赖怎么解决？" class="headerlink" title="循环依赖怎么解决？"></a>循环依赖怎么解决？</h2><blockquote><p>大部分的循环依赖问题Spring内部会使用三级缓存进行解决。当发现循环依赖时，Spring会尝试通过以下步骤解决：</p><ol><li><strong>创建早期的对象引用</strong>：当一个Bean A依赖于另一个Bean B时，Spring会先创建Bean A的实例，并将其放入三级缓存中。这个实例是一个未完成初始化的早期对象。</li><li><strong>注入早期的对象引用</strong>：接着，Spring会开始创建Bean B，并将早期的Bean A的引用注入到Bean B中，同时将Bean B也放入三级缓存中。</li><li><strong>解析循环依赖</strong>：当Bean B依赖于Bean A的其他属性时，Spring会检测到循环依赖关系，并尝试从三级缓存中获取已经创建的早期对象引用。</li><li><strong>提前暴露Bean引用</strong>：如果在三级缓存中找到了早期对象引用，Spring会将其提前暴露给其他需要引用它的Bean，以解决循环依赖。</li><li><strong>完成Bean的创建</strong>：最后，Spring会继续完成Bean的创建和初始化过程，包括调用初始化方法和设置其他属性等。</li></ol></blockquote><h2 id="三级缓存是什么？"><a href="#三级缓存是什么？" class="headerlink" title="三级缓存是什么？"></a>三级缓存是什么？</h2><blockquote><p>三级缓存是Spring框架中用于解决循环依赖问题的一种机制。创建Bean的时候，优先从一级缓存获取对象，如果没有，就从二级缓存中获取，如果还没有，就尝试从三级缓存获取ObjectFactory来创建对象</p><ul><li><strong>一级缓存</strong>：单例池，缓存已经经历了完整的生命周期，已经初始化完成的Bean对象</li><li><strong>二级缓存</strong>：缓存早期的Bean对象（生命周期还没走完）存储半成品的bean对象</li><li><strong>三级缓存</strong>：缓存ObjectFactory（创建Bean的工厂实例），用来创建某个对象的工厂实例</li></ul></blockquote><h2 id="事务是如何实现的？"><a href="#事务是如何实现的？" class="headerlink" title="事务是如何实现的？"></a>事务是如何实现的？</h2><blockquote><p>Spring提供了两种管理事务的方式：编程式事务和声明式事务</p><ul><li><strong>编程式事务</strong>：通过编写代码，显式地控制事务的开启、执行、提交、回滚以及手动释放资源等，可以灵活地控制事务的范围和行为，适用于对事务控制需求较复杂的场景。</li><li><strong>声明式事务</strong>：通过在XML配置文件中进行事务配置或使用@Transactional注解定义事务规则，将事务管理的责任交给Spring框架来处理，开发者只需要通过配置或注解的方式声明哪些方法需要进行事务管理，而不需要编写额外的代码来处理事务。</li></ul></blockquote><h2 id="编程式事务和声明式事务优缺点？"><a href="#编程式事务和声明式事务优缺点？" class="headerlink" title="编程式事务和声明式事务优缺点？"></a>编程式事务和声明式事务优缺点？</h2><blockquote><p>编程式事务的优缺点：</p><ul><li><strong>优点</strong>：可以灵活控制事务的开启、执行、提交、回滚以及手动释放资源等，实现细粒度的事务控制</li><li><strong>缺点</strong>：代码复杂度高，对代码有侵入性，容易出错</li></ul><p>声明式事务的优缺点：</p><ul><li><strong>优点</strong>：代码简洁、可读性强，配置灵活、易于维护</li><li><strong>缺点</strong>：不够灵活，最小粒度只能作用在方法上，需要注意事务的失效场景</li></ul></blockquote><h2 id="Transactional声明式事务为什么不推荐使用？"><a href="#Transactional声明式事务为什么不推荐使用？" class="headerlink" title="@Transactional声明式事务为什么不推荐使用？"></a>@Transactional声明式事务为什么不推荐使用？</h2><blockquote><p>@Transactional使用不当可能会失效</p><ol><li><strong>只适用于公共方法</strong>：由于声明式事务是基于代理机制实现的，所以只能应用于公共（public）的方法上，而不能应用于私有（private）或受保护（protected）的方法。</li><li><strong>类内部的自调用问题</strong>：在同一个类内部的一个方法自调用时，<code>@Transactional</code>注解可能无法生效。这是因为Spring事务默认是通过代理对象实现的，自调用时不会经过代理对象。</li><li><strong>异常处理</strong>：声明式事务可以通过设置<code>rollbackFor</code>来指定哪些异常会回滚事务，但需要注意未捕获的异常可能无法被事务捕获，从而导致事务无法回滚。</li></ol></blockquote><h2 id="Transactional事务失效的场景有哪些？"><a href="#Transactional事务失效的场景有哪些？" class="headerlink" title="@Transactional事务失效的场景有哪些？"></a>@Transactional事务失效的场景有哪些？</h2><blockquote><p>@Transactional事务失效场景：</p><ul><li><strong>@Transactional 应用在非 public 修饰的方法上</strong>：事务只能被 public 方法拦截，如果将 @Transactional 注解应用在了非 public 方法上，那么该方法不会被事务拦截器拦截，从而导致事务失效。</li><li><strong>非事务方法调用事务方法</strong>：如果一个非事务方法调用了一个带有 @Transactional 注解的事务方法，那么事务将无法生效。</li><li><strong>事务方法内部调用事务方法</strong>：如果一个事务方法调用了另一个带有 @Transactional 注解的事务方法，其中两个方法属于同一个对象，则外层 @Transactional 注解会被忽略，内层的事务方法将以非事务方式执行。这是因为 Spring 默认使用 AOP 基于动态代理实现事务管理，同一对象中的方法调用不会触发代理对象上的拦截器。如果要实现嵌套事务，可以考虑使用基于 AspectJ 的编译时织入。</li><li><strong>异常未被捕获</strong>：如果在事务中的方法抛出了未被捕获的异常，而没有在方法内部进行处理或在上层调用栈中进行捕获和处理，事务将会失效。</li></ul></blockquote><h2 id="Spring-框架中用到了哪些设计模式？"><a href="#Spring-框架中用到了哪些设计模式？" class="headerlink" title="Spring 框架中用到了哪些设计模式？"></a>Spring 框架中用到了哪些设计模式？</h2><blockquote><p>Spring 框架中使用了多种设计模式，以下是其中一些主要的设计模式：</p><ul><li><strong>单例设计模式</strong>：Spring容器默认使用单例模式管理Bean对象，保证整个应用程序中只有一个实例。</li><li><strong>工厂设计模式</strong>：Spring 使用工厂模式创建和管理 Bean 对象。即通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 Bean 对象。</li><li><strong>代理设计模式</strong>：Spring AOP （面向切面编程）基于代理模式实现，使用代理模式在目标方法执行前、执行后或出现异常时插入横切逻辑，实现面向切面编程。</li><li><strong>模板方法模式</strong>：Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，使用到了模板模式。</li><li><strong>观察者模式</strong>：Spring事件驱动模型基于观察者模式。Spring 的事件机制允许对象注册为事件监听器，当某个事件发生时，这些监听器将被通知并执行相应的操作。这种机制实现了解耦，让对象之间能够松散地交互。</li><li><strong>适配器模式</strong>：Spring MVC 中的 HandlerAdapter 使用适配器模式，帮助将请求从 Servlet 容器适配到 Controller 方法，并支持多种不同的处理器。</li><li><strong>策略模式</strong>：Spring的资源访问策略和事务管理策略的选择是基于策略模式的。通过配置选择不同的策略实现类，可以根据需要动态地切换实现。</li></ul></blockquote><h2 id="Spring、SpringMVC、SpringBoot之间的关系？"><a href="#Spring、SpringMVC、SpringBoot之间的关系？" class="headerlink" title="Spring、SpringMVC、SpringBoot之间的关系？"></a>Spring、SpringMVC、SpringBoot之间的关系？</h2><blockquote><p>Spring 是一个全栈式的 Java 开发框架，提供了容器、AOP、事务管理、ORM、MVC 等众多功能，是一个非常强大的框架。</p><p>Spring MVC 是 Spring 框架中的一个模块，用于开发 Web 应用程序，提供了 MVC 模式的实现，可以很方便地处理 HTTP 请求和响应。</p><p>Spring Boot 是 Spring 框架的一个子项目，它可以帮助开发者快速搭建 Spring 应用程序，提供了自动配置、快速开发、独立运行等特性，可以大大提高开发效率。</p></blockquote><p>Spring MVC的理解？</p><h2 id="SpringMVC的执行流程？"><a href="#SpringMVC的执行流程？" class="headerlink" title="SpringMVC的执行流程？"></a>SpringMVC的执行流程？</h2><blockquote><p>前端控制器—&gt;处理器映射器—&gt;处理器适配器—&gt;处理器—&gt;视图解析器—&gt;渲染视图并响应</p><ol><li><strong>客户端发送请求</strong>：客户端（浏览器）发送请求到服务器；</li><li><strong>前端控制器拦截请求</strong>：Servlet 容器会将请求交给 Spring 的 前端控制器（DispatcherServlet），进行拦截请求，并委托给处理器映射器（HandlerMapping）进行处理</li><li><strong>处理器映射器处理请求</strong>：处理器映射器（HandlerMapping）根据请求 URL 找到对应的 处理器（Controller）或 处理器链（HandlerExecutionChain）返回给 前端控制器（DispatcherServlet）</li><li><strong>处理器适配器处理请求</strong>：前端控制器（DispatcherServlet）将找到的处理器（Controller）或 处理器链（HandlerExecutionChain）交给处理器适配器（HandlerAdapter）去调用合适的处理器（Controller）</li><li><strong>处理器处理请求</strong>：处理器（Controller）执行业务逻辑，处理请求并生成模型数据，然后返回一个逻辑视图名（Logical View Name）或 ModelAndView 对象，返回给前端控制器（DispatcherServlet）；</li><li><strong>视图解析器解析视图</strong>：前端控制器（DispatcherServlet）将逻辑视图名或 ModelAndView 对象传递给视图解析器（ViewResolver），视图解析器根据逻辑视图名解析出一个具体的视图对象（如 JSP、Thymeleaf 或 FreeMarker 等）并响应给前端控制器（DispatcherServlet）</li><li><strong>渲染视图并响应</strong>：前端控制器（DispatcherServlet）调用视图对象（View）的渲染方法，将模型数据填充到视图中，并生成最终的响应结果，将其返回给客户端（浏览器）。</li></ol><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/SpringMVC执行流程.png" style="zoom:50%"></blockquote><h2 id="过滤器与拦截器有什么区别？"><a href="#过滤器与拦截器有什么区别？" class="headerlink" title="过滤器与拦截器有什么区别？"></a>过滤器与拦截器有什么区别？</h2><blockquote><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/监听器、过滤器、拦截器的区别.png" style="zoom:50%"><h3 id="功能定位"><a href="#功能定位" class="headerlink" title="功能定位"></a>功能定位</h3><ul><li><strong>监听器</strong>：主要用于监听和响应特定事件，对事件进行处理。</li><li><strong>过滤器</strong>：用于对请求进行预处理和后处理，对请求和响应进行筛选和修改。</li><li><strong>拦截器</strong>：在请求和响应的处理过程中，拦截并插入额外的逻辑来实现附加功能。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li><strong>监听器</strong>：适用于需要侦听和响应应用程序中的事件的情况，如服务器启动&#x2F;关闭、会话的创建&#x2F;销毁等。</li><li><strong>过滤器</strong>：常用于对请求进行过滤和处理，如身份验证、请求参数处理、字符编码等。</li><li><strong>拦截器</strong>：通常用于在应用程序级别上实现横切关注点，如日志记录、权限验证、性能监控等。</li></ul><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><ul><li><strong>监听器</strong>：由事件的发生顺序决定的，是被动的组件，它通过事件监听机制等待特定事件的发生，并在事件触发时执行相应的处理逻辑</li><li><strong>过滤器</strong>：过滤器通常形成一个过滤器链（Filter Chain），按照配置的顺序依次执行</li><li><strong>拦截器</strong>：由框架或应用程序维护拦截器链，通过拦截器链中的调用顺序依次执行拦截器的前置和后置逻辑</li></ul><h3 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h3><ul><li><strong>监听器</strong>：使用事件监听机制，通过实现特定接口或注解来定义监听器，并在配置文件或代码中进行注册。</li><li><strong>过滤器</strong>：使用Servlet规范中的Filter接口，通过编写过滤器类并在配置文件中进行配置和映射。</li><li><strong>拦截器</strong>：通常由框架或应用程序提供，通过定义拦截器类，并在配置或代码中进行配置和使用。</li></ul></blockquote><h2 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h2><blockquote><p>在Spring Boot项目中的引导类上有一个注解@SpringBootApplication，这个注解是对三个注解进行了封装，分别是：</p><ul><li><p>@SpringBootConfiguration</p></li><li><p>@EnableAutoConfiguration</p></li><li><p>@ComponentScan</p></li></ul><p>其中<code>@EnableAutoConfiguration</code>是实现自动化配置的核心注解。</p><p>该注解通过<code>@Import</code>注解导入对应的配置选择器。关键的是内部就是读取了该项目和该项目引用的Jar包的的classpath路径下<strong>META-INF&#x2F;spring.factories</strong>文件中的所配置的类的全类名。</p><p>在这些配置类中所定义的Bean会根据条件注解所<strong>指定的条件来决定</strong>是否需要将其导入到Spring容器中。</p><p>一般条件判断会有像<code>@ConditionalOnClass</code>这样的注解，判断是否有对应的class文件，如果有则加载该类，把这个配置类的所有的Bean放入spring容器中使用。</p></blockquote><h2 id="SpringBoot的启动过程？"><a href="#SpringBoot的启动过程？" class="headerlink" title="SpringBoot的启动过程？"></a>SpringBoot的启动过程？</h2><blockquote><p>Spring Boot的启动过程可以分为以下几个步骤：</p><ol><li>加载启动类：Spring Boot通过Java的反射机制加载启动类（通常是带有<code>@SpringBootApplication</code>注解的类）。启动类是整个应用的入口点，它包含了Spring Boot的配置和启动逻辑。</li><li>启动应用上下文：Spring Boot创建并启动一个应用上下文（ApplicationContext）。应用上下文是Spring框架的核心容器，负责管理和组装各个Bean对象。</li><li>执行自动配置：Spring Boot会根据依赖和配置信息，自动配置应用的各项功能。自动配置是Spring Boot的核心特性之一，它通过条件判断和自动装配机制，根据应用的环境和依赖，智能地配置和初始化相关组件。</li><li>扫描和注册Bean：Spring Boot会扫描并注册所有标记有@Component、@Service、@Controller等注解的Bean对象。这些注解通过元数据的方式告诉Spring框架哪些类是需要被管理和使用的。</li><li>运行应用：Spring Boot在完成Bean的注册后，会执行一些应用的初始化和准备工作，例如加载配置文件、连接数据库等。最后，启动内嵌的Servlet容器（如Tomcat、Jetty等），并将应用部署到容器中，使应用可以响应外部请求。</li><li>应用就绪：一旦应用启动成功并完全初始化，Spring Boot会发送一个应用就绪的事件。开发者可以通过编写监听器来监听该事件，执行一些自定义的操作。</li></ol></blockquote><h2 id="SpringBoot常用注解？"><a href="#SpringBoot常用注解？" class="headerlink" title="SpringBoot常用注解？"></a>SpringBoot常用注解？</h2><blockquote><p>第一类是：声明bean，有@Component、@Service、@Repository、@Controller</p><p>第二类是：依赖注入相关的，有@Autowired、@Qualifier、@Resourse</p><p>第三类是：设置作用域 @Scope</p><p>第四类是：spring配置相关的，比如@Configuration，@ComponentScan 和 @Bean</p><p>第五类是：跟aop相关做增强的注解 @Aspect，@Before，@After，@Around，@Pointcut</p></blockquote></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://w_e_n.gitee.io/blog">wen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://w_e_n.gitee.io/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/">https://w_e_n.gitee.io/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://w_e_n.gitee.io/blog" target="_blank">远方の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><div class="post_share"><div class="social-share" data-image="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Web%E5%BC%80%E5%8F%91%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/%E9%9D%A2%E8%AF%95%E9%A2%98.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF%E5%92%8C%E5%B7%A5%E5%85%B7/" title="面试题-技术场景和工具"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF%E5%92%8C%E5%B7%A5%E5%85%B7/%E9%9D%A2%E8%AF%95%E9%A2%98.png" onerror='onerror=null,src="/blog/img/404.png"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面试题-技术场景和工具</div></div></a></div><div class="next-post pull-right"><a href="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/" title="面试题-JavaSE"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/%E9%9D%A2%E8%AF%95%E9%A2%98.png" onerror='onerror=null,src="/blog/img/404.png"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">面试题-JavaSE</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Redis/" title="面试题-Redis"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-Redis/%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-01</div><div class="title">面试题-Redis</div></div></a></div><div><a href="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/" title="面试题-微服务与中间件"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-01</div><div class="title">面试题-微服务与中间件</div></div></a></div><div><a href="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF%E5%92%8C%E5%B7%A5%E5%85%B7/" title="面试题-技术场景和工具"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF%E5%92%8C%E5%B7%A5%E5%85%B7/%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-01</div><div class="title">面试题-技术场景和工具</div></div></a></div><div><a href="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/" title="面试题-JavaSE"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-JavaSE/%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-01</div><div class="title">面试题-JavaSE</div></div></a></div><div><a href="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-MySQL/" title="面试题-MySQL"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/%E9%9D%A2%E8%AF%95%E9%A2%98-MySQL/%E9%9D%A2%E8%AF%95%E9%A2%98.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-01</div><div class="title">面试题-MySQL</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Gitalk</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/img/%E5%A4%B4%E5%83%8F.png" onerror='this.onerror=null,this.src="/blog/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">wen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wen53231323"><i class="fab fa-github"></i><span>我的仓库</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">暂无</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaWeb"><span class="toc-number">1.</span> <span class="toc-text">JavaWeb</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#B-x2F-S%E6%9E%B6%E6%9E%84%E4%B8%8EC-x2F-S%E6%9E%B6%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.</span> <span class="toc-text">B&#x2F;S架构与C&#x2F;S架构是什么?</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B-x2F-S%E6%9E%B6%E6%9E%84%EF%BC%88Browser-x2F-Server%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">B&#x2F;S架构（Browser&#x2F;Server）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-x2F-S%E6%9E%B6%E6%9E%84%EF%BC%88Client-x2F-Server%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">C&#x2F;S架构（Client&#x2F;Server）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">MVC是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%90%8E%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">在浏览器输入网址后请求的过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">MVC工作流程是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">HTTP请求方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP%E5%B8%B8%E8%A7%81%E5%93%8D%E5%BA%94%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.6.</span> <span class="toc-text">HTTP常见响应码有哪些?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.7.</span> <span class="toc-text">GET和POST的区别?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POST%E5%92%8CPUT%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">POST和PUT的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Session%E4%B8%8ECookie%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.9.</span> <span class="toc-text">Session与Cookie的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.10.</span> <span class="toc-text">转发与重定向的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tomcat%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.11.</span> <span class="toc-text">Tomcat是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tomcat%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9"><span class="toc-number">1.12.</span> <span class="toc-text">Tomcat有什么特点?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tomcat%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">1.13.</span> <span class="toc-text">Tomcat有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Servlet%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.14.</span> <span class="toc-text">Servlet是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Servlet%E5%AE%B9%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.15.</span> <span class="toc-text">Servlet容器是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B0%86Tomcat%E7%A7%B0%E4%B8%BAServlet%E5%AE%B9%E5%99%A8%EF%BC%9F"><span class="toc-number">1.16.</span> <span class="toc-text">为什么将Tomcat称为Servlet容器？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.17.</span> <span class="toc-text">Servlet生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaWeb%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.18.</span> <span class="toc-text">JavaWeb三大组件是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Filter%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.19.</span> <span class="toc-text">Filter是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Listener%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.20.</span> <span class="toc-text">Listener是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.21.</span> <span class="toc-text">三层架构是什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux"><span class="toc-number">2.</span> <span class="toc-text">Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">Linux常用命令？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E6%80%8E%E4%B9%88%E7%9C%8B%E8%BF%9B%E7%A8%8B%E5%8F%B7"><span class="toc-number">2.2.</span> <span class="toc-text">Linux怎么看进程号?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux%E6%80%8E%E6%A0%B7%E7%BB%99%E6%96%87%E4%BB%B6%E6%8E%88%E6%9D%83"><span class="toc-number">2.3.</span> <span class="toc-text">Linux怎样给文件授权?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mybatis"><span class="toc-number">3.</span> <span class="toc-text">Mybatis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">Mybatis是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis%E7%9A%84-%E5%92%8C-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.2.</span> <span class="toc-text">Mybatis的${}和#{}区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%EF%BC%9F"><span class="toc-number">3.3.</span> <span class="toc-text">Mybatis常用标签？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ResultType%E5%92%8CResultMap%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.4.</span> <span class="toc-text">ResultType和ResultMap的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%E7%9A%84%EF%BC%9F"><span class="toc-number">3.5.</span> <span class="toc-text">Mybatis是如何实现分页的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis%E4%B8%AD%E7%89%A9%E7%90%86%E5%88%86%E9%A1%B5%EF%BC%88%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E9%A1%B5%EF%BC%89%E4%B8%8E%E9%80%BB%E8%BE%91%E5%88%86%E9%A1%B5%EF%BC%88%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5%EF%BC%89"><span class="toc-number">3.6.</span> <span class="toc-text">Mybatis中物理分页（数据库分页）与逻辑分页（内存分页）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis%E7%9A%84%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">3.7.</span> <span class="toc-text">Mybatis的分页插件运行原理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">3.8.</span> <span class="toc-text">Mybatis的执行流程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%9F"><span class="toc-number">3.9.</span> <span class="toc-text">Mybatis是否支持延迟加载？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis%E7%9A%84%E4%B8%80%E7%BA%A7%E3%80%81%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">3.10.</span> <span class="toc-text">Mybatis的一级、二级缓存？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">3.11.</span> <span class="toc-text">一级缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">3.12.</span> <span class="toc-text">二级缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MybatisPlus%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">3.13.</span> <span class="toc-text">MybatisPlus是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MybatisPlus%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%EF%BC%9F"><span class="toc-number">3.14.</span> <span class="toc-text">MybatisPlus的常用注解？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring"><span class="toc-number">4.</span> <span class="toc-text">Spring</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.1.</span> <span class="toc-text">Spring是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E5%8C%85%E5%90%AB%E7%9A%84%E6%A8%A1%E5%9D%97%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">Spring包含的模块有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IOC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">IOC是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOP%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.4.</span> <span class="toc-text">AOP是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DI%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.5.</span> <span class="toc-text">DI是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88DI%EF%BC%89%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">4.6.</span> <span class="toc-text">依赖注入（DI）怎么实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.7.</span> <span class="toc-text">自动装配是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">4.8.</span> <span class="toc-text">自动装配怎么实现？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8EXML%E9%85%8D%E7%BD%AE"><span class="toc-number">4.9.</span> <span class="toc-text">基于XML配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.10.</span> <span class="toc-text">基于注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Autowired%E5%92%8C-Resouce%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.11.</span> <span class="toc-text">@Autowired和@Resouce的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.12.</span> <span class="toc-text">Bean是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E6%80%8E%E4%B9%88%E5%A3%B0%E6%98%8E%EF%BC%9F"><span class="toc-number">4.13.</span> <span class="toc-text">Bean怎么声明？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XML-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A3%B0%E6%98%8E-Bean"><span class="toc-number">4.14.</span> <span class="toc-text">XML 配置文件声明 Bean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3%E5%A3%B0%E6%98%8E-Bean"><span class="toc-number">4.15.</span> <span class="toc-text">注解声明 Bean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.16.</span> <span class="toc-text">Bean生命周期?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.17.</span> <span class="toc-text">Bean的作用域有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">4.18.</span> <span class="toc-text">Bean是线程安全的吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory%E5%92%8CApplicationContext%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.19.</span> <span class="toc-text">BeanFactory和ApplicationContext有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.20.</span> <span class="toc-text">循环依赖是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">4.21.</span> <span class="toc-text">循环依赖怎么解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.22.</span> <span class="toc-text">三级缓存是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">4.23.</span> <span class="toc-text">事务是如何实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">4.24.</span> <span class="toc-text">编程式事务和声明式事务优缺点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transactional%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">4.25.</span> <span class="toc-text">@Transactional声明式事务为什么不推荐使用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transactional%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E5%9C%BA%E6%99%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.26.</span> <span class="toc-text">@Transactional事务失效的场景有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="toc-number">4.27.</span> <span class="toc-text">Spring 框架中用到了哪些设计模式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E3%80%81SpringMVC%E3%80%81SpringBoot%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">4.28.</span> <span class="toc-text">Spring、SpringMVC、SpringBoot之间的关系？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">4.29.</span> <span class="toc-text">SpringMVC的执行流程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%8E%E6%8B%A6%E6%88%AA%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.30.</span> <span class="toc-text">过滤器与拦截器有什么区别？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%AE%9A%E4%BD%8D"><span class="toc-number">4.30.1.</span> <span class="toc-text">功能定位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.30.2.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">4.30.3.</span> <span class="toc-text">执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.30.4.</span> <span class="toc-text">技术实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86"><span class="toc-number">4.31.</span> <span class="toc-text">SpringBoot自动装配原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">4.32.</span> <span class="toc-text">SpringBoot的启动过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%EF%BC%9F"><span class="toc-number">4.33.</span> <span class="toc-text">SpringBoot常用注解？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/CSS/" title="CSS笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/CSS/CSS.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="CSS笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/CSS/" title="CSS笔记">CSS笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/HTML/" title="HTML笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/HTML/HTML.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="HTML笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/HTML/" title="HTML笔记">HTML笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/JavaScript/" title="JavaScript笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/JavaScript/JavaScript.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="JavaScript笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/JavaScript/" title="JavaScript笔记">JavaScript笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/JavaWeb/" title="JavaWeb笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/JavaWeb/JavaWeb.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="JavaWeb笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/JavaWeb/" title="JavaWeb笔记">JavaWeb笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/Linux/" title="Linux笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/Linux/Linux.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="Linux笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/Linux/" title="Linux笔记">Linux笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By wen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '701b8bc001a40a760558',
      clientSecret: 'a51b436adc471c3949a8f41be05c2d58cccab10a',
      repo: 'Hexo-Butterfly-Comment',
      owner: 'wen53231323',
      admin: ['wen53231323'],
      id: '53647aee21cc2b48e2f37ec1b0ece51f',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'VI32wmbmMoxvlhpTpoDBNeOk-MdYXbMMI',
      appKey: 'oFstfBFkCQIkjuk4ibCpbGqz',
      avatar: 'monsterid',
      serverURLs: 'https://vi32wmbm.api.lncldglobal.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Gitalk' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/blog/js/search/local-search.js"></script></div></div></body></html>