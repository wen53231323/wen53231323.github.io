<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>JavaWeb笔记 | 远方の博客</title><meta name="author" content="wen"><meta name="copyright" content="wen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="JavaWeb基础JavaWeb技术体系  前端知识学习目录   技术 简介    HTML 结构，页面骨架，静态页面   CSS 表现，负责页面画面美化渲染   JavaScript 行为，负责页面行为，使网页可以交互，如验证之类的   jQuery JavaScript 库，方便操作BOM与DOM的功能   JSON 一种文件格式，字符串   Ajax 异步请求   Node.js 不是一门编"><meta property="og:type" content="article"><meta property="og:title" content="JavaWeb笔记"><meta property="og:url" content="https://ipvb.gitee.io/2023/01/01/JavaWeb/index.html"><meta property="og:site_name" content="远方の博客"><meta property="og:description" content="JavaWeb基础JavaWeb技术体系  前端知识学习目录   技术 简介    HTML 结构，页面骨架，静态页面   CSS 表现，负责页面画面美化渲染   JavaScript 行为，负责页面行为，使网页可以交互，如验证之类的   jQuery JavaScript 库，方便操作BOM与DOM的功能   JSON 一种文件格式，字符串   Ajax 异步请求   Node.js 不是一门编"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ipvb.gitee.io/2023/01/01/JavaWeb/JavaWeb.png"><meta property="article:published_time" content="2022-12-31T16:00:00.000Z"><meta property="article:modified_time" content="2023-09-05T18:30:49.272Z"><meta property="article:author" content="wen"><meta property="article:tag" content="JavaWeb"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://ipvb.gitee.io/2023/01/01/JavaWeb/JavaWeb.png"><link rel="shortcut icon" href="./img/favicon.png"><link rel="canonical" href="https://ipvb.gitee.io/2023/01/01/JavaWeb/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//static.cloudflareinsights.com"><link rel="preconnect" href="//www.clarity.ms"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="./css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?[object Object]";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=[object Object]"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","[object Object]")</script><script defer data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;[object Object]&quot;}"></script><script>!function(t,e,c,n,a,r){t[c]=t[c]||function(){(t[c].q=t[c].q||[]).push(arguments)},(a=e.createElement(n)).async=1,a.src="https://www.clarity.ms/tag/[object Object]",(r=e.getElementsByTagName(n)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><script>const GLOBAL_CONFIG = { 
  root: './',
  algolia: undefined,
  localSearch: {"path":"./search.xml","preload":true,"top_n_per_article":5,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"JavaWeb笔记",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-09-06 02:30:49"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./img/%E5%A4%B4%E5%83%8F.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="./archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="./tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="./categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="./"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="./archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="./tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="./categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="./picture/"><i class="fa-fw fas fa-images"></i><span> 图片库</span></a></li><li><a class="site-page child" href="./music/"><i class="fa-fw fas fa-music"></i><span> 音乐库</span></a></li><li><a class="site-page child" href="./movies/"><i class="fa-fw fas fa-video"></i><span> 视频库</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="./link/"><span>导航链接</span></a></li><li><a class="site-page child" href="./comment_loading/"><span>评论管理</span></a></li><li><a class="site-page child" href="./custom/"><span>自定义页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="./about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(2023/01/01/JavaWeb/JavaWeb.png)"><nav id="nav"><span id="blog-info"><a href="./" title="远方の博客"><span class="site-name">远方の博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="./"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="./archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="./tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="./categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="./picture/"><i class="fa-fw fas fa-images"></i><span> 图片库</span></a></li><li><a class="site-page child" href="./music/"><i class="fa-fw fas fa-music"></i><span> 音乐库</span></a></li><li><a class="site-page child" href="./movies/"><i class="fa-fw fas fa-video"></i><span> 视频库</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="./link/"><span>导航链接</span></a></li><li><a class="site-page child" href="./comment_loading/"><span>评论管理</span></a></li><li><a class="site-page child" href="./custom/"><span>自定义页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="./about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JavaWeb笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-05T18:30:49.272Z" title="更新于 2023-09-06 02:30:49">2023-09-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="./categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="JavaWeb笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JavaWeb基础"><a href="#JavaWeb基础" class="headerlink" title="JavaWeb基础"></a>JavaWeb基础</h1><h2 id="JavaWeb技术体系"><a href="#JavaWeb技术体系" class="headerlink" title="JavaWeb技术体系"></a>JavaWeb技术体系</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/JavaWeb/JavaWeb技术体系.png"><h2 id="前端知识学习目录"><a href="#前端知识学习目录" class="headerlink" title="前端知识学习目录"></a>前端知识学习目录</h2><table><thead><tr><th>技术</th><th>简介</th></tr></thead><tbody><tr><td>HTML</td><td>结构，页面骨架，静态页面</td></tr><tr><td>CSS</td><td>表现，负责页面画面美化渲染</td></tr><tr><td>JavaScript</td><td>行为，负责页面行为，使网页可以交互，如验证之类的</td></tr><tr><td>jQuery</td><td>JavaScript 库，方便操作BOM与DOM的功能</td></tr><tr><td>JSON</td><td>一种文件格式，字符串</td></tr><tr><td>Ajax</td><td>异步请求</td></tr><tr><td>Node.js</td><td>不是一门编程语言，是一个执行 JavaScript 代码的工具，提供了前端程序的运行环境<br>可以把Node.js理解成是运行前端程序的服务器，等同于Java中的Tomcat</td></tr><tr><td>webpack</td><td>前端模块打包机，基于 Node.js 开发出来的打包工具，是目前前端项目工程化的具体解决方案，类似Java中的Maven</td></tr><tr><td>Vue</td><td>前端MVVM框架，免除原生JavaScript中的DOM操作，简化书写</td></tr></tbody></table><h2 id="B-x2F-S架构与C-x2F-S架构"><a href="#B-x2F-S架构与C-x2F-S架构" class="headerlink" title="B&#x2F;S架构与C&#x2F;S架构"></a>B&#x2F;S架构与C&#x2F;S架构</h2><h3 id="B-x2F-S架构（Browser-x2F-Server）"><a href="#B-x2F-S架构（Browser-x2F-Server）" class="headerlink" title="B&#x2F;S架构（Browser&#x2F;Server）"></a>B&#x2F;S架构（Browser&#x2F;Server）</h3><p>B&#x2F;S架构（Browser&#x2F;Server Architecture）是指浏览器&#x2F;服务器架构，也被称为Web架构。在B&#x2F;S架构中，应用程序的前端界面（通常是浏览器）与后端服务器进行交互。</p><ul><li><p><strong>交互流程</strong>：在B&#x2F;S架构中，前端界面是通过浏览器上的Web页面来呈现给用户，通常使用HTML、CSS和JavaScript等技术来实现。用户通过浏览器发送请求（如点击链接、填写表单等），请求会被发送到服务器端进行处理。服务器端进行相应的业务逻辑处理，并返回数据或页面给浏览器，浏览器再将这些数据或页面展示给用户。</p></li><li><p><strong>适应场景</strong>：B&#x2F;S架构适用于跨平台和分布式环境，因为它只需要一个浏览器作为客户端界面，不需要安装额外的客户端软件</p></li><li><p><strong>示例应用</strong>：常见的网站和在线应用一般采用B&#x2F;S架构，如电子商务网站、新闻网站等</p></li></ul><h3 id="C-x2F-S架构（Client-x2F-Server）"><a href="#C-x2F-S架构（Client-x2F-Server）" class="headerlink" title="C&#x2F;S架构（Client&#x2F;Server）"></a>C&#x2F;S架构（Client&#x2F;Server）</h3><p>C&#x2F;S架构（Client&#x2F;Server Architecture）是指客户端&#x2F;服务器架构。在C&#x2F;S架构中，应用程序被分为客户端和服务器两个部分。</p><ul><li><strong>交互流程</strong>：在C&#x2F;S架构中，客户端是安装在用户本地的软件，负责用户界面的显示和用户交互，用户可以在客户端上进行各种操作，客户端会将这些操作转换为请求，发送给服务器。服务器则负责接收客户端的请求，进行相应的处理，并返回结果给客户端。</li><li><strong>适应场景</strong>：客户端软件需要在各个平台上进行开发和维护，适用于对性能和用户体验要求较高的应用场景。</li><li><strong>示例应用</strong>： 桌面应用程序和移动应用程序采用C&#x2F;S架构，如QQ、迅雷等APP。</li></ul><h2 id="在浏览器输入网址后请求的过程"><a href="#在浏览器输入网址后请求的过程" class="headerlink" title="在浏览器输入网址后请求的过程"></a>在浏览器输入网址后请求的过程</h2><p>在浏览器输入一个网址后，以下是请求的一般过程：</p><ol><li><strong>DNS解析</strong>：浏览器首先会解析输入的网址中的域名部分，将域名解析为对应的IP地址。浏览器会向本地DNS服务器发送查询请求，如果本地DNS服务器没有缓存该域名对应的IP地址，则会向根DNS服务器逐级查询，最终获取到目标服务器的IP地址。</li><li><strong>建立TCP连接</strong>：浏览器使用HTTP协议与目标服务器建立TCP连接。TCP连接的建立需要进行”三次握手”，即客户端向服务器发送连接请求，服务器回复确认连接请求，最后客户端再次回复确认。</li><li><strong>向服务器发起HTTP请求</strong>：建立TCP连接后，浏览器会构建HTTP请求报文，包括请求行、请求头和请求体等信息。请求行中包含了请求方法（GET、POST等）、请求URL和协议版本等。请求头中包含了一些附加的信息，如Cookie、Referer、User-Agent等。请求体中通常包含了一些表单数据或上传的文件等内容。</li><li><strong>服务器处理请求</strong>：目标服务器接收到浏览器发送的HTTP请求后，会进行请求的处理。服务器根据请求的URL找到对应的资源（如静态文件或动态程序），执行相应的操作。这可能涉及到数据库查询、业务逻辑处理等。</li><li><strong>服务器发送HTTP响应</strong>：服务器处理完请求后，会生成HTTP响应报文，包括响应行、响应头和响应体等信息。响应行中包含了响应状态码（如200表示成功、404表示资源未找到等）和协议版本等。响应头中包含了一些附加的信息，如响应的内容类型、长度、缓存策略等。响应体中包含了服务器返回给浏览器的数据或页面内容。</li><li><strong>接收响应并渲染页面</strong>：浏览器接收到服务器发送的HTTP响应后，会根据响应的内容进行页面渲染。如果响应是一个HTML页面，浏览器会解析HTML代码，并加载其中引用的其他资源（如CSS、JavaScript文件等）。最终，浏览器将页面展示给用户。</li><li><strong>关闭TCP连接</strong>：当页面全部加载完成后，浏览器会关闭与服务器的TCP连接，释放资源。在后续的操作中，如果需要再次请求同一服务器的资源，浏览器会重新建立TCP连接。</li></ol><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/JavaWeb/浏览器输入网址后请求的过程.png" style="zoom:50%"><h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h2 id="常用的-Web-服-务-器"><a href="#常用的-Web-服-务-器" class="headerlink" title="常用的 Web 服 务 器"></a>常用的 Web 服 务 器</h2><table><thead><tr><th>web服务器</th><th>简介</th></tr></thead><tbody><tr><td>Tomcat</td><td>Apache组织提供的一种web服务器，提供对jsp和servlet的支持。轻量级的javaweb容器(服务器)，当前应用最广的javaweb服务器(免费)</td></tr><tr><td>Jboss</td><td>遵从javaEE规范的、开放源码的、纯java的ELB服务器，支持所有的javaEE规范(免费)</td></tr><tr><td>GlassFish</td><td>Oracle公司开发的一款Javaweb服务器,是一款强健的商业服务器，达到产品级质量(应用很少)</td></tr></tbody></table><h2 id="Tomcat简介"><a href="#Tomcat简介" class="headerlink" title="Tomcat简介"></a>Tomcat简介</h2><p>Tomcat（全名为Apache Tomcat）是一个开源的、轻量级的Web应用服务器，由Apache软件基金会开发和维护。Tomcat可以作为Servlet容器、JSP容器和WebSocket容器</p><h2 id="Tomcat特点"><a href="#Tomcat特点" class="headerlink" title="Tomcat特点"></a>Tomcat特点</h2><p>Tomcat具有以下几个主要特点：</p><ol><li><strong>轻量级</strong>：Tomcat是一个相对轻量级的Servlet容器，它具有较小的内存占用和快速启动的特点。由于其设计简单，它在资源消耗方面比一些其他大型JavaEE服务器（如WebLogic、WebSphere）更加节省。</li><li><strong>独立性</strong>：Tomcat是一个独立的服务，可以独立于其他Web服务器（如Apache HTTP Server）运行。它可以作为独立的Servlet容器使用，也可以与其他Web服务器配合使用，通过反向代理或负载均衡实现更复杂的部署架构。</li><li><strong>开源性</strong>：Tomcat是一个开源项目，代码完全公开，并且遵循Apache许可证。这意味着任何人都可以查看、使用和修改Tomcat的源代码，可以根据自己的需求进行定制和扩展，使得它具有较好的灵活性和可定制性。</li><li><strong>可扩展性</strong>：Tomcat提供了可插拔的架构，允许用户通过添加或配置插件（例如Valve、Realm、Servlet等）来扩展其功能。这使得开发人员可以根据需要增加新的功能组件，或者替换默认的组件实现，以满足特定的需求。</li><li><strong>易用性</strong>：Tomcat提供了一个简单易用的管理界面（Tomcat Manager），可以通过该界面对Web应用程序进行部署、启停和监控。它还支持热部署特性，在不重启服务器的情况下更新Web应用程序，方便开发和调试。无论是小型的个人网站还是大型的企业级应用，都可以选择Tomcat作为其运行环境。同时，许多Java Web框架都默认支持Tomcat，使得开发人员更容易上手和开发应用程序。</li><li><strong>多协议支持</strong>：Tomcat不仅支持HTTP协议，还支持其他常用的网络协议，如HTTPS、AJP（Apache JServ Protocol）等。这使得Tomcat可以与其他应用程序和Web服务器进行协同工作，提供更灵活的部署方式。</li><li><strong>多线程支持</strong>：Tomcat使用多线程技术来处理并发请求，提高系统的并发性能。它为每个请求创建一个独立的线程，这样可以同时处理多个请求，提升Web应用程序的吞吐量。</li><li><strong>安全性支持</strong>：Tomcat提供了多种安全措施，例如基于角色的访问控制、SSL&#x2F;TLS加密等。它通过配置文件和管理界面来管理用户认证、授权和安全设置，以确保Web应用程序的安全性。</li><li><strong>JSP支持</strong>：Tomcat还支持JavaServer Pages（JSP）技术。JSP是用于创建动态Web页面的Java标准，可以在其中嵌入Java代码和HTML标记。Tomcat可以编译和执行JSP页面，将其转化为Servlet并进行处理，从而生成最终的HTML响应。</li><li><strong>Java WebSocket支持</strong>：Tomcat对Java WebSocket API提供了支持，可以加载和执行WebSocket相关的类和方法，从而实现WebSocket通信功能。开发人员可以使用Tomcat来构建实时的双向通信应用程序。</li><li><strong>Servlet容器</strong>：Tomcat作为一个Servlet容器，它能够加载、实例化和管理Servlet组件。它接收来自客户端的HTTP请求，并将请求转发给相应的Servlet进行处理，然后将处理结果返回给客户端。Tomcat负责管理Servlet的生命周期、线程处理和请求-响应的过程。</li></ol><h2 id="Tomcat作用"><a href="#Tomcat作用" class="headerlink" title="Tomcat作用"></a>Tomcat作用</h2><p>Tomcat作为一个Servlet容器，在Java Web开发中具有以下主要作用：</p><ol><li><strong>提供Servlet容器环境</strong>：Tomcat是一个Servlet容器，遵循Java Servlet规范，能够运行Java编写的Servlet代码。</li><li><strong>提供Servlet管理</strong>：Tomcat可以管理和处理Servlet的生命周期，包括初始化、加载、调用和销毁。</li><li><strong>提供连接池管理</strong>：Tomcat可以管理数据库连接池，提供了一组API和配置选项，用于管理数据库连接的创建、复用和回收，从而提高数据库访问的效率和性能。</li><li><strong>URL映射</strong>：Tomcat接收来自客户端的HTTP请求，URL映射将客户端请求转发给相应的Servlet进行处理。这样，开发人员可以根据URL的不同将请求分发到不同的Servlet，实现灵活的请求处理机制。</li><li><strong>运行JSP页面</strong>：Tomcat内置了JSP引擎，可以将JSP页面编译成Servlet，并在运行时动态地生成HTML响应。开发人员可以使用JSP编写动态的Web页面，通过Tomcat来解析和执行这些JSP页面。</li><li><strong>处理静态资源</strong>：除了动态生成的Servlet和JSP页面，Web应用程序还可能包含静态资源，如HTML、CSS、JavaScript、图片等。Tomcat可以直接处理这些静态资源的访问，并将其发送给客户端，无需额外的配置或处理。</li><li><strong>Web应用部署</strong>：Tomcat提供了一个简单易用的管理界面（Tomcat Manager），允许用户对Web应用程序进行部署、启停和监控。开发人员可以通过Tomcat Manager来管理多个Web应用程序，进行版本管理和灰度发布等操作。</li></ol><h2 id="Tomcat目录介绍"><a href="#Tomcat目录介绍" class="headerlink" title="Tomcat目录介绍"></a>Tomcat目录介绍</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Tomcat</span><br><span class="line">├─ bin                     # 存放Tomcat的可执行文件</span><br><span class="line">│   ├─ catalina.sh         # Tomcat启动脚本（Unix/Linux）</span><br><span class="line">│   ├─ catalina.bat        # Tomcat启动脚本（Windows）</span><br><span class="line">│   └─ ...</span><br><span class="line">├─ conf                    # 存放Tomcat的配置文件</span><br><span class="line">│   ├─ server.xml          # Tomcat服务器配置文件</span><br><span class="line">│   ├─ web.xml             # 全局Web应用程序配置文件</span><br><span class="line">│   └─ ...</span><br><span class="line">├─ lib                     # 存放Tomcat的库文件</span><br><span class="line">│   ├─ catalina.jar        # Tomcat容器核心库</span><br><span class="line">│   ├─ servlet-api.jar     # Java Servlet API库</span><br><span class="line">│   └─ ...</span><br><span class="line">├─ logs                    # 存放Tomcat日志文件</span><br><span class="line">│   ├─ catalina.out        # Tomcat运行日志</span><br><span class="line">│   └─ ...</span><br><span class="line">├─ webapps                 # 存放Web应用程序</span><br><span class="line">│   ├─ ROOT                # 默认的根应用程序</span><br><span class="line">│   ├─ myapp               # 自定义的Web应用程序</span><br><span class="line">│   └─ ...</span><br><span class="line">├─ work                    # 存放Tomcat的工作目录</span><br><span class="line">│   └─ ...</span><br><span class="line">└─ ...</span><br></pre></td></tr></table></figure><h2 id="IDEA添加Tomcat"><a href="#IDEA添加Tomcat" class="headerlink" title="IDEA添加Tomcat"></a>IDEA添加Tomcat</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>（1）使用maven骨架创建web项目，选中Create from archetype，搜索webapp</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/JavaWeb/Maven骨架项目.png" style="zoom:50%"><p>（2）生成的目录并不是完整的，可以自己添java目录、resources目录、test目录</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/JavaWeb/Web项目目录介绍.png" style="zoom:50%"><p>（3）在pom.xml文件添加打包方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--&lt;packaging&gt;：打包方式标签（war表示是web项目，默认值是jar）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打成war包后目录结构变化</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、编译后的java字节码文件和resources的资源文件，会放到WEB-INF下的classes目录下</span><br><span class="line"><span class="number">2</span>、pom.xml中依赖坐标对应的jar包，会放入WENF下的<span class="class"><span class="keyword">lib</span>目录下</span></span><br></pre></td></tr></table></figure><h3 id="方式一：集成本地Tomcat"><a href="#方式一：集成本地Tomcat" class="headerlink" title="方式一：集成本地Tomcat"></a>方式一：集成本地Tomcat</h3><p>（1）安装tomcat省略</p><p>（2）集成本地Tomcat到IDEA</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/JavaWeb/集成本地Tomcat到IDEA.png" style="zoom:80%"><p>其中级别update classes and resources最低，restart最高</p><table><thead><tr><th>模式</th><th>简介</th></tr></thead><tbody><tr><td>Update resources</td><td>修改html、css、js后，执行更新</td></tr><tr><td>Redeploy</td><td>修改后台Java代码后，在不重新启动服务器的情况下，重建和重新部署应用程序构件，一般在更改java文件时使用。</td></tr><tr><td>Update classes and resources</td><td>重新编译所有更改的Java类(仅在debugging时)+更新所有更改过的资源，一般在更改.jsp文件时使用</td></tr><tr><td>Restart server</td><td>修改服务器配置（即配置文件）后，执行更新</td></tr></tbody></table><p>（3）点击deployment，点右边的+的artifacts，选择war exploded，将开发项目部署项目到Tomcat中</p><table><thead><tr><th>模式</th><th>简介</th></tr></thead><tbody><tr><td>xxx.war</td><td>发布模式，将项目打成war包，把war包发布到Tomcat服务器上， war模式部署成功后，Tomcat的webapps目录下会有部署的项目内容，这个一般是成品项目，也就是整个项目完成后才去做的</td></tr><tr><td>xxx.war exploded</td><td>展开部署，将WEB工程以当前文件夹的位置关系发布到Tomcat服务器上 war exploded模式部署成功后，Tomcat的webapps目录下没有，而使用的是项目的target目录下的内容进行部署 这个更适合我们测试的时候使用，所以虚拟目录应该用这个选项</td></tr></tbody></table><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/JavaWeb/配置Tomcat.png" style="zoom:80%"><h3 id="方式二：Maven添加Tomcat插件"><a href="#方式二：Maven添加Tomcat插件" class="headerlink" title="方式二：Maven添加Tomcat插件"></a>方式二：Maven添加Tomcat插件</h3><p>（1）在pom.xml中添加Tomcat插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>   </span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">	    <span class="comment">&lt;!--Tomcat插件 --&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	            <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span><span class="comment">&lt;!--访问端口号 --&gt;</span></span><br><span class="line">	            <span class="comment">&lt;!--项目访问路径</span></span><br><span class="line"><span class="comment">	                未配置访问路径: http://localhost:80/tomcat-demo2/test.html</span></span><br><span class="line"><span class="comment">	                配置/后访问路径: http://localhost:80/test.html</span></span><br><span class="line"><span class="comment">	                如果配置成 /hello,访问路径会变成: http://localhost:80/hello/test.html</span></span><br><span class="line"><span class="comment">	            --&gt;</span></span><br><span class="line">	            <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span><span class="comment">&lt;!--项目访问路径--&gt;</span></span><br><span class="line">	        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）使用Maven Helper插件快速启动项目</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/JavaWeb/Tomcat插件使用.png" style="zoom:80%"><h3 id="添加Tomcat报错解决"><a href="#添加Tomcat报错解决" class="headerlink" title="添加Tomcat报错解决"></a>添加Tomcat报错解决</h3><p>在右下角提示Error：Duplicate context path ‘&#x2F;‘报错，原因是Tomcat下加入两个maven项目，同一个项目的war和exploded两个版本，因为不可能存在几个项目都发布到同一个地址下这里是’&#x2F;‘，所以需要修改其他项目的 Application context即可</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/JavaWeb/Tomcat报错解决.png" style="zoom:50%"><h1 id="JavaWeb三大组件"><a href="#JavaWeb三大组件" class="headerlink" title="JavaWeb三大组件"></a>JavaWeb三大组件</h1><blockquote><p>JavaWeb 的三大组件分别是Servlet 程序、Filter过滤器、Listener 监听器</p></blockquote><h2 id="Servlet程序"><a href="#Servlet程序" class="headerlink" title="Servlet程序"></a>Servlet程序</h2><h3 id="Servlet简介"><a href="#Servlet简介" class="headerlink" title="Servlet简介"></a>Servlet简介</h3><p>Servlet在Java Web开发中扮演着重要的角色，是一种用于在Web服务器上运行的Java程序组件</p><ul><li><strong>狭义Servlet</strong>：指Java语言中的javax.servlet.Servlet接口，这个接口定义了处理客户端请求和生成响应的方法</li><li><strong>广义Servlet</strong>：指任何实现了javax.servlet.Servlet接口的类，包括通过实现该接口或继承已有实现的类来创建的Servlet类。</li></ul><p>Servlet运行在服务器端，主要作用是使用Java语言与Servlet容器（如Tomcat）进行交互，处理Web请求和生成Web响应。</p><ol><li><strong>处理Web请求</strong>：Servlet可以接收来自客户端的HTTP请求，并根据请求的内容进行相应的处理。它可以读取请求参数、处理表单数据、解析请求头等。通过编写Servlet类，开发者可以定义自己的业务逻辑来处理不同类型的请求。</li><li><strong>生成Web响应</strong>：Servlet可以根据业务逻辑和请求内容动态生成HTTP响应。它可以生成HTML页面、JSON数据、XML文档等各种形式的响应内容。开发者可以通过设置响应状态码、头信息和内容体等来构建合适的响应，以满足客户端的需求。</li></ol><h3 id="Servlet容器简介"><a href="#Servlet容器简介" class="headerlink" title="Servlet容器简介"></a>Servlet容器简介</h3><ol><li>Servlet是一种用于在Web服务器上基于Java语言编写的服务器端程序，本身不能独立运行，需要在支持Servlet规范的容器中才能被加载和执行</li><li>Servlet容器，也称为Web容器或Servlet引擎，提供了运行和管理Servlet的环境，可以加载和执行Java编写的Servlet代码</li><li>常见的Servlet容器有Apache Tomcat、Jetty、IBM WebSphere和Oracle WebLogic等。这些容器实现了Servlet规范，可以加载和执行Java编写的Servlet代码</li></ol><h3 id="Servlet与Tomcat关系"><a href="#Servlet与Tomcat关系" class="headerlink" title="Servlet与Tomcat关系"></a>Servlet与Tomcat关系</h3><p>Tomcat 作为Servlet容器，负责处理客户请求，把请求传送给Servlet，并将Servlet的响应传送回给客户，而Servlet运行在服务器端，主要作用是使用Java语言与Servlet容器（如Tomcat）进行交互，处理Web请求和生成Web响应。Servlet需要依赖Tomcat才能运行，Tomcat 服务器和Servlet 版本的对应关系</p><table><thead><tr><th>Tomcat版本</th><th>Servlet&#x2F;jsp版本</th><th>javaEE版本</th><th>运行环境</th></tr></thead><tbody><tr><td>4.1</td><td>2.3&#x2F;1.2</td><td>1.3</td><td>Jdk1.3</td></tr><tr><td>5.0</td><td>2.4&#x2F;2.0</td><td>1.4</td><td>Jdk1.4</td></tr><tr><td>5.5&#x2F;6.0</td><td>2.5&#x2F;2.1</td><td>5.0</td><td>Jdk5.0</td></tr><tr><td>7.0</td><td>3.0&#x2F;2.2</td><td>6.0</td><td>Jdk6.0</td></tr><tr><td>8.0</td><td>3.1&#x2F;2.3</td><td>7.0</td><td>Jdk7.0</td></tr></tbody></table><h3 id="Servlet继承关系"><a href="#Servlet继承关系" class="headerlink" title="Servlet继承关系"></a>Servlet继承关系</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/JavaWeb/Servlet继承关系.png" style="zoom:50%"><table><thead><tr><th>关系</th><th>简介</th></tr></thead><tbody><tr><td>javax.servlet.Servlet接口</td><td>Servlet体系根接口，有5个方法</td></tr><tr><td>javax.servlet.Generic抽象类</td><td>Servlet抽象实现类，对不常用的方法进行了空实现，未对service方法进行实现</td></tr><tr><td>javax.servlet.http.HttpServlet抽象子类</td><td>继承Generic抽象实现类，对serivice方法重写，主要针对表单提交方式的重写</td></tr></tbody></table><h3 id="Servlet接口的五个方法"><a href="#Servlet接口的五个方法" class="headerlink" title="Servlet接口的五个方法"></a>Servlet接口的五个方法</h3><p>核心方法是init()、service()、destroy()，另外两个方法getServletInfo()和getServletConfig()使用的不是很多，了解即可</p><table><thead><tr><th>方法</th><th>简介</th></tr></thead><tbody><tr><td><code>init()</code></td><td><code>初始化方法</code>，在Servlet被创建时执行，只执行一次</td></tr><tr><td>getServletConfig()</td><td>获取ServletConfig对象</td></tr><tr><td><code>service()</code></td><td><code>服务方法</code>，每次客户端发送请求，Servlet被访问都会调用该方法</td></tr><tr><td>getServletInfo()</td><td>该方法用来返回Servlet的相关信息，没有什么太大的用处，一般返回一个空字符串即可</td></tr><tr><td><code>destroy()</code></td><td><code>销毁方法</code>，当Servlet被销毁时，调用该方法。在内存释放或服务器关闭时销毁Servlet，只调用一次</td></tr></tbody></table><h3 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h3><p>生命周期：指一个对象从被创建到被销毁的整个过程，对应Servlet中的三个方法：init()、service()、destroy()</p><table><thead><tr><th>生命周期</th><th>简介</th></tr></thead><tbody><tr><td>加载和实例化（实例化）</td><td>默认情况下，当Servlet第一次被访问时，Servlet调用构造方法（构造器）进行实例化</td></tr><tr><td>初始化（初始化）</td><td>在Servlet实例化之后，容器将调用Servlet的<code>init()</code>方法初始化这个对象<br>init()方法仅调用一次，用来加载配置文件、创建连接等初始化的工作</td></tr><tr><td>请求处理（服务）</td><td>每次请求Servlet时，Servlet容器都会调用Servlet的<code>service()</code>方法对请求进行处理<br>service()方法访问一次就会调用一次</td></tr><tr><td>服务终止（销毁）</td><td>当需要释放内存或者容器关闭时，容器就会调用Servlet实例的<code>destroy()</code>方法完成资源的释放<br>destroy()方法仅调用一次</td></tr></tbody></table><h3 id="Servlet的初始化时机"><a href="#Servlet的初始化时机" class="headerlink" title="Servlet的初始化时机"></a>Servlet的初始化时机</h3><p>（1）Servlet的初始化时机默认是第一次接收请求时实例化、初始化，之后每次请求都会调用服务，直到销毁，如果创建Servlet比较耗时的话，那么第一个访问的人等待的时间就比较长，用户的体验就比较差</p><p>（2）可以设置初始化时机，解决这个问题</p><p>在web.xml中，设置初始化时机（xml方式）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定servlet被创建的时机，设为负数则在第一次访问时创建、0或正数则在servlet加载进servlet容器时创建，且越小先被创建 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用@WebServlet注解中的loadOnstartup属性设置初始化时机（注解方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定servlet被创建的时机，设为负数则在第一次访问时创建、0或正数则在servlet加载进servlet容器时创建，且越小先被创建</span></span><br><span class="line"><span class="meta">@WebServlet(loadOnStartup = 1)</span></span><br></pre></td></tr></table></figure><h3 id="Servlet注解开发"><a href="#Servlet注解开发" class="headerlink" title="Servlet注解开发"></a>Servlet注解开发</h3><p>Servlet的配置是从3.0版本后开始支持注解配置（@WebServlet），3.0版本前只支持XML配置文件的配置方法，XML配置方式和注解比起来，麻烦很多，了解即可，建议使用注解来开发</p><table><thead><tr><th>@WebServlet注解中的属性</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>指定Servlet 的 name 属性，等价于 <code>&lt;servlet-name&gt;</code>。<br>如果没有显式指定，则该 Servlet 的取值即为类的全限定名</td></tr><tr><td>value</td><td>该属性等价于 urlPatterns 属性。两个属性不能同时使用。</td></tr><tr><td>urlPatterns</td><td>指定一组 Servlet 的 URL 匹配模式。等价于<code>&lt;url-pattern&gt;</code>标签。</td></tr><tr><td>loadOnStartup</td><td>指定 Servlet 的加载顺序，等价于 <code>&lt;load-on-startup&gt;</code>标签。<br>设为负数则在第一次访问时创建、0或正数则在servlet加载进servlet容器时创建，且越小先被创建</td></tr><tr><td>initParams</td><td>指定一组 Servlet 初始化参数，等价于<code>&lt;init-param&gt;</code>标签。</td></tr><tr><td>asyncSupported</td><td>声明 Servlet 是否支持异步操作模式，等价于<code>&lt;async-supported&gt;</code> 标签。</td></tr><tr><td>description</td><td>该 Servlet 的描述信息，等价于 <code>&lt;description&gt;</code>标签。</td></tr><tr><td>displayName</td><td>该 Servlet 的显示名，通常配合工具使用，等价于 <code>&lt;display-name&gt;</code>标签。</td></tr></tbody></table><p>（1）使用Maven创建Web项目，pom文件导入Servlet依赖坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>    </span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">          此处为什么需要添加provided标签?</span></span><br><span class="line"><span class="comment">          provided指的是在编译和测试过程中有效,最后生成的war包时不会加入</span></span><br><span class="line"><span class="comment">          因为Tomcat的lib目录中已经有servlet-api这个jar包，</span></span><br><span class="line"><span class="comment">          如果在生成war包的时候生效就会和Tomcat中的jar包冲突，导致报错</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）定义一个类，实现Servlet接口，并重写接口中所有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加loadOnStartup属性并修改为0或者正整数，则会在服务器启动的时候调用init()方法</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/ServletTest&quot;,loadOnStartup = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletTest</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span> &#123;</span><br><span class="line">    <span class="comment">// init()方法：初始化方法，在Servlet被创建时执行，只执行一次</span></span><br><span class="line">    <span class="comment">// init()方法调用时机：默认情况下，Servlet被第一次访问时调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getServletConfig()：获取ServletConfig对象</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//service()方法：提供服务方法，每次Servlet被访问，都会调用该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;servlet hello world&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getServletInfo()：用来返回Servlet的相关信息，没有什么太大的用处，一般我们返回一个空字符串即可</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getServletInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//destroy()：当Servlet被销毁时，调用该方法。在内存释放或服务器关闭时销毁Servlet，只调用一次</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）启动Tomcat，浏览器中输入URL地址访问该Servlet</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//</span>localhost:<span class="number">8080</span><span class="regexp">//</span>项目名称/@WebServlet注解路径</span><br></pre></td></tr></table></figure><h2 id="过滤器（Filter）"><a href="#过滤器（Filter）" class="headerlink" title="过滤器（Filter）"></a>过滤器（Filter）</h2><h3 id="过滤器简介"><a href="#过滤器简介" class="headerlink" title="过滤器简介"></a>过滤器简介</h3><p>过滤器（Filter）用于对请求和响应进行预处理和后处理。当客户端发送请求时，过滤器会先执行，然后再将请求传递给目标Servlet进行处理。同样，在目标Servlet处理完请求后，过滤器还可以对响应进行处理，最后将响应返回给客户端。</p><h3 id="过滤器三要素"><a href="#过滤器三要素" class="headerlink" title="过滤器三要素"></a>过滤器三要素</h3><table><thead><tr><th>三要素</th><th>简介</th></tr></thead><tbody><tr><td>拦截</td><td>过滤器之所以能够对请求进行预处理，关键是对请求进行拦截，把请求拦截下来才能够做后续的操作。 而且对于一个具体的过滤器，它必须明确它要拦截的请求，而不是所有请求都拦截。</td></tr><tr><td>过滤</td><td>根据业务功能实际的需求，看看在把请求拦截到之后，需要做什么检查或什么操作，写对应的代码即可。</td></tr><tr><td>放行</td><td>过滤器完成自己的任务或者是检测到当前请求符合过滤规则，那么可以将请求放行。 所谓放行，就是让请求继续去访问它原本要访问的资源。</td></tr></tbody></table><h3 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h3><p>（1）多个Filter的拦截范围如果存在重合部分，那么这些Filter会形成Filter链。</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/JavaWeb/过滤器链.png" style="zoom:50%"><p>（2）过滤器链执行顺序</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、浏览器请求重合部分对应的目标资源时，会依次经过<span class="keyword">Filter</span>链中的每一个<span class="keyword">Filter</span>。</span><br><span class="line"><span class="number">2</span>、如果采取的是注解的方式进行配置，那么过滤器链的拦截顺序是按照全类名的先后顺序排序的</span><br><span class="line"><span class="number">3</span>、如果采取的是<span class="type">xml</span>的方式进行配置，那么按照配置的<span class="keyword">filter</span>-<span class="keyword">mapping</span>先后顺序进行排序</span><br></pre></td></tr></table></figure><h3 id="过滤器生命周期"><a href="#过滤器生命周期" class="headerlink" title="过滤器生命周期"></a>过滤器生命周期</h3><table><thead><tr><th>生命周期阶段</th><th>执行时机</th><th>执行次数</th></tr></thead><tbody><tr><td>创建对象</td><td>Web应用启动时</td><td>一次</td></tr><tr><td>初始化</td><td>创建对象后</td><td>一次</td></tr><tr><td>拦截请求</td><td>接收到匹配的请求</td><td>多次</td></tr><tr><td>销毁</td><td>Web应用卸载前</td><td>一次</td></tr></tbody></table><h3 id="过滤器开发步骤"><a href="#过滤器开发步骤" class="headerlink" title="过滤器开发步骤"></a>过滤器开发步骤</h3><p>（1）定义类，实现javax.servlet.Filter接口，实现其中的三个方法：init、doFilter、destroy</p><p>（2）配置Filter，可以通过xml文件或注解配置，推荐注解</p><p>（3）在doFilter()方法中执行过滤，满足过滤条件使用 chain.doFilter(request, response);放行，如果不满足过滤条件转发或重定向请求</p><h3 id="过滤器匹配规则"><a href="#过滤器匹配规则" class="headerlink" title="过滤器匹配规则"></a>过滤器匹配规则</h3><table><thead><tr><th>规则</th><th>简介</th></tr></thead><tbody><tr><td>&#x2F;index.html</td><td><code>拦截具体的资源</code>，只有访问index.html时才会被拦截</td></tr><tr><td>&#x2F;test&#x2F;*</td><td><code>目录拦截</code>，访问&#x2F;test下的所有资源，都会被拦截</td></tr><tr><td>*.png</td><td><code>后缀名拦截</code>，访问后缀名为png的资源，都会被拦截 如果前杠后缀，星号在中间，&#x2F;<em>.png配置启动Web应用时会抛出异常 java.lang.IllegalArgumentException: Invalid &#x2F;</em>.png in filter mapping</td></tr><tr><td>&#x2F;*</td><td><code>拦截所有</code>，访问所有资源，都会被拦截</td></tr></tbody></table><h3 id="过滤器使用案例"><a href="#过滤器使用案例" class="headerlink" title="过滤器使用案例"></a>过滤器使用案例</h3><p>需求：请求参数message是否等于monster，等于则使用 chain.doFilter(request, response);放行，不等于则将请求跳转到另外一个页面</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 案例：请求参数message是否等于monster，</span></span><br><span class="line"><span class="comment"> * 等于则使用 chain.doFilter(request, response);放行，</span></span><br><span class="line"><span class="comment"> * 不等于则将请求跳转到另外一个页面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 通过注解过滤以.test结尾的路由</span></span><br><span class="line"><span class="meta">@WebFilter(urlPatterns=&quot;*.test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FilterTest</span> <span class="keyword">implements</span> <span class="title class_">Filter</span>&#123;<span class="comment">// 实现javax.servlet.Filter接口，重写init()、doFilter()、destroy()方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">// 打印一句话表明Filter执行了</span></span><br><span class="line">        System.out.println(<span class="string">&quot;过滤器执行--------------------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;message&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否满足过滤条件，请求参数是否等于monster</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;monster&quot;</span>.equals(message)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行放行-------------------------&quot;</span>);</span><br><span class="line">            <span class="comment">// 执行放行</span></span><br><span class="line">            <span class="comment">// FilterChain对象代表过滤器链，chain.doFilter(request, response)方法效果：</span></span><br><span class="line">            <span class="comment">// 将请求放行到下一个Filter，如果当前Filter已经是最后一个Filter了，那么就将请求放行到原本要访问的目标资源</span></span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有放行-------------------------&quot;</span>);</span><br><span class="line">            <span class="comment">// 跳转页面</span></span><br><span class="line">            request.getRequestDispatcher(<span class="string">&quot;/test.html&quot;</span>).forward(request, response);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监听器（Listener）"><a href="#监听器（Listener）" class="headerlink" title="监听器（Listener）"></a>监听器（Listener）</h2><h3 id="监听器简介"><a href="#监听器简介" class="headerlink" title="监听器简介"></a>监听器简介</h3><p>Listener监听器用于监听Web应用中的事件，并在事件发生时执行相应的操作。它实现了一种观察者模式，用于观察和响应特定的事件。</p><h3 id="监听器分类"><a href="#监听器分类" class="headerlink" title="监听器分类"></a>监听器分类</h3><p>（1）Servlet规范中定义了9个监听器接口，可以用来监听ServletContext、HttpSession 和 ServletRequest 对象的生命周期和属性变化事件</p><table><thead><tr><th>监听器</th><th>简介</th></tr></thead><tbody><tr><td>ServletContext监听器</td><td>监听ServletContext对象的创建与销毁、以及属性的变化</td></tr><tr><td>HttpSession监听器</td><td>监听HttpSession对象的创建与销毁、以及属性的变化</td></tr><tr><td>HttpServeltRequest监听器</td><td>监听HttpServeltRequest对象的创建与销毁、以及属性的变化</td></tr></tbody></table><p>（2）监听器Listener按照监听的事件可以分成3大类，分别为：监听对象创建和销毁的监听器、监听对象中属性变更的监听器、监听 HttpSession 中的对象状态改变的监听器</p><h3 id="监听对象创建和销毁的监听器"><a href="#监听对象创建和销毁的监听器" class="headerlink" title="监听对象创建和销毁的监听器"></a>监听对象创建和销毁的监听器</h3><table><thead><tr><th>事件源</th><th>监听器</th><th>监听器描述</th></tr></thead><tbody><tr><td>ServletContext</td><td>ServletContextListener</td><td>用于监听 ServletContext 对象的创建与销毁过程</td></tr><tr><td>HttpSession</td><td>HttpSessionListener</td><td>用于监听 HttpSession 对象的创建和销毁过程</td></tr><tr><td>ServletRequest</td><td>ServletRequestListener</td><td>用于监听 ServletRequest 对象的创建和销毁过程</td></tr></tbody></table><h3 id="监听对象中属性变更的监听器"><a href="#监听对象中属性变更的监听器" class="headerlink" title="监听对象中属性变更的监听器"></a>监听对象中属性变更的监听器</h3><table><thead><tr><th>事件源</th><th>监听器</th><th>监听器描述</th></tr></thead><tbody><tr><td>ServletContext</td><td>ServletContextAttributeListener</td><td>用于监听 ServletContext 对象的属性新增、移除和替换</td></tr><tr><td>HttpSession</td><td>HttpSessionAttributeListener</td><td>用于监听 HttpSession 对象的属性新增、移除和替换</td></tr><tr><td>HttpServletRequest</td><td>ServletRequestAttributeListener</td><td>用于监听 HttpServletRequest 对象的属性新增、移除和替换</td></tr></tbody></table><h3 id="监听HttpSession中的对象状态改变的监听器"><a href="#监听HttpSession中的对象状态改变的监听器" class="headerlink" title="监听HttpSession中的对象状态改变的监听器"></a>监听HttpSession中的对象状态改变的监听器</h3><table><thead><tr><th>监听器</th><th>简介</th></tr></thead><tbody><tr><td>HttpSessionBindingListener</td><td>用于监听 JavaBean 对象绑定到 HttpSession 对象和从 HttpSession 对象解绑的事件</td></tr><tr><td>HttpSessionActivationListener</td><td>用于监听 HttpSession 中对象活化和钝化的过程</td></tr></tbody></table><h1 id="四大作用域"><a href="#四大作用域" class="headerlink" title="四大作用域"></a>四大作用域</h1><p>JavaWeb的四大作用域为PageContext页面域、ServletRequest请求域、HttpSession会话域、ServletContext应用域（全局域）</p><table><thead><tr><th>作用域</th><th>简介</th></tr></thead><tbody><tr><td>PageContext</td><td>作用范围是整个JSP页面，是四大作用域中最小的一个；生命周期是当对JSP的请求时开始，当响应结束时销毁</td></tr><tr><td>ServletRequest</td><td>作用范围是一次请求响应范围</td></tr><tr><td>HttpSession</td><td>作用范围是一次会话</td></tr><tr><td>ServletContext</td><td>作用范围是整个Web应用，一次应用程序范围有效，全局</td></tr></tbody></table><h2 id="PageContext页面域"><a href="#PageContext页面域" class="headerlink" title="PageContext页面域"></a>PageContext页面域</h2><p>在使用的视图是JSP的时候，域对象有4个，使用Thymeleaf的时候，域对象有3个，没有pageContext</p><table><thead><tr><th>页面域</th><th>简介</th></tr></thead><tbody><tr><td>生命周期</td><td>访问jsp页面时创建，访问结束时销毁</td></tr><tr><td>作用范围</td><td>当前jsp页面</td></tr><tr><td>功能</td><td>在整个jsp页面共享数据</td></tr></tbody></table><h2 id="ServletRequest请求域"><a href="#ServletRequest请求域" class="headerlink" title="ServletRequest请求域"></a>ServletRequest请求域</h2><table><thead><tr><th>请求域</th><th>简介</th></tr></thead><tbody><tr><td>生命周期</td><td>一次请求开始时创建，结束时销毁</td></tr><tr><td>作用范围</td><td>一次请求响应范围</td></tr><tr><td>功能</td><td>在整个请求链共享数据</td></tr></tbody></table><h2 id="HttpSession会话域"><a href="#HttpSession会话域" class="headerlink" title="HttpSession会话域"></a>HttpSession会话域</h2><table><thead><tr><th>会话域</th><th>简介</th></tr></thead><tbody><tr><td>生命周期</td><td>创建、销毁（超时销毁、主动杀死）、意外身亡（服务器宕机）</td></tr><tr><td>作用范围</td><td>整个会话</td></tr><tr><td>功能</td><td>在整个会发范围内共享数据</td></tr></tbody></table><h2 id="ServletContext应用域"><a href="#ServletContext应用域" class="headerlink" title="ServletContext应用域"></a>ServletContext应用域</h2><table><thead><tr><th>应用域</th><th>简介</th></tr></thead><tbody><tr><td>生命周期</td><td>web应用启动时创建，web应用销毁时销毁</td></tr><tr><td>作用范围</td><td>整个web应用</td></tr><tr><td>功能</td><td>在整个web应用中共享数据</td></tr></tbody></table><h1 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h1><h2 id="请求（request）"><a href="#请求（request）" class="headerlink" title="请求（request）"></a>请求（request）</h2><blockquote><p>HTTP请求数据总共分为三部分内容，分别是请求行、请求头、请求体</p></blockquote><h3 id="获取请求行数据"><a href="#获取请求行数据" class="headerlink" title="获取请求行数据"></a>获取请求行数据</h3><table><thead><tr><th>方法</th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>getMethod()</td><td>获取请求的HTTP方法</td></tr><tr><td>getRequestURI()</td><td>获取请求的URI路径部分</td></tr><tr><td>getRequestURL()</td><td>获取请求的完整URL</td></tr><tr><td>getProtocol()</td><td>获取请求使用的协议</td></tr><tr><td>getScheme()</td><td>获取请求的协议</td></tr><tr><td>getQueryString()</td><td>获取请求的查询字符串部分</td></tr><tr><td>getServletPath()</td><td>获取请求的Servlet路径部分</td></tr></tbody></table><h3 id="获取请求头数据"><a href="#获取请求头数据" class="headerlink" title="获取请求头数据"></a>获取请求头数据</h3><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>getHeader(String name)</td><td>获取指定名称的请求头部的值</td></tr><tr><td>getHeaders(String name)</td><td>获取指定名称的请求头部的所有值</td></tr><tr><td>getIntHeader(String name)</td><td>获取指定名称的请求头部的整数值</td></tr><tr><td>getDateHeader(String name)</td><td>获取指定名称的请求头部的日期值</td></tr><tr><td>getContentType()</td><td>获取请求的Content-Type头部的值</td></tr><tr><td>getContentLength()</td><td>获取请求的Content-Length头部的值</td></tr></tbody></table><h3 id="获取请求参数"><a href="#获取请求参数" class="headerlink" title="获取请求参数"></a>获取请求参数</h3><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>getParameter(String name)</td><td>获取指定名称的请求参数的值（单个值）</td></tr><tr><td>getParameterValues(String name)</td><td>获取指定名称的请求参数的所有值（数组）</td></tr><tr><td>getParameterMap()</td><td>获取所有请求参数的映射（Map集合）</td></tr></tbody></table><h3 id="获取请求体数据"><a href="#获取请求体数据" class="headerlink" title="获取请求体数据"></a>获取请求体数据</h3><table><thead><tr><th>方法</th><th>简介</th></tr></thead><tbody><tr><td>getInputStream()</td><td>获取字节输入流，如果前端发送的是字节数据，比如传递的是文件数据，则使用该方法</td></tr><tr><td>getReader()</td><td>获取字符输入流，如果前端发送的是纯文本数据，则使用该方法</td></tr></tbody></table><h3 id="获取Cookie"><a href="#获取Cookie" class="headerlink" title="获取Cookie"></a>获取Cookie</h3><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>getCookies()</td><td>获取请求中的所有Cookie</td></tr></tbody></table><h3 id="获取远程地址"><a href="#获取远程地址" class="headerlink" title="获取远程地址"></a>获取远程地址</h3><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>getRemoteAddr()</td><td>获取客户端的IP地址</td></tr><tr><td>getRemoteHost()</td><td>获取客户端的主机名</td></tr><tr><td>getRemotePort()</td><td>获取客户端的连接端口</td></tr><tr><td>getRemoteUser()</td><td>获取客户端的用户名（如果有认证）</td></tr></tbody></table><h3 id="获取会话"><a href="#获取会话" class="headerlink" title="获取会话"></a>获取会话</h3><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>getSession(boolean create)</td><td>获取会话对象，如果不存在是否创建</td></tr><tr><td>getSession()</td><td>获取会话对象，如果不存在则创建一个新的会话</td></tr></tbody></table><h3 id="获取认证"><a href="#获取认证" class="headerlink" title="获取认证"></a>获取认证</h3><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>getUserPrincipal()</td><td>获取请求的用户主体（已认证的用户）</td></tr><tr><td>isUserInRole(String role)</td><td>检查请求的用户是否具有指定角色</td></tr></tbody></table><h3 id="获取其他"><a href="#获取其他" class="headerlink" title="获取其他"></a>获取其他</h3><table><thead><tr><th><strong>方法</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>getLocale()</td><td>获取请求的语言环境</td></tr><tr><td>getLocales()</td><td>获取请求支持的所有语言环境</td></tr></tbody></table><h3 id="request请求域"><a href="#request请求域" class="headerlink" title="request请求域"></a>request请求域</h3><table><thead><tr><th>方法</th><th>简介</th></tr></thead><tbody><tr><td>setAttribute(String name,Object value);</td><td>存（怎么向ServletContext请求域中存数据）</td></tr><tr><td>getAttribute(String name);</td><td>取（怎么从ServletContext请求域中取数据）</td></tr><tr><td>removeAttribute(String name);</td><td>删（怎么删除ServletContext请求域中的数据）</td></tr></tbody></table><h3 id="请求转发相关方法"><a href="#请求转发相关方法" class="headerlink" title="请求转发相关方法"></a>请求转发相关方法</h3><table><thead><tr><th>方法</th><th>简介</th></tr></thead><tbody><tr><td>getRequestDispatcher(String path)</td><td>根据转发的资源路径path得到转发器RequestDispatcher</td></tr></tbody></table><h2 id="响应（response）"><a href="#响应（response）" class="headerlink" title="响应（response）"></a>响应（response）</h2><p>响应消息就是服务器响应给客户端的消息内容， 也叫做响应报文，主要由响应行、响应头部和响应体3个部分组成</p><h3 id="设置响应头"><a href="#设置响应头" class="headerlink" title="设置响应头"></a>设置响应头</h3><table><thead><tr><th>方法</th><th>简介</th></tr></thead><tbody><tr><td>addHeader(String name, String value)</td><td>设置HTTP响应头字段，name指定字段名称，value指定字段值，可以增加同名的响应头字段</td></tr><tr><td>setHeader(String name, String value)</td><td>设置HTTP响应头字段，name指定字段名称，value指定字段值，会覆盖同名的头字段</td></tr><tr><td>setContentLength(int len)</td><td>设置响应消息的实体内容的大小，单位为字节，即设置Content-Length字段的值</td></tr><tr><td>setContentType(String type)</td><td>设置Servlet输出内容的MIME类型，即设置Content-Type字段的值</td></tr><tr><td>setCharacterEncoding(String charset)</td><td>设置输出内容字符编码，即设置Content-Type字段的值，该方法优先级比setContentType的高</td></tr><tr><td>sendRedirect(String location)</td><td>Servlet请求重定向</td></tr></tbody></table><h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h3><p>通过输出流, 通过Response得到网络输出流</p><table><thead><tr><th>方法</th><th>简介</th></tr></thead><tbody><tr><td>getOutputStream()</td><td>得到响应<code>字节输出流</code>，万能流</td></tr><tr><td>getWriter()</td><td>得到响应<code>字符输出流</code>，输出字符</td></tr></tbody></table><h3 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h3><table><thead><tr><th>方法</th><th>简介</th></tr></thead><tbody><tr><td>setStatus(int sc)</td><td>设置响应消息状态码，Web服务器默认产生一个状态码为200的状态行</td></tr><tr><td>sendError(int sc)</td><td>发送表示错误信息的状态码</td></tr><tr><td>sendError(int sc, String msg)</td><td>发送表示错误信息的状态码和错误提示信息</td></tr></tbody></table><h3 id="Response响应字符数据案例"><a href="#Response响应字符数据案例" class="headerlink" title="Response响应字符数据案例"></a>Response响应字符数据案例</h3><p>创建一个类响应字符数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/response&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseTest</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//设置响应的数据格式及数据的编码（设置后可以不设置content-type）</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//获取字符输出流</span></span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">        <span class="comment">//设置content-type，告诉浏览器返回的数据类型是HTML类型数据，这样浏览器才会解析HTML标签</span></span><br><span class="line">        <span class="comment">//response.setHeader(&quot;content-type&quot;,&quot;text/html&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过字符输出流写数据</span></span><br><span class="line">        writer.write(<span class="string">&quot;你好，response&quot;</span>);</span><br><span class="line">        writer.write(<span class="string">&quot;&lt;h1&gt;你好，response&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//细节：流不需要关闭</span></span><br><span class="line">        <span class="comment">//一次请求响应结束后，response对象就会被销毁掉，所以不要手动关闭流。</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Response响应字节数据案例"><a href="#Response响应字节数据案例" class="headerlink" title="Response响应字节数据案例"></a>Response响应字节数据案例</h3><p>（1）pom.xml添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 处理IO的工具类包 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/response&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseTest</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1. 读取文件</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;E:\\图片、视频、音乐\\图片\\静态图片\\1.png&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 获取response字节输出流</span></span><br><span class="line">        <span class="type">ServletOutputStream</span> <span class="variable">os</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3. 完成流的复制（copy）</span></span><br><span class="line">        <span class="comment">//byte[] buff = new byte[1024];</span></span><br><span class="line">        <span class="comment">//int len = 0;</span></span><br><span class="line">        <span class="comment">//while ((len = fis.read(buff)) != -1) &#123;</span></span><br><span class="line">        <span class="comment">//    os.write(buff, 0, len);</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        <span class="comment">//使用工具类，简化流的复制（copy）</span></span><br><span class="line">        IOUtils.copy(fis,os);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.关闭流</span></span><br><span class="line">        fis.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="请求转发与重定向"><a href="#请求转发与重定向" class="headerlink" title="请求转发与重定向"></a>请求转发与重定向</h1><table><thead><tr><th>转发与重定向</th><th>简介</th></tr></thead><tbody><tr><td>请求转发</td><td>一次请求，一次响应，浏览器地址不发生变化，参数不会丢失，只能访问内部资源，由于只创建了一次客户端和服务器的链接，相对而言转发会比较节省网络资源</td></tr><tr><td>请求重定向</td><td>二次请求，二次响应，浏览器地址发生变化，参数会丢失，可以定向到任何资源</td></tr></tbody></table><h2 id="请求转发（forward）"><a href="#请求转发（forward）" class="headerlink" title="请求转发（forward）"></a>请求转发（forward）</h2><p>请求转发是一种在服务器内部的资源跳转方式，本质是转交，在请求的处理过程中，Servlet完成了自己的任务，需要把请求转交给下一个资源继续处理</p><h3 id="请求转发的流程"><a href="#请求转发的流程" class="headerlink" title="请求转发的流程"></a>请求转发的流程</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/JavaWeb/请求转发.png" style="zoom:50%"><p>（1）浏览器发送请求给服务器，服务器中对应的资源A接收到请求<br>（2）资源A处理完请求后将请求发给资源B<br>（3）资源B处理完后将结果响应给浏览器<br>（4）请求从资源A到资源B的过程就叫请求转发</p><h3 id="请求转发的特点"><a href="#请求转发的特点" class="headerlink" title="请求转发的特点"></a>请求转发的特点</h3><ol><li>浏览器地址栏路径不发生变化，且只能转发到当前服务器的内部资源，不能从一个服务器通过转发访问另一台服务器</li><li>一次请求响应的过程，对于客户端而言，内部经过了多少次转发，客户端是不知道的</li></ol><h3 id="请求转发的实现方式"><a href="#请求转发的实现方式" class="headerlink" title="请求转发的实现方式"></a>请求转发的实现方式</h3><table><thead><tr><th>方法</th><th>简介</th></tr></thead><tbody><tr><td>request.getRequestDispatcher(“资源B路径”).forward(request,response);</td><td>将请求转发到B路径</td></tr></tbody></table><h3 id="请求转发的案例"><a href="#请求转发的案例" class="headerlink" title="请求转发的案例"></a>请求转发的案例</h3><p>（1）创建一个类，将数据存入request域对象中，然后转发</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加loadOnStartup属性并修改为0或者正整数，则会在服务器启动的时候调用init()方法</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/Servlet_5_请求转发&quot;, loadOnStartup = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletA</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;获取请求...&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印request</span></span><br><span class="line">        System.out.println(request);</span><br><span class="line">        <span class="comment">// 存储数据到request域中（范围,数据是存储在request对象）</span></span><br><span class="line">        request.setAttribute(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">        <span class="comment">// 将请求转发到指定路径</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">&quot;/ServletB&quot;</span>).forward(request,response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）创建另一个类，接收转发并从request域对象中获取数据，并将数据打印到控制台</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加loadOnStartup属性并修改为0或者正整数，则会在服务器启动的时候调用init()方法</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/ServletB&quot;, loadOnStartup = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletB</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求已经被转发...&quot;</span>);</span><br><span class="line">        <span class="comment">//再次打印request</span></span><br><span class="line">        System.out.println(request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据key获取value值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">msg</span> <span class="operator">=</span> request.getAttribute(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取转发的数据:&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）启动Tomcat，访问<code>http://localhost:8080/ServletA</code> ，路径没有变化，控制台打印如下</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">获取请求...</span><br><span class="line">org<span class="selector-class">.apache</span><span class="selector-class">.catalina</span><span class="selector-class">.connector</span>.RequestFacade@<span class="number">68</span>b412fb</span><br><span class="line">请求已经被转发...</span><br><span class="line">org<span class="selector-class">.apache</span><span class="selector-class">.catalina</span><span class="selector-class">.core</span>.ApplicationHttpRequest@<span class="number">432</span>fbf29</span><br><span class="line">获取转发的数据:hello world</span><br></pre></td></tr></table></figure><h2 id="请求重定向（redirect）"><a href="#请求重定向（redirect）" class="headerlink" title="请求重定向（redirect）"></a>请求重定向（redirect）</h2><p>Response重定向是一种资源跳转方式，本质是一种特殊的响应，在请求的处理过程中，Servlet完成了自己的任务，然后以一个响应的方式告诉浏览器：“要完成这个任务还需要你另外再访问下一个资源”</p><h3 id="请求重定向的流程"><a href="#请求重定向的流程" class="headerlink" title="请求重定向的流程"></a>请求重定向的流程</h3><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/JavaWeb/请求重定向.png" style="zoom:50%"><p>（1）浏览器发送请求给服务器，服务器中对应的资源A接收到请求<br>（2）资源A现在无法处理该请求，就会给浏览器响应一个302的状态码+location的一个访问资源B的路径<br>（3）浏览器接收到响应状态码为302就会重新发送请求到location对应的访问地址去访问资源B<br>（4）资源B接收到请求后进行处理并最终给浏览器响应结果，这整个过程就叫重定向</p><h3 id="请求重定向的特点"><a href="#请求重定向的特点" class="headerlink" title="请求重定向的特点"></a>请求重定向的特点</h3><p>（1）浏览器地址栏路径发生变化，客户端可以知道请求URL有变化，当进行重定向访问的时候，由于是由浏览器发送的两次请求，所以地址会发生变化</p><p>（2）可以重定向到任何位置的资源(服务内容、外部均可)，因为第一次响应结果中包含了浏览器下次要跳转的路径，所以这个路径是可以任意位置资源。</p><p>（3）两次请求响应的过程，不能在多个资源使用request共享数据，因为浏览器发送了两次请求，是两个不同的request对象，就无法通过request对象进行共享数据</p><h3 id="请求重定向的实现方式"><a href="#请求重定向的实现方式" class="headerlink" title="请求重定向的实现方式"></a>请求重定向的实现方式</h3><p>对于转发来说，因为是在服务端进行的，所以不需要加虚拟目录，但对于重定向，路径最终是由浏览器来发送请求，需要添加虚拟目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态获取虚拟目录（项目根路径）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> request.getContextPath();</span><br><span class="line"><span class="comment">// 设置重定向</span></span><br><span class="line">resposne.sendRedirect(contextPath+<span class="string">&quot;资源B的访问路径&quot;</span>)</span><br><span class="line"><span class="comment">// 设置状态码</span></span><br><span class="line">resposne.setStatus(<span class="number">302</span>);</span><br></pre></td></tr></table></figure><h3 id="请求重定向的案例"><a href="#请求重定向的案例" class="headerlink" title="请求重定向的案例"></a>请求重定向的案例</h3><p>（1）创建一个类设置重定向</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加loadOnStartup属性并修改为0或者正整数，则会在服务器启动的时候调用init()方法</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/ServletRedirect&quot;, loadOnStartup = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletRedirect</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;设置重定向....&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态获取虚拟目录（项目目录）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">contextPath</span> <span class="operator">=</span> request.getContextPath();</span><br><span class="line">        <span class="comment">// 设置重定向</span></span><br><span class="line">        response.sendRedirect(contextPath+<span class="string">&quot;/ServletTest&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重定向到 远方の博客</span></span><br><span class="line">        <span class="comment">// response.sendRedirect(&quot;https://wen53231323.github.io/&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）另一个类接收重定向</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加loadOnStartup属性并修改为0或者正整数，则会在服务器启动的时候调用init()方法</span></span><br><span class="line"><span class="meta">@WebServlet(urlPatterns = &quot;/ServletTest&quot;, loadOnStartup = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletTest</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Response重定向重定向成功....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）启动Tomcat，访问<code>http://localhost:8080/ServletRedirect</code>，会发现路径发生变化，重定向为<code>http://localhost:8080/ServletTest</code>，同时控制台打印如下</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置重定向....</span><br><span class="line">Response重定向重定向成功....</span><br></pre></td></tr></table></figure><h1 id="MVC与三层架构"><a href="#MVC与三层架构" class="headerlink" title="MVC与三层架构"></a>MVC与三层架构</h1><h2 id="架构思想"><a href="#架构思想" class="headerlink" title="架构思想"></a>架构思想</h2><h3 id="架构的分类"><a href="#架构的分类" class="headerlink" title="架构的分类"></a>架构的分类</h3><p>对于“架构”来讲，理论上划分了5种架构视图，分别是：逻辑架构、开发架构、运行架构、物理架构、数据架构。</p><table><thead><tr><th>分类</th><th>简介</th></tr></thead><tbody><tr><td>逻辑架构</td><td>逻辑架构关注的是功能，包含用户直接可见的功能，还有系统中隐含的功能，偏向日常所理解的“分层”，把一个项目分为“表现层、业务逻辑层、数据访问层”这样经典的“三层架构”。</td></tr><tr><td>开发架构</td><td>开发架构则更关注程序包，不仅仅是我们自己写的程序，还包括应用程序依赖的SDK、第三方类库、中间价等</td></tr><tr><td>运行架构</td><td>应用程序运行中可能出现的一些问题，例如：高并发、多线程</td></tr><tr><td>物理架构</td><td>系统、网络、服务器等基础设施</td></tr><tr><td>数据架构</td><td>数据持久化和存储层面的问题，关系型数据库与非关系型数据库的选择问题，例如：数据的分布、复制、同步等</td></tr></tbody></table><h3 id="为什么需要架构"><a href="#为什么需要架构" class="headerlink" title="为什么需要架构"></a>为什么需要架构</h3><p>（1）以前系统简单，一个应用部署在一台服务器上，且大部分开发工作是CRUD，应用结构简单，且易于维护</p><p>（2）随着系统业务复杂度越来越高，功能模块越来越庞大，耦合度也越来越高，导致系统的复杂度越来越不可控</p><p>（3）为了更好的降低应用及模块间的耦合度，诞生了一些熟知的网络架构（分布式微服务）和应用架构（三层架构、MVC架构），使用框架的好处就是结构清晰易于维护</p><h2 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h2><h3 id="MVC设计模式简介"><a href="#MVC设计模式简介" class="headerlink" title="MVC设计模式简介"></a>MVC设计模式简介</h3><p>MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分</p><ul><li><strong>模型（Model）</strong>：模型表示应用程序的数据和业务逻辑</li><li><strong>视图（View）</strong>：视图负责展示模型中的数据给用户，并接受用户的输入</li><li><strong>控制器（Controller）</strong>：控制器作为模型和视图之间的中介，处理用户的请求并协调模型和视图的交互</li></ul><h3 id="MVC的工作流程"><a href="#MVC的工作流程" class="headerlink" title="MVC的工作流程"></a>MVC的工作流程</h3><ol><li><strong>用户发送请求</strong>：用户在浏览器中输入URL或者与应用程序进行交互，发送请求给服务器。</li><li><strong>控制器接收请求</strong>：服务器接收到请求后，控制器（通常是一个Servlet）负责接收并处理请求。控制器根据请求的类型和参数，选择合适的处理方法。</li><li><strong>模型处理请求</strong>：控制器根据请求的类型和参数，调用相应的模型来处理数据。模型负责处理业务逻辑，包括数据的获取、处理、验证、存储等操作。</li><li><strong>视图展示数据</strong>：模型处理完数据之后，将处理结果返回给控制器。控制器根据处理结果选择适当的视图来展示数据。视图负责将数据渲染成可视化的界面供用户查看。</li><li><strong>用户与视图交互</strong>：用户在浏览器中与视图进行交互，例如填写表单、点击按钮等。用户的操作可能会触发新的请求。</li></ol><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/JavaWeb/MVC工作流程.png" style="zoom:50%"><h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><h3 id="三层架构的简介"><a href="#三层架构的简介" class="headerlink" title="三层架构的简介"></a>三层架构的简介</h3><p>为了符合<code>高内聚</code>，<code>低耦合</code>思想，可以把各个功能模块划分为了表示层（UI）、业务逻辑层（BLL）和数据访问层（DAL）三层架构。三层架构是一种软件设计模式，将应用程序按照功能和责任划分为三个独立的层次，每个层次都有自己的职责和功能，且彼此之间独立操作，提高了系统的可维护性、可扩展性和可测试性。通常由以下三个层级组成：</p><ul><li><strong>表示层（Presentation Layer）</strong>：表示层是系统与用户进行交互的界面部分，包括用户界面（如Web页面、移动应用界面、桌面应用界面等）和用户输入处理逻辑。主要作用是<code>将用户的请求传递给业务逻辑层，并将处理结果展示给用户</code></li><li><strong>业务逻辑层（Business Logic Layer）</strong>：业务逻辑层是应用程序的核心部分，包含了应用程序的业务规则、算法、流程等。主要作用是<code>处理来自表示层的请求，调用数据访问层提供的数据实现系统的业务逻辑</code></li><li><strong>数据访问层（Data Access Layer）</strong>：数据访问层是与数据存储系统（如数据库或文件系统）交互的部分，包括数据的存储、检索、更新等操作。主要作用是<code>与数据存储系统（如数据库或文件系统）交互进行交互，执行对数据的增删改查等操作，并将操作结果返回给业务逻辑层</code>。</li></ul><p>（2）在三层架构程序设计中，采用面向接口编程。各层之间采用接口相互访问，并通过对象模型的实体类（Model）作为数据传递的载体</p><p>（3）层是一种弱耦合结构，层与层之间的依赖是向下的，上层对下层的调用，是通过接口实现的，而真正提供服务的是下层的接口实现类。服务标准接口是相同的，而实现类是可以替换的，这样就实现了层与层间的解耦</p><h3 id="三层架构的关系"><a href="#三层架构的关系" class="headerlink" title="三层架构的关系"></a>三层架构的关系</h3><p>三层架构的关系：控制层 调用 业务层 处理业务逻辑，业务层调用 Dao 持久化数据，简单调用流程如下</p><blockquote><p>用户访问浏览器向服务端发送请求，浏览器收到响应的数据展示页面（前端页面）</p><p>​ ↓ ↑</p><p>表现层Controller接收请求，向下调用业务逻辑层Service处理业务逻辑，向上封装结果返回给客户端</p><p>​ ↓ ↑</p><p>业务层Service处理业务逻辑，向下调用数据访问层Dao操作数据，向上为表现层提供处理结果</p><p>​ ↓ ↑</p><p>数据访问层Dao向下操作数据库数据，向上为业务逻辑层提供数据</p></blockquote><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/JavaWeb/三层架构的关系.png" style="zoom:50%"><h3 id="三层架构对应的包和框架"><a href="#三层架构对应的包和框架" class="headerlink" title="三层架构对应的包和框架"></a>三层架构对应的包和框架</h3><table><thead><tr><th>三层架构</th><th>对应包</th><th>对应框架</th></tr></thead><tbody><tr><td>表现层</td><td>controller包或web包</td><td>SpringMVC、Struts2</td></tr><tr><td>业务逻辑层</td><td>service包</td><td>Spring</td></tr><tr><td>数据访问层</td><td>dao包或mapper包</td><td>Mybatis</td></tr></tbody></table><h1 id="Servlet案例回顾"><a href="#Servlet案例回顾" class="headerlink" title="Servlet案例回顾"></a>Servlet案例回顾</h1><p>JavaWeb时做的水果商店案例回顾，基础代码省略，仅保留核心思想与过程</p><h2 id="基础水果商店"><a href="#基础水果商店" class="headerlink" title="基础水果商店"></a>基础水果商店</h2><p>基础版本中，使用了多个Servlet，一个请求对应一个Servlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IndexServlet、AddServlet、EditServlet、DelServlet、UpdateServlet</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/JavaWeb/My_tool\Hexo\butterfly\source\_posts\Spring\基础版本水果商店.png"><h2 id="优化水果商店"><a href="#优化水果商店" class="headerlink" title="优化水果商店"></a>优化水果商店</h2><p>（1）由于Servlet太多，可以将多个Servlet合并成一个FruitServlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IndexServlet、AddServlet、EditServlet、DelServlet、UpdateServlet -&gt; 合并成FruitServlet</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/JavaWeb/My_tool\Hexo\butterfly\source\_posts\Spring\优化水果商店.png"><p>（2）合并成一个FruitServlet后，需要前端多传递一个operate参数与方法名对应，后端接收到operate的值是什么，表明需要调用对应的方法进行响应，如果找不到对应的方法，则抛异常。可以使用<code>switch-case</code>，通过一个operate的值来决定调用FruitServlet中的哪一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取前端传递的operate</span></span><br><span class="line"><span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line"><span class="keyword">switch</span> (operate) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;index&quot;</span>:</span><br><span class="line">        index(request, response);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>:</span><br><span class="line">        add(request, response);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;update&quot;</span>:</span><br><span class="line">        update(request, response);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;edit&quot;</span>:</span><br><span class="line">        edit(request, response);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;del&quot;</span>:</span><br><span class="line">        del(request, response);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）随着项目的业务规模扩大，会有很多的Servlet，意味着会有很多的switch-case，从而造成代码冗余，此时可以使用<code>反射技术</code>，根据方法名的对象，调用类中对应的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取前端传递的operate</span></span><br><span class="line"><span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line"><span class="comment">// 获取方法对象</span></span><br><span class="line"><span class="comment">// getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)：根据指定的方法名称和参数，匹配类中的方法，返回Method对象</span></span><br><span class="line"><span class="type">Method</span> <span class="variable">methodName</span> <span class="operator">=</span> getClass().getDeclaredMethod(operate, HttpServletRequest.class, HttpServletResponse.class);</span><br><span class="line"><span class="comment">// this表示当前类的对象，调用类中对应方法</span></span><br><span class="line">methodName.invoke(<span class="built_in">this</span>, request, response);</span><br></pre></td></tr></table></figure><h2 id="引入中央控制器DispatcherServlet"><a href="#引入中央控制器DispatcherServlet" class="headerlink" title="引入中央控制器DispatcherServlet"></a>引入中央控制器DispatcherServlet</h2><p>虽然使用了反射技术，但每一个servlet中都有类似的反射技术的代码，因此可以继续抽取，设计中央控制器类：DispatcherServlet</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/JavaWeb/My_tool\Hexo\butterfly\source\_posts\Spring\引入中央控制器类DispatcherServlet.png"><h3 id="根据url定位controller组件"><a href="#根据url定位controller组件" class="headerlink" title="根据url定位controller组件"></a>根据url定位controller组件</h3><p>（1）假设有多个xxxServlet，可以将xxxServlet改名为xxxController，可以创建一个xml文件，在bean标签中，以id属性对应方法名，class属性对应指定包下的类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 作用：将来servletpath中涉及的名字对应的是fruit，那么就要FruitController这个类来处理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;fruit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.wen.controller.FruitController&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 也可以添加其他Controller控制器，例如UserController，涉及用户的增删改查 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）创建中央控制器DispatcherServlet类，继承HttpServlet，在初始化方法init()中，通过DOM技术解析XML文件，将解析到的id和class属性对应类的实例对象存放到Map集合类型的beanMap容器中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义Map容器</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Object&gt; beanMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 获取xml配置文件中的id</span></span><br><span class="line"><span class="type">String</span> <span class="variable">beanId</span> <span class="operator">=</span> beanElement.getAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="comment">// 获取xml配置文件中的class（类的全类名）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> beanElement.getAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line"><span class="comment">// 根据 类的全类名，获取 类的实例</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">controllerBeanClass</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line"><span class="comment">// 加载的类的实例对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">beanObj</span> <span class="operator">=</span> controllerBeanClass.newInstance();</span><br><span class="line"><span class="comment">// 将 id 和 对应类的实例 保存到map集合</span></span><br><span class="line">beanMap.put(beanId, beanObj);</span><br></pre></td></tr></table></figure><p>（3）从url中提取路径servletPath，对应xml文件中的id（&#x2F;fruit.do —&gt; fruit）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得请求servlet服务的路径（/xxx.do）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">servletPath</span> <span class="operator">=</span> request.getServletPath();</span><br><span class="line"><span class="comment">// 截取/，剩下xxx.do</span></span><br><span class="line">servletPath = servletPath.substring(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 获取.do的下标，lastIndexOf()：获取下标</span></span><br><span class="line"><span class="type">int</span> <span class="variable">lastDotIndex</span> <span class="operator">=</span> servletPath.lastIndexOf(<span class="string">&quot;.do&quot;</span>);</span><br><span class="line"><span class="comment">// 获取到xxx，substring()：获取指定下标的字符</span></span><br><span class="line">servletPath = servletPath.substring(<span class="number">0</span>, lastDotIndex);</span><br></pre></td></tr></table></figure><p>（4）从beanMap容器中根据路径fruit（id）获取到对应的组件实例FruitController（class）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据路由名称（对应xml中的id），获取对应类的实例。即在Map集合中，根据key获取value</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">controllerBeanObj</span> <span class="operator">=</span> beanMap.get(servletPath);</span><br></pre></td></tr></table></figure><p>（5）通过反射，根据组件实例获取实例中的所有方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getDeclaredMethods()：返回类中（类自身）所有的实例方法，包含public、protected和private方法。</span></span><br><span class="line">Method[] methods = controllerBeanObj.getClass().getDeclaredMethods();</span><br></pre></td></tr></table></figure><p>（6）获取前端的operate的值，遍历所有的实例方法，若方法与operate相同则进行后续处理，否则抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  获取前端传递的operate（用于区分方法）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">operate</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;operate&quot;</span>);</span><br><span class="line"><span class="comment">// 循环遍历方法</span></span><br><span class="line"><span class="keyword">for</span> (Method methodName : methods) &#123;</span><br><span class="line">    <span class="comment">// 如果前端传递的参数方法 与 类中的方法一致则执行</span></span><br><span class="line">    <span class="keyword">if</span> (operate.equals(methodName.getName())) &#123;</span><br><span class="line">        ……(此处省略了调用Controller组件中的方法过程)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="调用Controller组件中的方法"><a href="#调用Controller组件中的方法" class="headerlink" title="调用Controller组件中的方法"></a>调用Controller组件中的方法</h3><p>（1）由于已经遍历了所有的方法，所以可以统一获取请求参数，并做统一处理（获取即将要调用的方法的参数信息，存放到参数数组）此处只考虑了具体逻辑，另外需要考虑参数的类型问题，详见具体代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统一获取请求参数：获取即将要调用的方法的参数签名信息，返回参数数组</span></span><br><span class="line">Parameter[] parameters = methodName.getParameters();</span><br><span class="line"></span><br><span class="line"><span class="comment">// parameterValues数组用来存放 获取到的每个参数的值</span></span><br><span class="line">Object[] parameterValues = <span class="keyword">new</span> <span class="title class_">Object</span>[parameters.length];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历参数数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 获取一个参数</span></span><br><span class="line">    <span class="type">Parameter</span> <span class="variable">parameter</span> <span class="operator">=</span> parameters[i];</span><br><span class="line">    <span class="comment">// 获取参数名</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">parameterName</span> <span class="operator">=</span> parameter.getName();</span><br><span class="line">    <span class="comment">// 获取Object型的参数值</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">parameterObj</span> <span class="operator">=</span> parameterValue;</span><br><span class="line">    <span class="comment">// 存储获取的参数</span></span><br><span class="line">    parameterValues[i] = parameterObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）执行对应的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// invoke(Object obj, Object… args)：组件中的方法调用，方法对象.invoke(对象,方法参数)</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">returnObj</span> <span class="operator">=</span> methodName.invoke(controllerBeanObj, parameterValues);</span><br></pre></td></tr></table></figure><p>（3）视图处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据执行方法的返回值，做出对应的重定向或页面定位</span></span><br><span class="line"><span class="type">String</span> <span class="variable">methodReturnStr</span> <span class="operator">=</span> (String) returnObj;</span><br><span class="line"><span class="comment">// 获取的参数是redirect:开头的（比如：redirect:fruit.do），截取redirect:（比如：剩下fruit.do）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">redirectStr</span> <span class="operator">=</span> methodReturnStr.substring(<span class="string">&quot;redirect:&quot;</span>.length());</span><br><span class="line"><span class="comment">// 重定向到对应页面</span></span><br><span class="line">response.sendRedirect(redirectStr);</span><br></pre></td></tr></table></figure><h2 id="引入IOC控制反转和DI依赖注入（工厂模式）"><a href="#引入IOC控制反转和DI依赖注入（工厂模式）" class="headerlink" title="引入IOC控制反转和DI依赖注入（工厂模式）"></a>引入IOC控制反转和DI依赖注入（工厂模式）</h2><p>由于层与层之间调用时，都需要使用new创建对象，导致层与层之间具有耦合性，可以使用IOC控制反转和DI依赖注入实现解耦</p><p>（1）创建BeanFactory接口用于根据配置文件获取bean对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据配置文件获取bean对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(String id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）让中央控制器类实现BeanFactory接口重写getBean()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> beanMap.get(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）在中央控制器的init()初始化bean工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入</span></span><br><span class="line"><span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">    <span class="comment">// 初始化bean工厂</span></span><br><span class="line">    beanFactory = <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）使用bean工厂造指定类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.getBean(xxx);</span><br></pre></td></tr></table></figure><h2 id="引入事务管理（代理模式）"><a href="#引入事务管理（代理模式）" class="headerlink" title="引入事务管理（代理模式）"></a>引入事务管理（代理模式）</h2><p>事务是逻辑上的一组操作，要么都执行，要么都不执行</p><p>（1）定义工具类，用来创建MySQL连接对象、获取MySQL连接对象、关闭MySQL连接对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工具类：创建MySQL连接对象、获取MySQL连接对象、关闭MySQL连接对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConnUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本地线程变量，用于事务控制，为每一个进程创建一个connection对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//private static ThreadLocal&lt;Object&gt; threadLocal2 = new ThreadLocal&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//private static ThreadLocal&lt;Object&gt; threadLocal3 = new ThreadLocal&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DRIVER</span> <span class="operator">=</span> <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">URL</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/fruitdb?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">USER</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PWD</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建连接对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Connection <span class="title function_">createConn</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.加载驱动</span></span><br><span class="line">            Class.forName(DRIVER);</span><br><span class="line">            <span class="comment">//2.通过驱动管理器获取连接对象</span></span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(URL, USER, PWD);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException | SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取连接对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConn</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// threadLocal.get()：获取线程本地变量的内容</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="literal">null</span>) &#123;</span><br><span class="line">            conn = createConn();</span><br><span class="line">            threadLocal.set(conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭连接对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeConn</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> threadLocal.get();</span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!conn.isClosed()) &#123;</span><br><span class="line">            conn.close();</span><br><span class="line">            <span class="comment">// threadLocal.set(null)：设置线程本地变量的内容为null</span></span><br><span class="line">            threadLocal.set(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）使用工具类实现MySQL的开启事务、提交事务、回滚事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用工具类实现MySQL的开启事务、提交事务、回滚事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">beginTrans</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        ConnUtil.getConn().setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">// 获取mysql连接对象</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ConnUtil.getConn();</span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        conn.commit();</span><br><span class="line">        ConnUtil.closeConn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回滚事务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> ConnUtil.getConn();</span><br><span class="line">        conn.rollback();</span><br><span class="line">        ConnUtil.closeConn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）定义事务过滤器，用来在将一个业务逻辑作为整体，要么都执行，要么都不执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过滤器：拦截请求，开启事务，执行放行</span></span><br><span class="line"><span class="comment"> * 若未出现错误则提交事务，若出现错误则回滚</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebFilter(&quot;*.do&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenSessionInViewFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 开启事务</span></span><br><span class="line">            TransactionManager.beginTrans();</span><br><span class="line">            System.out.println(<span class="string">&quot;开启事务....&quot;</span>);</span><br><span class="line">            <span class="comment">// 执行放行</span></span><br><span class="line">            filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">            <span class="comment">// 提交事务</span></span><br><span class="line">            TransactionManager.commit();</span><br><span class="line">            System.out.println(<span class="string">&quot;提交事务...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 回滚事务</span></span><br><span class="line">                TransactionManager.rollback();</span><br><span class="line">                System.out.println(<span class="string">&quot;回滚事务....&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ipvb.gitee.io">wen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ipvb.gitee.io/2023/01/01/JavaWeb/">https://ipvb.gitee.io/2023/01/01/JavaWeb/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ipvb.gitee.io" target="_blank">远方の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="./tags/JavaWeb/">JavaWeb</a></div><div class="post_share"><div class="social-share" data-image="./2023/01/01/JavaWeb/JavaWeb.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="./2023/01/01/Linux/" title="Linux笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/Linux/Linux.png" onerror='onerror=null,src="./img/404.png"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux笔记</div></div></a></div><div class="next-post pull-right"><a href="./2023/01/01/Vue/" title="Vue笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/Vue/Vue.png" onerror='onerror=null,src="./img/404.png"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Vue笔记</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Gitalk</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./img/%E5%A4%B4%E5%83%8F.png" onerror='this.onerror=null,this.src="./img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">wen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="./archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="./tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="./categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wen53231323"><i class="fab fa-github"></i><span>我的仓库</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">暂无</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaWeb%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">JavaWeb基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaWeb%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB"><span class="toc-number">1.1.</span> <span class="toc-text">JavaWeb技术体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.</span> <span class="toc-text">前端知识学习目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-x2F-S%E6%9E%B6%E6%9E%84%E4%B8%8EC-x2F-S%E6%9E%B6%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">B&#x2F;S架构与C&#x2F;S架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B-x2F-S%E6%9E%B6%E6%9E%84%EF%BC%88Browser-x2F-Server%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">B&#x2F;S架构（Browser&#x2F;Server）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-x2F-S%E6%9E%B6%E6%9E%84%EF%BC%88Client-x2F-Server%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">C&#x2F;S架构（Client&#x2F;Server）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%90%8E%E8%AF%B7%E6%B1%82%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">在浏览器输入网址后请求的过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Tomcat"><span class="toc-number">2.</span> <span class="toc-text">Tomcat</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84-Web-%E6%9C%8D-%E5%8A%A1-%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">常用的 Web 服 务 器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tomcat%E7%AE%80%E4%BB%8B"><span class="toc-number">2.2.</span> <span class="toc-text">Tomcat简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tomcat%E7%89%B9%E7%82%B9"><span class="toc-number">2.3.</span> <span class="toc-text">Tomcat特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tomcat%E4%BD%9C%E7%94%A8"><span class="toc-number">2.4.</span> <span class="toc-text">Tomcat作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tomcat%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.5.</span> <span class="toc-text">Tomcat目录介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IDEA%E6%B7%BB%E5%8A%A0Tomcat"><span class="toc-number">2.6.</span> <span class="toc-text">IDEA添加Tomcat</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">2.6.1.</span> <span class="toc-text">准备工作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E9%9B%86%E6%88%90%E6%9C%AC%E5%9C%B0Tomcat"><span class="toc-number">2.6.2.</span> <span class="toc-text">方式一：集成本地Tomcat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9AMaven%E6%B7%BB%E5%8A%A0Tomcat%E6%8F%92%E4%BB%B6"><span class="toc-number">2.6.3.</span> <span class="toc-text">方式二：Maven添加Tomcat插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0Tomcat%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3"><span class="toc-number">2.6.4.</span> <span class="toc-text">添加Tomcat报错解决</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaWeb%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">JavaWeb三大组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Servlet%E7%A8%8B%E5%BA%8F"><span class="toc-number">3.1.</span> <span class="toc-text">Servlet程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet%E7%AE%80%E4%BB%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">Servlet简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet%E5%AE%B9%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">3.1.2.</span> <span class="toc-text">Servlet容器简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet%E4%B8%8ETomcat%E5%85%B3%E7%B3%BB"><span class="toc-number">3.1.3.</span> <span class="toc-text">Servlet与Tomcat关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">3.1.4.</span> <span class="toc-text">Servlet继承关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BA%94%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.5.</span> <span class="toc-text">Servlet接口的五个方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.1.6.</span> <span class="toc-text">Servlet生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E6%9C%BA"><span class="toc-number">3.1.7.</span> <span class="toc-text">Servlet的初始化时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Servlet%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="toc-number">3.1.8.</span> <span class="toc-text">Servlet注解开发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%88Filter%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">过滤器（Filter）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">过滤器简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">3.2.2.</span> <span class="toc-text">过滤器三要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE"><span class="toc-number">3.2.3.</span> <span class="toc-text">过滤器链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.2.4.</span> <span class="toc-text">过滤器生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.2.5.</span> <span class="toc-text">过滤器开发步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-number">3.2.6.</span> <span class="toc-text">过滤器匹配规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">3.2.7.</span> <span class="toc-text">过滤器使用案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8%EF%BC%88Listener%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">监听器（Listener）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">3.3.1.</span> <span class="toc-text">监听器简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%99%A8%E5%88%86%E7%B1%BB"><span class="toc-number">3.3.2.</span> <span class="toc-text">监听器分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E7%9A%84%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">3.3.3.</span> <span class="toc-text">监听对象创建和销毁的监听器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%AF%B9%E8%B1%A1%E4%B8%AD%E5%B1%9E%E6%80%A7%E5%8F%98%E6%9B%B4%E7%9A%84%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">3.3.4.</span> <span class="toc-text">监听对象中属性变更的监听器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%ACHttpSession%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81%E6%94%B9%E5%8F%98%E7%9A%84%E7%9B%91%E5%90%AC%E5%99%A8"><span class="toc-number">3.3.5.</span> <span class="toc-text">监听HttpSession中的对象状态改变的监听器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E5%A4%A7%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">4.</span> <span class="toc-text">四大作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#PageContext%E9%A1%B5%E9%9D%A2%E5%9F%9F"><span class="toc-number">4.1.</span> <span class="toc-text">PageContext页面域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ServletRequest%E8%AF%B7%E6%B1%82%E5%9F%9F"><span class="toc-number">4.2.</span> <span class="toc-text">ServletRequest请求域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HttpSession%E4%BC%9A%E8%AF%9D%E5%9F%9F"><span class="toc-number">4.3.</span> <span class="toc-text">HttpSession会话域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ServletContext%E5%BA%94%E7%94%A8%E5%9F%9F"><span class="toc-number">4.4.</span> <span class="toc-text">ServletContext应用域</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94"><span class="toc-number">5.</span> <span class="toc-text">请求与响应</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%EF%BC%88request%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">请求（request）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E8%A1%8C%E6%95%B0%E6%8D%AE"><span class="toc-number">5.1.1.</span> <span class="toc-text">获取请求行数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%95%B0%E6%8D%AE"><span class="toc-number">5.1.2.</span> <span class="toc-text">获取请求头数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"><span class="toc-number">5.1.3.</span> <span class="toc-text">获取请求参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E4%BD%93%E6%95%B0%E6%8D%AE"><span class="toc-number">5.1.4.</span> <span class="toc-text">获取请求体数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Cookie"><span class="toc-number">5.1.5.</span> <span class="toc-text">获取Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%9C%E7%A8%8B%E5%9C%B0%E5%9D%80"><span class="toc-number">5.1.6.</span> <span class="toc-text">获取远程地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%BC%9A%E8%AF%9D"><span class="toc-number">5.1.7.</span> <span class="toc-text">获取会话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%AE%A4%E8%AF%81"><span class="toc-number">5.1.8.</span> <span class="toc-text">获取认证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%85%B6%E4%BB%96"><span class="toc-number">5.1.9.</span> <span class="toc-text">获取其他</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#request%E8%AF%B7%E6%B1%82%E5%9F%9F"><span class="toc-number">5.1.10.</span> <span class="toc-text">request请求域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.11.</span> <span class="toc-text">请求转发相关方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%EF%BC%88response%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">响应（response）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-number">5.2.1.</span> <span class="toc-text">设置响应头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E4%BD%93"><span class="toc-number">5.2.2.</span> <span class="toc-text">响应体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">5.2.3.</span> <span class="toc-text">响应状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Response%E5%93%8D%E5%BA%94%E5%AD%97%E7%AC%A6%E6%95%B0%E6%8D%AE%E6%A1%88%E4%BE%8B"><span class="toc-number">5.2.4.</span> <span class="toc-text">Response响应字符数据案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Response%E5%93%8D%E5%BA%94%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE%E6%A1%88%E4%BE%8B"><span class="toc-number">5.2.5.</span> <span class="toc-text">Response响应字节数据案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-number">6.</span> <span class="toc-text">请求转发与重定向</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%EF%BC%88forward%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">请求转发（forward）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">6.1.1.</span> <span class="toc-text">请求转发的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">6.1.2.</span> <span class="toc-text">请求转发的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">6.1.3.</span> <span class="toc-text">请求转发的实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="toc-number">6.1.4.</span> <span class="toc-text">请求转发的案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%87%8D%E5%AE%9A%E5%90%91%EF%BC%88redirect%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">请求重定向（redirect）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">6.2.1.</span> <span class="toc-text">请求重定向的流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">6.2.2.</span> <span class="toc-text">请求重定向的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">6.2.3.</span> <span class="toc-text">请求重定向的实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="toc-number">6.2.4.</span> <span class="toc-text">请求重定向的案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MVC%E4%B8%8E%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="toc-number">7.</span> <span class="toc-text">MVC与三层架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E6%80%9D%E6%83%B3"><span class="toc-number">7.1.</span> <span class="toc-text">架构思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">7.1.1.</span> <span class="toc-text">架构的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%9E%B6%E6%9E%84"><span class="toc-number">7.1.2.</span> <span class="toc-text">为什么需要架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVC%E6%9E%B6%E6%9E%84"><span class="toc-number">7.2.</span> <span class="toc-text">MVC架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AE%80%E4%BB%8B"><span class="toc-number">7.2.1.</span> <span class="toc-text">MVC设计模式简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">7.2.2.</span> <span class="toc-text">MVC的工作流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84"><span class="toc-number">7.3.</span> <span class="toc-text">三层架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">7.3.1.</span> <span class="toc-text">三层架构的简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.3.2.</span> <span class="toc-text">三层架构的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E5%92%8C%E6%A1%86%E6%9E%B6"><span class="toc-number">7.3.3.</span> <span class="toc-text">三层架构对应的包和框架</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Servlet%E6%A1%88%E4%BE%8B%E5%9B%9E%E9%A1%BE"><span class="toc-number">8.</span> <span class="toc-text">Servlet案例回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%B0%B4%E6%9E%9C%E5%95%86%E5%BA%97"><span class="toc-number">8.1.</span> <span class="toc-text">基础水果商店</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%B0%B4%E6%9E%9C%E5%95%86%E5%BA%97"><span class="toc-number">8.2.</span> <span class="toc-text">优化水果商店</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E4%B8%AD%E5%A4%AE%E6%8E%A7%E5%88%B6%E5%99%A8DispatcherServlet"><span class="toc-number">8.3.</span> <span class="toc-text">引入中央控制器DispatcherServlet</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AEurl%E5%AE%9A%E4%BD%8Dcontroller%E7%BB%84%E4%BB%B6"><span class="toc-number">8.3.1.</span> <span class="toc-text">根据url定位controller组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8Controller%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">8.3.2.</span> <span class="toc-text">调用Controller组件中的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E5%92%8CDI%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%EF%BC%88%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">8.4.</span> <span class="toc-text">引入IOC控制反转和DI依赖注入（工厂模式）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%EF%BC%88%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">8.5.</span> <span class="toc-text">引入事务管理（代理模式）</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="./2023/01/01/CSS/" title="CSS笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/CSS/CSS.png" onerror='this.onerror=null,this.src="./img/404.png"' alt="CSS笔记"></a><div class="content"><a class="title" href="./2023/01/01/CSS/" title="CSS笔记">CSS笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="./2023/01/01/HTML/" title="HTML笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/HTML/HTML.png" onerror='this.onerror=null,this.src="./img/404.png"' alt="HTML笔记"></a><div class="content"><a class="title" href="./2023/01/01/HTML/" title="HTML笔记">HTML笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="./2023/01/01/JavaScript/" title="JavaScript笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/JavaScript/JavaScript.png" onerror='this.onerror=null,this.src="./img/404.png"' alt="JavaScript笔记"></a><div class="content"><a class="title" href="./2023/01/01/JavaScript/" title="JavaScript笔记">JavaScript笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="./2023/01/01/Linux/" title="Linux笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/Linux/Linux.png" onerror='this.onerror=null,this.src="./img/404.png"' alt="Linux笔记"></a><div class="content"><a class="title" href="./2023/01/01/Linux/" title="Linux笔记">Linux笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="./2023/01/01/JavaWeb/" title="JavaWeb笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/JavaWeb/JavaWeb.png" onerror='this.onerror=null,this.src="./img/404.png"' alt="JavaWeb笔记"></a><div class="content"><a class="title" href="./2023/01/01/JavaWeb/" title="JavaWeb笔记">JavaWeb笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By wen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="./js/utils.js"></script><script src="./js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '701b8bc001a40a760558',
      clientSecret: 'a51b436adc471c3949a8f41be05c2d58cccab10a',
      repo: 'Hexo-Butterfly-Comment',
      owner: 'wen53231323',
      admin: ['wen53231323'],
      id: '94f02a1beb73ba78900a0e0945ae7826',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'VI32wmbmMoxvlhpTpoDBNeOk-MdYXbMMI',
      appKey: 'oFstfBFkCQIkjuk4ibCpbGqz',
      avatar: 'monsterid',
      serverURLs: 'https://vi32wmbm.api.lncldglobal.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Gitalk' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="./js/search/local-search.js"></script></div></div></body></html>