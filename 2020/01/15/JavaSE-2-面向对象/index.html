<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>JavaSE笔记-面向对象 | 远方の博客</title><meta name="author" content="wen"><meta name="copyright" content="wen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="面向对象 Java是一门面向对象设计的语言，对 Java语言来说，一切皆是对象。  面向过程思想什么是过程？过程是指一系列的操作步骤或算法，每个步骤按照特定的顺序执行，直至达到预期的结果。比如现在要制作一杯咖啡，可以将制作咖啡的过程进行分解  研磨咖啡豆：将咖啡豆研磨成粉末状。 加水：将适量的水倒入咖啡壶中。 冲泡咖啡：将咖啡粉末放入滤网中，然后将滤网放入咖啡壶中，倒入热水冲泡。 倒出咖啡：将冲泡"><meta property="og:type" content="article"><meta property="og:title" content="JavaSE笔记-面向对象"><meta property="og:url" content="https://ipvb.gitee.io/blog/2020/01/15/JavaSE-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/index.html"><meta property="og:site_name" content="远方の博客"><meta property="og:description" content="面向对象 Java是一门面向对象设计的语言，对 Java语言来说，一切皆是对象。  面向过程思想什么是过程？过程是指一系列的操作步骤或算法，每个步骤按照特定的顺序执行，直至达到预期的结果。比如现在要制作一杯咖啡，可以将制作咖啡的过程进行分解  研磨咖啡豆：将咖啡豆研磨成粉末状。 加水：将适量的水倒入咖啡壶中。 冲泡咖啡：将咖啡粉末放入滤网中，然后将滤网放入咖啡壶中，倒入热水冲泡。 倒出咖啡：将冲泡"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ipvb.gitee.io/blog/2020/01/15/JavaSE-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/Java.png"><meta property="article:published_time" content="2020-01-14T16:00:00.000Z"><meta property="article:modified_time" content="2023-08-15T10:30:17.468Z"><meta property="article:author" content="wen"><meta property="article:tag" content="JavaSE"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://ipvb.gitee.io/blog/2020/01/15/JavaSE-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/Java.png"><link rel="shortcut icon" href="/blog/img/favicon.png"><link rel="canonical" href="https://ipvb.gitee.io/blog/2020/01/15/JavaSE-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//static.cloudflareinsights.com"><link rel="preconnect" href="//www.clarity.ms"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?[object Object]";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=[object Object]"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","[object Object]")</script><script defer data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;[object Object]&quot;}"></script><script>!function(t,e,c,n,a,r){t[c]=t[c]||function(){(t[c].q=t[c].q||[]).push(arguments)},(a=e.createElement(n)).async=1,a.src="https://www.clarity.ms/tag/[object Object]",(r=e.getElementsByTagName(n)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><script>const GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: {"path":"/blog/search.xml","preload":true,"top_n_per_article":5,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"JavaSE笔记-面向对象",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-08-15 18:30:17"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/img/%E5%A4%B4%E5%83%8F.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/picture/"><i class="fa-fw fas fa-images"></i><span> 图片库</span></a></li><li><a class="site-page child" href="/blog/music/"><i class="fa-fw fas fa-music"></i><span> 音乐库</span></a></li><li><a class="site-page child" href="/blog/movies/"><i class="fa-fw fas fa-video"></i><span> 视频库</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/link/"><span>导航链接</span></a></li><li><a class="site-page child" href="/blog/comment_loading/"><span>评论管理</span></a></li><li><a class="site-page child" href="/blog/custom/"><span>自定义页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/blog/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/blog/2020/01/15/JavaSE-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/Java.png)"><nav id="nav"><span id="blog-info"><a href="/blog/" title="远方の博客"><span class="site-name">远方の博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/picture/"><i class="fa-fw fas fa-images"></i><span> 图片库</span></a></li><li><a class="site-page child" href="/blog/music/"><i class="fa-fw fas fa-music"></i><span> 音乐库</span></a></li><li><a class="site-page child" href="/blog/movies/"><i class="fa-fw fas fa-video"></i><span> 视频库</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/link/"><span>导航链接</span></a></li><li><a class="site-page child" href="/blog/comment_loading/"><span>评论管理</span></a></li><li><a class="site-page child" href="/blog/custom/"><span>自定义页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/blog/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JavaSE笔记-面向对象</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-01-14T16:00:00.000Z" title="发表于 2020-01-15 00:00:00">2020-01-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-15T10:30:17.468Z" title="更新于 2023-08-15 18:30:17">2023-08-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="JavaSE笔记-面向对象"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><blockquote><p>Java是一门面向对象设计的语言，对 Java语言来说，<code>一切皆是对象</code>。</p></blockquote><h2 id="面向过程思想"><a href="#面向过程思想" class="headerlink" title="面向过程思想"></a>面向过程思想</h2><h3 id="什么是过程？"><a href="#什么是过程？" class="headerlink" title="什么是过程？"></a>什么是过程？</h3><p><code>过程</code>是指一系列的<code>操作步骤或算法</code>，每个步骤按照特定的顺序执行，直至达到预期的结果。比如现在要制作一杯咖啡，可以将制作咖啡的过程进行分解</p><ol><li>研磨咖啡豆：将咖啡豆研磨成粉末状。</li><li>加水：将适量的水倒入咖啡壶中。</li><li>冲泡咖啡：将咖啡粉末放入滤网中，然后将滤网放入咖啡壶中，倒入热水冲泡。</li><li>倒出咖啡：将冲泡好的咖啡倒入杯子中。</li><li>加调料：根据个人口味加入糖、牛奶等调料。</li></ol><h3 id="什么是面向过程？"><a href="#什么是面向过程？" class="headerlink" title="什么是面向过程？"></a>什么是面向过程？</h3><p>面向过程是一种基于功能的编程思想，强调了<code>解决问题的步骤和流程</code>，以过程&#x2F;函数为最小单位，考虑<code>怎么做</code>。</p><p>对于一个问题，在面向过程编程中，问题会被划分为多个步骤或函数，每个步骤或函数负责完成特定的功能，函数之间通过参数传递数据进行交互，通过调用函数来实现功能。这种方式更注重解决问题的步骤和流程，将问题划分为多个子任务，并按照一定的顺序执行这些子任务来解决问题。</p><p>假如现在有一个问题：如何把大象塞进冰箱？以面向过程的思想解决问题，可能需要以下的步骤：</p><ul><li>第一步：打开冰箱门。</li><li>第二步：把大象放进冰箱。</li><li>第三步：关闭冰箱门。</li></ul><h2 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h2><h3 id="什么是对象？"><a href="#什么是对象？" class="headerlink" title="什么是对象？"></a>什么是对象？</h3><p><code>对象</code>是对现实世界中<code>具体事物或概念</code>的抽象，每个对象都有自身的<code>特征</code>和<code>行为</code>，现实世界中每一个<code>具体事物或概念</code>都可以看做是一个对象</p><ul><li>比如现实世界中的一只<code>猫</code>或者一只<code>狗</code>，他们都可以看做是一个<code>对象</code></li><li>猫或者狗一般都具有颜色、体重等等<code>特征</code>和吃饭、睡觉等<code>行为</code></li><li>把现实世界中的对象抽象地体现在编程世界中，可以定义<code>类来描述对象</code>，定义<code>属性描述特征</code>，定义<code>方法描述行为</code></li></ul><h3 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h3><p>面向对象是一种编程思想，强调了<code>具备功能的对象</code>，以类&#x2F;对象为最小单位，考虑<code>谁来做</code>。</p><p>对于一个问题，在面向对象编程中，问题会被抽象为一组相互关联的功能对象，每个对象具有属性和方法。对象之间通过消息传递进行交互，通过调用对象的方法来实现功能。这种方式更注重问题领域中的对象和它们之间的关系，对象拥有自己的状态和行为，通过协同工作来解决问题。</p><p>假如现在有一个问题：如何把大象塞进冰箱？以面向对象的思想解决问题可能需要以下的步骤：</p><ol><li>第一步：创建一个冰箱对象。冰箱对象具有方法：<code>打开门()</code>和<code>关闭门()</code>。</li><li>第二步：创建一个大象对象。大象对象具有方法：<code>移动()</code>。</li><li>第三步：调用冰箱对象的<code>打开门()</code>方法。</li><li>第四步：调用大象对象的<code>移动()</code>方法，使其进入冰箱。</li><li>第五步：调用冰箱对象的<code>关闭门()</code>方法。</li></ol><h2 id="面向对象与面向过程对比"><a href="#面向对象与面向过程对比" class="headerlink" title="面向对象与面向过程对比"></a>面向对象与面向过程对比</h2><p>面向过程性能比面向对象高，因为面向对象中类调用时需要实例化，开销比较大，比较消耗资源;</p><table><thead><tr><th>对比</th><th>面向对象程序设计</th><th>面向过程程序设计（也叫结构化编程）</th></tr></thead><tbody><tr><td>设计语言</td><td>Java、C++、C#、Python等</td><td>C、Fortran</td></tr><tr><td>特点</td><td>封装、继承、多态</td><td>算法+数据结构</td></tr><tr><td>优势</td><td>适用于大型复杂系统，方便复用</td><td>适用于简单系统，容易理解</td></tr><tr><td>劣势</td><td>比较抽象、性能比面向过程低</td><td>难以应对复杂系统，难以复用，不易维护、不易扩展</td></tr></tbody></table><h1 id="类及类的成员"><a href="#类及类的成员" class="headerlink" title="类及类的成员"></a>类及类的成员</h1><h2 id="什么是类"><a href="#什么是类" class="headerlink" title="什么是类"></a>什么是类</h2><p>类是对一类事物的描述，描述了一组具有相同特性（属性）和相同行为（方法）的集合，是构造面向对象程序的基本单位</p><h2 id="怎么创建类"><a href="#怎么创建类" class="headerlink" title="怎么创建类"></a>怎么创建类</h2><p>创建一个类，需要使用 <code>class</code> 关键字，语法格式如下（中括号<code>[]</code>中的部分可省略）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法格式</span></span><br><span class="line">[访问修饰符] class 类名 [extends 父类名] [implements 接口名]&#123; </span><br><span class="line">	类的成员（属性、方法、构造器、代码块、内部类）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>概括</th></tr></thead><tbody><tr><td>访问修饰符</td><td>对访问权限进行限定的 class的权限修饰只可以用public公共和default缺省</td></tr><tr><td>类名</td><td>首字母大写且符合标识符</td></tr><tr><td>extends</td><td>用于类的继承</td></tr><tr><td>implements</td><td>用于类实现接口</td></tr><tr><td>类的成员</td><td>属性、方法、构造器、代码块、内部类</td></tr></tbody></table><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类的成员"><a href="#类的成员" class="headerlink" title="类的成员"></a>类的成员</h2><h3 id="属性（field）"><a href="#属性（field）" class="headerlink" title="属性（field）"></a>属性（field）</h3><h4 id="类中属性的定义"><a href="#类中属性的定义" class="headerlink" title="类中属性的定义"></a>类中属性的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法格式</span></span><br><span class="line">[访问修饰符] 数据类型 属性名 = 初始化值;</span><br><span class="line"><span class="comment">// 代码示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>概括</th></tr></thead><tbody><tr><td>访问修饰符</td><td>对访问权限进行限定，常用的权限修饰符有：private、缺省、protected、public 其他修饰符：static、final</td></tr><tr><td>数据类型</td><td>任何基本数据类型(如int、boolean) 或 任何引用数据类型</td></tr><tr><td>属性名</td><td>属于标识符，符合命名规则和规范即可</td></tr></tbody></table><h4 id="成员变量和局部变量"><a href="#成员变量和局部变量" class="headerlink" title="成员变量和局部变量"></a>成员变量和局部变量</h4><p>根据类位置的不同可以将属性划分为<code>成员变量</code>和<code>局部变量</code></p><table><thead><tr><th>属性</th><th>简介</th></tr></thead><tbody><tr><td>成员变量</td><td>在方法体外，类体内声明的变量</td></tr><tr><td>局部变量</td><td>在方法体内部声明的变量</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="comment">// 成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> memberVariable;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exampleMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 局部变量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">localVariable</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;成员变量：&quot;</span> + memberVariable);</span><br><span class="line">        System.out.println(<span class="string">&quot;局部变量：&quot;</span> + localVariable);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Example</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Example</span>();</span><br><span class="line">        example.exampleMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员变量和局部变量的区别</p><table><thead><tr><th>区别</th><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr><td>声明的位置</td><td>直接声明在类中</td><td>方法形参或内部、代码块内、构造器内等</td></tr><tr><td>访问修饰符</td><td>private、public、static、final等</td><td><code>不能用权限修饰符修饰</code>，可以用final修饰</td></tr><tr><td>初始化值</td><td>有默认初始化值</td><td>没有默认初始化值，必须显式赋值，方可使用</td></tr><tr><td>内存加载位置</td><td>堆空间 或 静态域内</td><td>栈空间</td></tr></tbody></table><h3 id="方法（method）"><a href="#方法（method）" class="headerlink" title="方法（method）"></a>方法（method）</h3><h4 id="类中方法的定义"><a href="#类中方法的定义" class="headerlink" title="类中方法的定义"></a>类中方法的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法格式</span></span><br><span class="line">[访问修饰符] 返回值类型 方法名(参数类型 形参<span class="number">1</span>, 参数类型 形参<span class="number">2</span>, …) &#123;</span><br><span class="line">　　方法体</span><br><span class="line">　　<span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>概括</th></tr></thead><tbody><tr><td>修饰符</td><td>对访问权限进行限定，常用的权限修饰符有：private、缺省、protected、public</td></tr><tr><td>返回值类型</td><td>用于限定方法返回值的数据类型，与方法体中 return 返回值 搭配使用，若没有返回值使用void</td></tr><tr><td>方法名</td><td>属于标识符，命名时遵循标识符命名规则和规范</td></tr><tr><td>参数类型</td><td>限定调用方法时传入参数的数据类型</td></tr><tr><td>形参</td><td>是一个变量，用于接收调用方法时传入的数据</td></tr><tr><td>return 返回值</td><td>方法在执行完毕后返还给调用它的程序的数据。当方法的返回值类型为void时，return及其返回值可以省略</td></tr></tbody></table><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="comment">// test方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="方法的重载（Overload）"><a href="#方法的重载（Overload）" class="headerlink" title="方法的重载（Overload）"></a>方法的重载（Overload）</h4><p>在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">    <span class="comment">// 方法A</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">A</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法A的重载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">A</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法的重写（Override）"><a href="#方法的重写（Override）" class="headerlink" title="方法的重写（Override）"></a>方法的重写（Override）</h4><p>子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作。注意：<code>静态方法无法被子类重写</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        animal.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 父类中的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Cat</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// @Override注解用来帮助检查方法的正确性</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;重写了父类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法的递归（recursion）"><a href="#方法的递归（recursion）" class="headerlink" title="方法的递归（recursion）"></a>方法的递归（recursion）</h4><p>（1）递归方法：<code>一个方法体内调用它自身</code>称为递归方法</p><p>（2）方法递归包含了一种隐式的循环，会重复执行某段代码，但这种重复执行无须循环控制</p><p>（3）递归一定要向已知方向递归（有结束条件），否则这种递归就变成了无穷递归，类似于死循环，导致递归很耗费栈内存，从而发生栈内存溢出错误，递归算法可以不用的时候尽量别用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归调用未写结束条件，会报错java.lang.StackOverflowError栈内存溢出错误</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法的递归调用&quot;</span>);</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）递归案例：使用递归求1-n的和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(sum(<span class="number">100</span>));<span class="comment">// 5050</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用递归求1-n的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> n + sum(n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造器（构造方法）"><a href="#构造器（构造方法）" class="headerlink" title="构造器（构造方法）"></a>构造器（构造方法）</h3><h4 id="构造器简介"><a href="#构造器简介" class="headerlink" title="构造器简介"></a>构造器简介</h4><p>构造方法（Constructor）是一种特殊类型的方法，主要用于创建和初始化对象，具有以下特性：</p><ul><li><strong>构造方法名字与类名相同</strong>：构造方法的名称必须与类名完全相同</li><li><strong>构造方法没有返回值</strong>：构造方法没有返回类型，包括 <code>void</code>，也不需要使用 <code>return</code> 关键字。</li><li><strong>默认构造方法</strong>：如果一个类没有显式定义任何构造方法，编译器会自动提供一个默认的无参构造方法，它什么也不做。默认构造方法的访问修饰符通常为 public</li><li><strong>构造方法的重载</strong>：可以根据需要在类中定义多个构造方法，可以有不同的参数列表（参数的个数、顺序、类型不同），称为构造方法的重载。每个构造方法可以根据参数的不同来完成不同的初始化任务</li><li><strong>构造方法自动执行</strong>：当使用 <code>new</code> 关键字创建对象时，构造方法会自动执行，用于初始化新创建的对象，<code>只会执行一次</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有参构造器</span></span><br><span class="line">[访问修饰符] 类名(参数类型 形参<span class="number">1</span>, 参数类型 形参<span class="number">2</span>, …)  &#123; </span><br><span class="line">    初始化语句;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 无参构造器</span></span><br><span class="line"><span class="keyword">public</span> 类名()  &#123; </span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>概括</th></tr></thead><tbody><tr><td>访问修饰符</td><td>修饰符只有权限修饰符private、默认、protected、public<br>不能被static、final、synchronized、abstract、native修饰</td></tr><tr><td>类名</td><td>构造器名称与类名一致</td></tr><tr><td>初始化语句</td><td>用于初始化类的信息 ，不能有 return 语句返回值</td></tr></tbody></table><h4 id="构造器代码示例"><a href="#构造器代码示例" class="headerlink" title="构造器代码示例"></a>构造器代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 无参构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span>  &#123; </span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 有参构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> id, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;<span class="comment">// 构造器中调用属性</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;<span class="comment">// 构造器中调用属性</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造方法的重载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;<span class="comment">// 构造器中调用属性</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;<span class="comment">// 构造器中调用属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="代码块（初始化块）"><a href="#代码块（初始化块）" class="headerlink" title="代码块（初始化块）"></a>代码块（初始化块）</h3><h4 id="类中代码块的定义"><a href="#类中代码块的定义" class="headerlink" title="类中代码块的定义"></a>类中代码块的定义</h4><p>使用<code>&#123;&#125;</code>括起来的代码被称为代码块，常用来初始化类、对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[访问修饰符] &#123;</span><br><span class="line">    初始化语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>字段</th><th>概括</th></tr></thead><tbody><tr><td>访问修饰符</td><td>修饰符可选但只能使用static</td></tr><tr><td>初始化语句</td><td>代码块中可以写任何语句（输入，输出，方法调用，循环，判断等等）</td></tr></tbody></table><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p>使用<code>static</code>关键字修饰的称为静态代码块，其余的称为非静态代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    初始化语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态代码块与非静态代码块的区别"><a href="#静态代码块与非静态代码块的区别" class="headerlink" title="静态代码块与非静态代码块的区别"></a>静态代码块与非静态代码块的区别</h4><table><thead><tr><th>区别</th><th>静态代码块</th><th>非静态代码块</th></tr></thead><tbody><tr><td>执行时机</td><td>随着类的加载而执行，而且只执行一次</td><td>随着对象的创建而执行，每创建一个对象，就执行一次非静态代码块</td></tr><tr><td>作用</td><td>初始化类的信息</td><td>可以在创建对象时，对对象的属性等进行初始化</td></tr><tr><td>调用</td><td>只能调用静态的属性、方法，不能调用非静态的结构</td><td>可以调用静态的属性、静态的方法，非静态的属性、非静态的方法</td></tr></tbody></table><h3 id="内部类（inner-class）"><a href="#内部类（inner-class）" class="headerlink" title="内部类（inner class）"></a>内部类（inner class）</h3><h4 id="类中内部类的定义"><a href="#类中内部类的定义" class="headerlink" title="类中内部类的定义"></a>类中内部类的定义</h4><p>在类中声明的类称为内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类A为类B的外部类（outer class）</span></span><br><span class="line">[访问修饰符] class 类A&#123;</span><br><span class="line">    <span class="comment">// 类B为类A的内部类（inner class）</span></span><br><span class="line">    [访问修饰符] class 类B&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类C是类A的外部其他类（other class）</span></span><br><span class="line">class 类C&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内部的分类"><a href="#内部的分类" class="headerlink" title="内部的分类"></a>内部的分类</h4><table><thead><tr><th>内部类</th><th>简介</th></tr></thead><tbody><tr><td>成员内部类</td><td>定义在类内部的非静态类叫做成员内部类（不使用static修饰）</td></tr><tr><td>静态内部类</td><td>定义在类内部的静态类称为静态内部类（使用static修饰）</td></tr><tr><td>局部内部类</td><td>在方法中定义的内部类，有类名</td></tr><tr><td>匿名内部类</td><td>在方法中定义的内部类，无类名</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// 成员内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 局部内部类</span></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 匿名内部类</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Test</span>() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类的实例化（创建对象）"><a href="#类的实例化（创建对象）" class="headerlink" title="类的实例化（创建对象）"></a>类的实例化（创建对象）</h1><h2 id="对象的简介"><a href="#对象的简介" class="headerlink" title="对象的简介"></a>对象的简介</h2><p>（1）Java中常说的<code>创建对象</code>就是<code>对类进行实例化</code>，一般会使用 <code>new</code> 关键字创建对象（对类进行实例化）</p><p>（2）每个对象都是相互独立的，在内存中占有独立的内存地址，并且每个对象都具有自己的生命周期</p><p>（2）Java对象的生命周期包括创建、使用和清除，当对象的生命周期结束时，对象就变成了垃圾，由 Java 虚拟机自带的垃圾回收机制处理</p><p>（3）对象具有状态和行为，变量用来表明对象的状态，方法表明对象所具有的行为。</p><h2 id="对象的创建（实例化）"><a href="#对象的创建（实例化）" class="headerlink" title="对象的创建（实例化）"></a>对象的创建（实例化）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure><h2 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h2><p>使用普通方式创建对象，访问对象中的成员（属性和方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line">类名 对象名 = <span class="keyword">new</span> 类名();</span><br><span class="line"><span class="comment">// 使用对象名访问对象成员（包括属性和方法）</span></span><br><span class="line">对象名.对象成员;</span><br></pre></td></tr></table></figure><p>使用匿名对象方式（不定义对象的句柄，直接调用对象成员）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名().对象成员;</span><br></pre></td></tr></table></figure><h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><p>（1）先创建一个Person类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人可以吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人可以睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）创建对象，并访问成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 new 关键字创建对象</span></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">        <span class="comment">// 打印对象地址</span></span><br><span class="line">        System.out.println(person);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用普通方式调用成员（属性和方法）</span></span><br><span class="line">        person.age = <span class="number">1</span>;<span class="comment">// 调用成员变量</span></span><br><span class="line">        person.name = <span class="string">&quot;小明&quot;</span>;<span class="comment">// 调用成员变量</span></span><br><span class="line">        person.eat();<span class="comment">// 调用成员方法</span></span><br><span class="line">        person.sleep();<span class="comment">// 调用成员方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用匿名对象方式调用成员（属性和方法）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>().age = <span class="number">1</span>;<span class="comment">// 调用成员变量</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>().name = <span class="string">&quot;小明&quot;</span>;<span class="comment">// 调用成员变量</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>().eat();<span class="comment">// 调用成员方法</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Person</span>().sleep();<span class="comment">// 调用成员方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h1><table><thead><tr><th>特征</th><th>简介</th></tr></thead><tbody><tr><td>封装（Encapsulation）</td><td>封装是面向对象的核心思想，将对象的<code>属性和行为封装起来，不需要让外界知道具体实现细节</code></td></tr><tr><td>继承（Inheritance）</td><td>继承主要描述的就是<code>类与类之间的关系</code>，通过继承，可以在无需重新编写原有类的情况下，<code>对原有类的功能进行扩展</code></td></tr><tr><td>多态（Polymorphism）</td><td>多态指的是在一个类中定义的属性和功能被其他类继承后，当<code>把子类对象直接赋值给父类引用变量</code>时，相同引用类型的<code>变量调用同一个方法所呈现出的多种不同行为特性</code></td></tr></tbody></table><h2 id="封装性（Encapsulation）"><a href="#封装性（Encapsulation）" class="headerlink" title="封装性（Encapsulation）"></a>封装性（Encapsulation）</h2><h3 id="封装简介"><a href="#封装简介" class="headerlink" title="封装简介"></a>封装简介</h3><p>封装可以隐藏对象的实现细节，仅对外公开接口，增强了代码的安全性</p><p>封装体现在权限修饰符上：private（类访问级别）、default（包访问级别）、protected（子类访问级别）、public（公共访问级别）</p><h3 id="四种权限修饰符"><a href="#四种权限修饰符" class="headerlink" title="四种权限修饰符"></a>四种权限修饰符</h3><p>Java权限修饰符<code>public</code>、<code>protected</code>、<code>default</code>、<code>private</code>置于类的成员定义前， 用来限定对象对该类成员的访问权限。</p><table><thead><tr><th>修饰符</th><th>概括</th></tr></thead><tbody><tr><td>private</td><td><code>当前类访问级别</code>，如果类的成员被private访问控制符来修饰<br>这个成员只能被该类的其他成员访问，其他类无法直接访问 类的良好封装就是通过private关键字来实现的</td></tr><tr><td>default</td><td><code>包访问级别</code>，如果一个类或者类的成员不使用任何访问控制符修饰，则称它为默认访问控制级别<br>这个类或者类的成员只能被本包中的其他类访问</td></tr><tr><td>protected</td><td><code>子类访问级别</code>，如果一个类的成员被protected访问控制符修饰<br>这个成员既能被同一包下的其他类访问，也能被不同包下该类的子类访问</td></tr><tr><td>public</td><td><code>公共访问级别</code>，这是一个最宽松的访问控制级别，如果一个类或者类的成员被public访问控制符修饰<br>这个类或者类的成员能被所有的类访问，不管访问类与被访问类是否在同一个包中</td></tr></tbody></table><h3 id="权限修饰符访问级别"><a href="#权限修饰符访问级别" class="headerlink" title="权限修饰符访问级别"></a>权限修饰符访问级别</h3><table><thead><tr><th>修饰符</th><th>类内部</th><th>同一个包</th><th>不同包的子类</th><th>同一个工程</th></tr></thead><tbody><tr><td>private</td><td>Yes</td><td></td><td></td><td></td></tr><tr><td>default（缺省）</td><td>Yes</td><td>Yes</td><td></td><td></td></tr><tr><td>protected</td><td>Yes</td><td>Yes</td><td>Yes</td><td></td></tr><tr><td>public</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr></tbody></table><h2 id="继承性（Inheritance）"><a href="#继承性（Inheritance）" class="headerlink" title="继承性（Inheritance）"></a>继承性（Inheritance）</h2><h3 id="继承简介"><a href="#继承简介" class="headerlink" title="继承简介"></a>继承简介</h3><p>（1）继承是基于已有的类创造新的类，使用继承降低了代码编写的冗余度，便于功能的扩展，提高编程的效率，是多态性的使用的前提</p><p>（2）一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法，也可以创建自己的属性和方法</p><p>（3）Java 仅支持<code>单继承</code>，一个子类只能有一个父类，一个父类可以有多个子类，一个子类的父类的父类称为间接父类</p><p>（4）若<code>子类重写</code>了<code>父类方法</code>，就意味着<code>子类</code>里定义的<code>方法</code>彻底<code>覆盖</code>了<code>父类里的同名方法</code>，系统将不可能把父类里的方法转移到子类中</p><p>（5）<code>所有的java类(除java.lang.Object类之外)都直接或间接的继承于java.lang.Object类</code>，如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类，这就意味着所有的java类都具有java.lang.Object类中声明的功能方法</p><h3 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h3><p>在 Java 中通过 <code>extends</code> 关键字可以申明一个类是从另外一个类继承而来的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类A</span></span><br><span class="line">[访问修饰符] class 父类A&#123;</span><br><span class="line">	类的成员（属性、方法、构造器、代码块、内部类）</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类B继承父类A</span></span><br><span class="line">[访问修饰符] class 子类B extends 父类A&#123;</span><br><span class="line">	类的成员（属性、方法、构造器、代码块、内部类）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重写父类方法"><a href="#重写父类方法" class="headerlink" title="重写父类方法"></a>重写父类方法</h3><p>（1）子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        animal.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 父类中的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Cat</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// @Override注解用来帮助检查方法的正确性</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;重写了父类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）案例分析</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">上面的例子中，`animal`对象被定义为父类`Animal`类型。</span><br><span class="line"></span><br><span class="line">在编译期，编译器会检查父类`Animal`类中是否有可访问的`hello()`方法，只要其中包含`hello()`方法，那么就可以编译通过。</span><br><span class="line"></span><br><span class="line">在运行期，子类`Cat`对象被`new`出来，并赋值给`animal`变量，这时JVM是明确的知道`animal`变量指向的其实是子类`Cat`对象的引用。</span><br><span class="line"></span><br><span class="line">所以当`animal`对象调用`hello()`方法的时候，就会调用子类`Cat`类中定义的`hello()`方法。这就是所谓的动态多态性</span><br></pre></td></tr></table></figure><p>（3）重写方法的条件</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">不能重写被标示为<span class="keyword">final</span>的方法</span><br><span class="line">参数列表必须完全与被重写方法的相同</span><br><span class="line">返回类型必须完全与被重写方法的返回类型相同</span><br><span class="line">如果不能继承一个方法，则不能重写这个方法</span><br><span class="line">访问级别的限制性一定不能比被重写方法的强</span><br><span class="line">访问级别的限制性可以比被重写方法的弱</span><br><span class="line">重写方法一定不能抛出新的检查异常或比被重写的方法声明的检查异常更广泛的检查异常</span><br><span class="line">重写的方法能够抛出更少或更有限的异常（也就是说，被重写的方法声明了异常，但重写的方法可以什么也不声明）</span><br></pre></td></tr></table></figure><h2 id="多态性（Polymorphism）"><a href="#多态性（Polymorphism）" class="headerlink" title="多态性（Polymorphism）"></a>多态性（Polymorphism）</h2><h3 id="多态简介"><a href="#多态简介" class="headerlink" title="多态简介"></a>多态简介</h3><p>（1）多态可以理解为可以理解为一个事物的多种形态，在父类中定义的属性和方法被子类继承之后，可以具有不同的数据类型或表现出不同的行为，</p><p>（2）多态例子：打印机可以有黑白打印机与彩色打印机，他们都是打印机，但是打印的效果不同</p><p>（3）多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理</p><p>（4）多态性是运行时的行为，只适用于方法，不适用于属性</p><h3 id="实现多态的条件"><a href="#实现多态的条件" class="headerlink" title="实现多态的条件"></a>实现多态的条件</h3><table><thead><tr><th>条件</th><th>简介</th></tr></thead><tbody><tr><td>继承</td><td>必须要有子类继承父类的继承关系</td></tr><tr><td>重写</td><td>子类对父类中的一些方法进行重写，然后调用方法时就会调用子类重写的方法，而不是原本父类的方法</td></tr><tr><td>向上转型</td><td>父类引用指向子类对象（<code>Animal animal = new Cat();</code>）。<br>在多态中需要将子类的引用赋给父类对象，只有这样该引用才能做到，既能调用父类的方法，又能调用子类的方法</td></tr></tbody></table><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 对象的多态性：父类的引用指向子类的对象</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 多态的使用：当调用父类同名同参数的方法时，实际执行的是子类重写父类的方法（虚拟方法调用）</span></span><br><span class="line">        animal1.eat();<span class="comment">// 子类1吃饭</span></span><br><span class="line">        animal2.eat();<span class="comment">// 子类2吃饭</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象的多态性只适用于方法，不适用于属性(静态绑定)</span></span><br><span class="line">        System.out.println(animal1.id); <span class="comment">//1001</span></span><br><span class="line">        System.out.println(animal2.id); <span class="comment">//1001</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1002</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写父类方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类1吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1003</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写父类方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类2吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态绑定和动态绑定"><a href="#静态绑定和动态绑定" class="headerlink" title="静态绑定和动态绑定"></a>静态绑定和动态绑定</h3><p>（1）上面例子中等号左边的内容表示父类的引用，该引用在栈内存中，指向了一块堆中的地址，而这个地址中存放的是其子类的对象。animal是Animal类型的一个引用，指向的是其子类Cat的对象，这个就叫做<code>父类引用指向子类对象</code>。程序在编译（javac）的时候animal被看做Animal类型，所以animal.eat()绑定的是Animal类中的eat()方法，这叫做<code>静态绑定</code>，程序运行时，会在堆中开辟空间创建出对象，此时animal指向的是堆中的Cat对象，而在Cat中对eat()方法进行了重写，所以在运行阶段绑定的是Cat中的eat()方法，这叫做<code>动态绑定</code></p><p>（2）对面向对象来说，多态分为编译时多态和运行时多态。</p><table><thead><tr><th>多态</th><th>简介</th></tr></thead><tbody><tr><td>编译时多态</td><td>静态的，主要是指方法的重载，是根据参数列表的不同来区分不同的方法。<br>通过编译之后会变成两个不同的方法，在运行时谈不上多态</td></tr><tr><td>运行时多态</td><td>动态的，是通过动态绑定来实现的，也就是大家通常所说的多态性</td></tr></tbody></table><p>（3）有了对象的多态性以后，在<code>编译期</code>，<code>只能调用父类中声明的方法</code>，但在<code>运行期间</code>，<code>实际执行的是子类重写父类的方法</code>，提高了代码的通用性，常称作接口重用（<code>编译，看左边，运行，看右边</code>）</p><p>（4）代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">        <span class="comment">// 编译时，只能调用父类中声明的属性和方法, 子类特有的属性和方法不能调用</span></span><br><span class="line">        <span class="comment">// b.name;     //静态绑定</span></span><br><span class="line">        <span class="comment">// b.test();   //静态绑定</span></span><br><span class="line">        b.eat();       <span class="comment">//动态绑定，会打印子类重写父类方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如何调用子类特有的属性和方法?</span></span><br><span class="line">        <span class="comment">//向下转型，使用强制类型转换符(可能出现ClassCastException的异常)</span></span><br><span class="line">        <span class="type">B</span> <span class="variable">b1</span> <span class="operator">=</span> (B) b;</span><br><span class="line">        b1.test(); <span class="comment">// 会打印子类特有的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;父类属性&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;子类属性&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类重写父类方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类特有的方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><table><thead><tr><th>类型转换</th><th>简介</th></tr></thead><tbody><tr><td>自动类型转换</td><td>小的数据类型可以自动转换成大的数据类型</td></tr><tr><td>强制类型转换</td><td>可以把大的数据类型强制转换成小的数据类型，使用强制转换时，可能出现类型转换异常（ClassCastException）</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，</span></span><br><span class="line"><span class="comment">         * 但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法,子类特有的属性和方法不能调用</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="comment">// cat.sleep(); // 不能调用子类中特有的方法、属性,编译时，cat是父类Animal类型</span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 调用子类特有的属性和方法需要向下转型，使用强制类型转换符()</span></span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat1</span> <span class="operator">=</span> (Cat) cat;</span><br><span class="line">        cat1.sleep(); <span class="comment">// 子类睡觉</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1002</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写父类方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h3><p>会判断引用指向的对象是否是该类型的，如果是则计算结果是true，否则结果是false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  instanceof关键字的使用方式：a instanceof A</span></span><br><span class="line"><span class="comment">*  判断对象a是否是类A的实例，如果是，返回true：如果不是，返回false</span></span><br><span class="line"><span class="comment">*  使用情境：为了避免在向下转型时出现ClassCastException的异常,在向下转型之前，先进行instanceof的判断，</span></span><br><span class="line"><span class="comment">*  如果返回true就进行向下转型，如果返回false，不进行向下转型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果cat是Cat类的实例，就执行强制类型转换</span></span><br><span class="line">        <span class="keyword">if</span> (cat <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">            <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat) cat; <span class="comment">// 强制类型转换</span></span><br><span class="line">            c.sleep(); <span class="comment">// 调用子类特有方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果cat是Dog类的实例，就执行强制类型转换</span></span><br><span class="line">        <span class="keyword">if</span> (cat <span class="keyword">instanceof</span> Dog) &#123;</span><br><span class="line">            <span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> (Cat) cat; <span class="comment">// 强制类型转换</span></span><br><span class="line">            c.sleep(); <span class="comment">// 调用子类特有方法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 父类方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1002</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写父类方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类1吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类1特有方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类1睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1003</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写父类方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类2吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类2特有方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类2睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h1><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h3><p>使用abstract关键字修饰的类称为抽象类，<code>抽象类不能实例化（不能造对象）</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;…&#125;</span><br></pre></td></tr></table></figure><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p>抽象类可以定义各种类型的成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="comment">// 基本数据类型成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> intValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用类型成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String stringValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> booleanValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态常量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><code>抽象类中一定有构造器</code>，便于子类对象实例化时调用，开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="comment">// 基本数据类型成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> intValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用类型成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String stringValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractClass</span><span class="params">(<span class="type">int</span> intValue, String stringValue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.intValue = intValue;</span><br><span class="line">        <span class="built_in">this</span>.stringValue = stringValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>抽象类中可以使用代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="comment">// 普通代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>抽象类可以包含抽象方法和普通方法，包含抽象方法的类，一定是一个抽象类，抽象类中可以没有抽象方法</p><ul><li><p><strong>抽象方法</strong>：使用<code>abstract</code>关键字修饰的方法称为抽象方法，<code>抽象方法只有方法的声明，没有方法体</code></p></li><li><p><strong>普通方法</strong>：有方法的声明，也有方法体</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    修饰符 <span class="keyword">abstract</span> 返回值类型 方法名(参数列表);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 普通方法</span></span><br><span class="line">    [访问修饰符] 返回值类型 方法名(参数列表) &#123;</span><br><span class="line">        方法体</span><br><span class="line">        <span class="keyword">return</span> 返回值;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h3><p>一个类只能继承一个类，抽象类中的子类可以是抽象类，如果不是抽象类的话必须对抽象类中的抽象方法进行重写</p><ul><li><strong>抽象子类</strong>：若子类没有重写父类中的所有抽象方法，此子类也是一个抽象类，此子类不能实例化，需要用abstract修饰</li><li><strong>普通子类</strong>：若子类重写了父类中的所有的抽象方法后，此子类是一个普通类，此子类可实例化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractClass</span><span class="params">(<span class="type">int</span> intValue, String stringValue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.intValue = intValue;</span><br><span class="line">        <span class="built_in">this</span>.stringValue = stringValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">concreteMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个具体的方法。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通子类：继承抽象类，并实现所有抽象方法，此子类可实例化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="comment">// 普通子类构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteClass</span><span class="params">(<span class="type">int</span> intValue, String stringValue)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(intValue, stringValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类实现父类的抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法实现。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象子类：继承抽象类，不实现抽象方法，此子类不可实例化</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSubclass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象子类构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractSubclass</span><span class="params">(<span class="type">int</span> intValue, String stringValue)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(intValue, stringValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码示例"><a href="#完整代码示例" class="headerlink" title="完整代码示例"></a>完整代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="comment">// 基本数据类型成员变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> intValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用类型成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String stringValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> booleanValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态常量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">PI</span> <span class="operator">=</span> <span class="number">3.14159</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractClass</span><span class="params">(<span class="type">int</span> intValue, String stringValue)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.intValue = intValue;</span><br><span class="line">        <span class="built_in">this</span>.stringValue = stringValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">concreteMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一个具体的方法。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通代码块</span></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通子类：继承抽象类，并实现所有抽象方法，此子类可实例化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteClass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="comment">// 普通子类构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ConcreteClass</span><span class="params">(<span class="type">int</span> intValue, String stringValue)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(intValue, stringValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子类实现父类的抽象方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">abstractMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;抽象方法实现。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象子类：继承抽象类，不实现抽象方法，此子类不可实例化</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSubclass</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象子类构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AbstractSubclass</span><span class="params">(<span class="type">int</span> intValue, String stringValue)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(intValue, stringValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="定义方式-1"><a href="#定义方式-1" class="headerlink" title="定义方式"></a>定义方式</h3><p>使用<code>interface</code>来声明一个接口，接口其实是一个特殊的抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Test</span>&#123;...&#125;</span><br></pre></td></tr></table></figure><h3 id="成员变量-1"><a href="#成员变量-1" class="headerlink" title="成员变量"></a>成员变量</h3><p>接口中的变量前面会被默认加上<code>public static final</code>的，即接口中没有变量，都是常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// 基本数据类型静态常量，等同于 public static final int MAX_SPEED = 60;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">MAX_SPEED</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用类型静态常量，等同于 public static final String TYPE = &quot;Land&quot;;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">TYPE</span> <span class="operator">=</span> <span class="string">&quot;Land&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p>在Java中，接口是一种定义方法的规范，它不能包含构造函数</p><h3 id="代码块-1"><a href="#代码块-1" class="headerlink" title="代码块"></a>代码块</h3><p>接口中不能使用代码块</p><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>接口可以包含抽象方法、默认方法和静态方法</p><p><strong>抽象方法</strong>：接口中的方法会被默认加上<code>abstract</code>关键字，使用abstract关键字修饰的方法称为抽象方法，<code>抽象方法只有方法的声明，没有方法体</code></p><p><strong>默认方法</strong>：使用<code>default</code>关键字修饰，有方法的声明，也有方法体</p><p><strong>静态方法</strong>：使用<code>static</code>关键字修饰，有方法的声明，也有方法体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;    </span><br><span class="line">    <span class="comment">// 抽象方法，等同于 abstract String sound();</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接口A中的默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接口A中的静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多实现"><a href="#多实现" class="headerlink" title="多实现"></a>多实现</h3><p>一个类可以实现多个接口，通过逗号分隔。当实现了接口之后，需要满足以下要求</p><ul><li><strong>必须重写抽象方法</strong>：必须在实现类中重写所有抽象方法，否则该类必须使用<code>abstract</code>关键字声明为抽象类。</li><li><strong>选择性重写默认方法</strong>：可以选择性地进行重写，如果不重写，实现类将继承接口中的默认实现。</li><li><strong>不能重写静态方法</strong>：无法被子类重写或覆盖，可以直接通过接口名调用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法，等同于 abstract String sound();</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接口A中的默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接口A中的静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="comment">// 抽象方法，等同于 abstract String sound();</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接口B中的默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接口B中的默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现一个接口，只重写抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassC</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;重写方法A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现两个接口，重写抽象方法、默认方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassD</span> <span class="keyword">implements</span> <span class="title class_">A</span>, B &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;重写方法A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;重写方法B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择重写默认方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;重写默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现两个接口，不重写抽象方法</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MyClassE</span> <span class="keyword">implements</span> <span class="title class_">A</span>, B &#123;</span><br><span class="line">    <span class="comment">// 接口 A 和 B 都包含 defaultMethod 同名默认方法。如果不重写，编译器将会报错</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;重写默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完整代码示例-1"><a href="#完整代码示例-1" class="headerlink" title="完整代码示例"></a>完整代码示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// 基本数据类型静态常量，等同于 public static final int MAX_SPEED = 60;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">MAX_SPEED</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用类型静态常量，等同于 public static final String TYPE = &quot;Land&quot;;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">TYPE</span> <span class="operator">=</span> <span class="string">&quot;Land&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法，等同于 abstract String sound();</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接口A中的默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接口A中的静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">    <span class="comment">// 基本数据类型静态常量，等同于 public static final int MAX_SPEED = 60;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">MAX_SPEED</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用类型静态常量，等同于 public static final String TYPE = &quot;Land&quot;;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">TYPE</span> <span class="operator">=</span> <span class="string">&quot;Land&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抽象方法，等同于 abstract String sound();</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接口B中的默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接口B中的默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现一个接口，只重写抽象方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassC</span> <span class="keyword">implements</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;重写方法A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现两个接口，重写抽象方法、默认方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClassD</span> <span class="keyword">implements</span> <span class="title class_">A</span>, B &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;重写方法A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;重写方法B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择重写默认方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;重写默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现两个接口，不重写抽象方法</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MyClassE</span> <span class="keyword">implements</span> <span class="title class_">A</span>, B &#123;</span><br><span class="line">    <span class="comment">// 接口 A 和 B 都包含 defaultMethod 同名默认方法。如果不重写，编译器将会报错</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">defaultMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;重写默认方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象类与接口的区别"><a href="#抽象类与接口的区别" class="headerlink" title="抽象类与接口的区别"></a>抽象类与接口的区别</h2><ol><li><strong>定义方式</strong>：抽象类使用<code>abstract</code>关键字来修饰，接口使用<code>interface</code>关键字来修饰。</li><li><strong>构造函数</strong>：抽象类可以有构造函数，而接口不能有构造函数。</li><li><strong>代码块</strong>：抽象类中可以包含代码块，而接口中不能有代码块。</li><li><strong>成员变量</strong>：抽象类可以定义各种类型的成员变量，而接口中的变量默认为<code>public static final</code>型常量。</li><li><strong>方法</strong>：抽象类可以包含非抽象方法和抽象方法，而接口只能包含抽象方法、默认方法和静态方法。</li><li><strong>单继承与多实现</strong>：一个类可以继承一个抽象类，但只能实现多个接口。</li><li><strong>主要作用</strong>：抽象类用于作为其他类的基类，定义了一些通用行为和属性，子类可以继承这些通用行为和属性，并在需要的基础上进行扩展或修改。接口用于定义一组规范，描述了一个对象应该具备的行为</li></ol><h1 id="常见关键字"><a href="#常见关键字" class="headerlink" title="常见关键字"></a>常见关键字</h1><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><p>（1）<code>this</code>表示当前对象的引用，可以使用<code>this</code>关键字访问当前对象的成员变量、成员方法和构造方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用当前对象的构造器,需要在构造器中使用,必须放在构造器的首行</span></span><br><span class="line"><span class="built_in">this</span>(形参列表);</span><br><span class="line"><span class="comment">// 调用当前对象的属性</span></span><br><span class="line"><span class="built_in">this</span>.属性;</span><br><span class="line"><span class="comment">// 调用当前对象的方法</span></span><br><span class="line"><span class="built_in">this</span>.方法;</span><br></pre></td></tr></table></figure><p>（2）当类中成员变量与构造方法形参重名时，可以使用this区分同名变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Demo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 构造器中调用构造器,必须放在构造器的首行</span></span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;小白&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">// 调用当前对象的方法</span></span><br><span class="line">        <span class="built_in">this</span>.hello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全参构造</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Demo</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造器中调用属性</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）当需要返回当前对象的引用时，就常常在方法写return this</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> Demo <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 返回类的当前对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><p>（1）<code>super</code>表示当前对象的父类（超类）的引用，可以使用<code>super</code>关键字访问父类的成员变量、成员方法和构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用父类对象的构造器,需要在构造器中使用,必须放在构造器的首行</span></span><br><span class="line"><span class="built_in">super</span>(参数列表)</span><br><span class="line"><span class="comment">// 调用父类的属性</span></span><br><span class="line"><span class="built_in">super</span>.属性</span><br><span class="line"><span class="comment">// 调用父类的方法</span></span><br><span class="line"><span class="built_in">super</span>.方法</span><br></pre></td></tr></table></figure><p>（2）super关键字可用于访问父类中定义的属性、方法，在子类构造器中调用父类的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造器中调用属性</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 父类中的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类Cat类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 调用父类对象的构造器,需要在构造器中使用,必须放在构造器的首行</span></span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;喵喵&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用父类的属性</span></span><br><span class="line">        <span class="built_in">super</span>.name = <span class="string">&quot;绵绵&quot;</span>;</span><br><span class="line">        <span class="comment">// 调用父类的hello()方法</span></span><br><span class="line">        <span class="built_in">super</span>.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）this和super的区别</p><table><thead><tr><th>区别点</th><th>this</th><th>super</th></tr></thead><tbody><tr><td>访问属性</td><td>访问本类中的属性，如果本类没 有此属性则从父类中继续查找</td><td>直接访问父类中的属性</td></tr><tr><td>调用方法</td><td>访问本类中的方法，如果本类没 有此方法则从父类中继续查找</td><td>直接访问父类中的方法</td></tr><tr><td>调用构造器</td><td>调用本类构造器，必须放在构造器的首行</td><td>调用父类构造器，必须放在子类构造器的首行</td></tr></tbody></table><h2 id="abstract关键字（抽象）"><a href="#abstract关键字（抽象）" class="headerlink" title="abstract关键字（抽象）"></a>abstract关键字（抽象）</h2><p>abstract关键字可以用来修饰的类（抽象类）、方法（抽象方法）</p><p>abstract关键字不能用来修饰属性、私有方法、静态方法、构造方法、final修饰的方法、final修饰的类</p><h2 id="interface关键字（接口）"><a href="#interface关键字（接口）" class="headerlink" title="interface关键字（接口）"></a>interface关键字（接口）</h2><p>interface关键字用于定义接口</p><h2 id="package关键字（包）"><a href="#package关键字（包）" class="headerlink" title="package关键字（包）"></a>package关键字（包）</h2><h3 id="包概念相关"><a href="#包概念相关" class="headerlink" title="包概念相关"></a>包概念相关</h3><p>（1）为了更好地对类进行统一的管理和划分，Java提供了包机制。使用package关键字来声明类或接口所属的包，声明在源文件的首行</p><p>（2）包的作用：解决类命名冲突的问题、控制访问权限、划分项目层次，便于管理</p><p>（3）如果在源文件中没有定义包，那么类、接口、枚举和注释类型文件将会被放进一个无名的包中，也称为默认包。在实际企业开发中，通常不会把类定义在默认包下</p><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><p>（1）包声明在源文件的首行，语法格式如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明在源文件的首行</span></span><br><span class="line"><span class="keyword">package</span> pkg1[．pkg2[．pkg3…]];</span><br></pre></td></tr></table></figure><p>（2）Java 包的命名规则</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、包名全部由小写字母（多个单词也全部小写）</span><br><span class="line"><span class="number">2</span>、如果包名包含多个层次，每个层次用“.”分割</span><br><span class="line"><span class="number">3</span>、包名一般由倒置的域名开头，比如 com.baidu，不要有 www</span><br><span class="line"><span class="number">4</span>、自定义包不能 java 开头</span><br></pre></td></tr></table></figure><h3 id="包导入（import）"><a href="#包导入（import）" class="headerlink" title="包导入（import）"></a>包导入（import）</h3><p>（1）如果使用不同包中的其它类，需要使用该类的全名（包名+类名）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com.wen为包名，Test为包下的类</span></span><br><span class="line">com.wen.Test() test = <span class="keyword">new</span> <span class="title class_">com</span>.wen.Test();</span><br></pre></td></tr></table></figure><p>（2）为了简化编程，Java 引入了 <code>import</code> 关键字，用于导入指定包层次下的某个类或全部类</p><p>注意：使用星号（*）可能会增加编译时间，特别是引入多个大包时，所以明确的导入你想要用到的类是一个好方法，需要注意的是使用星号对运行时间和类的大小没有影响</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入某个包下的某个类</span></span><br><span class="line"><span class="keyword">import</span> 包名.类名;</span><br><span class="line"><span class="comment">// 导入某个包下的所有类</span></span><br><span class="line"><span class="keyword">import</span> 包名.*;</span><br></pre></td></tr></table></figure><p>（3）import 语句位于 package 语句之后，类定义之前。一个 Java 源文件只能包含一个 package 语句，但可以包含多个 import 语句</p><p>（4）Java 默认为所有源文件导入 java.lang 包下的所有类，因此前面在 Java 程序中使用 String、System 类时都无须使用 import 语句来导入这些类</p><h3 id="系统包"><a href="#系统包" class="headerlink" title="系统包"></a>系统包</h3><p>Java SE 提供了一些系统包，其中包含了 Java 开发中常用的基础类</p><table><thead><tr><th>包</th><th>简介</th></tr></thead><tbody><tr><td>java.lang</td><td>包含一些Java语言的核心类，如String、Math、Integer、 System和 Thread，提供常用功能</td></tr><tr><td>java.net</td><td>包含执行与网络相关的操作的类和接口</td></tr><tr><td>java.io</td><td>包含能提供多种输入&#x2F;输出功能的类</td></tr><tr><td>java.util</td><td>包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数</td></tr><tr><td>java.text</td><td>包含了一些java格式化相关的类</td></tr><tr><td>java.sql</td><td>包含了Java进行JDBC数据库编程的相关类&#x2F;接口</td></tr><tr><td>java.awt</td><td>包含了构成抽象窗口工具集的多个类，这些类被用来构建和管理应用程序的图形用户界面（GUI）</td></tr></tbody></table><h3 id="Jar包"><a href="#Jar包" class="headerlink" title="Jar包"></a>Jar包</h3><p>（1）Java中的jar包就是java类在编译生成class文件后，进行打包的压缩包，jar包里面就是.class文件</p><p>（2）因为jar包主要是对class文件进行打包，而java编译生成的class文件是平台无关的，这就意味着<code>jar包是跨平台的</code>，所以不必关心涉及具体平台的问题</p><p>（3）将一个类打为 jar 包的语法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）编译</span></span><br><span class="line">javac -d . 类名.java</span><br><span class="line"><span class="comment">// （2）打jar包，生成名叫myjar.jar的文件，参数c参数创建，参数v参数显示创建过程文件的详细信息</span></span><br><span class="line">jar -cvf myjar.jar cn</span><br></pre></td></tr></table></figure><p>（4）查看 jar 文件内容列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数t表示显示列表，参数v表示显示文件的详细信息</span></span><br><span class="line">jar -tvf myjar.jar</span><br></pre></td></tr></table></figure><p>（5）解压 jar 文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar xvf myjar.jar</span><br></pre></td></tr></table></figure><p>（6）运行jar文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar myjar.jar</span><br></pre></td></tr></table></figure><p>（7）jar是一种基于ZIP压缩格式的文件，除了扩展名和zip不一样之外，可以认为一个jar文件和一个zip文件是完全一样的，因此二者仅仅是后缀名称的区别而已，也就是说将文件压缩为<code>zip</code>格式，通过<code>java -jar</code>也可以运行</p><h2 id="static关键字（静态）"><a href="#static关键字（静态）" class="headerlink" title="static关键字（静态）"></a>static关键字（静态）</h2><p>static关键字可以用来修饰属性、方法、代码块、内部类。</p><ul><li><strong>修饰属性</strong>：用<code>static</code>修饰的属性为静态属性，也称为类变量。静态属性属于类本身，可以直接通过类名调用，无需创建类的实例对象。</li><li><strong>修饰方法</strong>：用<code>static</code>修饰的方法为静态方法，也称为类方法。静态方法属于类本身，可以直接通过类名调用，无需创建类的实例对象。静态方法中&#96;&#96;不能直接访问实例方法和实例变量，也不能使用this关键字、super关键字<code>。静态方法</code>不能被重写&#96;</li><li><strong>修饰代码块</strong>：用<code>static</code>修饰的代码块称为静态代码块。静态代码块在类加载时执行，并且只会执行一次。它可用于进行静态变量的初始化或其他静态操作。</li><li><strong>修饰内部类</strong>：用<code>static</code>修饰的内部类称为静态内部类。静态内部类与外部类间没有直接的关联，可以直接创建静态内部类的实例对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyClass.staticVariable = <span class="number">2</span>;<span class="comment">// 通过类名调用静态属性</span></span><br><span class="line">        MyClass.staticMethod();<span class="comment">// 通过类名调用静态方法</span></span><br><span class="line">        MyClass.StaticInnerClass.staticInnerMethod();<span class="comment">// 通过类名调用静态内部类中的静态方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> staticVariable;</span><br><span class="line">    <span class="comment">// 实例属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> instanceVariable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 静态方法不能直接访问实例变量和实例方法</span></span><br><span class="line">        <span class="comment">// MyClass.instanceVariable = 2; // 直接访问实例变量会报错</span></span><br><span class="line">        <span class="comment">// MyClass.instanceMethod(); // 直接访问实例方法也会报错</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 静态方法不能使用this关键字、super关键字</span></span><br><span class="line">        <span class="comment">// System.out.println(MyClass.this.getClass()); // 使用this关键字会报错</span></span><br><span class="line">        <span class="comment">// System.out.println(MyClass.super.getClass()); // 使用super关键字也会报错</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">instanceMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 实例方法可以直接访问静态变量和调用静态方法</span></span><br><span class="line">        MyClass.staticVariable = <span class="number">2</span>;</span><br><span class="line">        MyClass.staticMethod();</span><br><span class="line">        <span class="comment">// 也可以使用this关键字、super关键字</span></span><br><span class="line">        System.out.println(MyClass.<span class="built_in">this</span>.getClass());</span><br><span class="line">        System.out.println(MyClass.<span class="built_in">super</span>.getClass());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态代码块，类加载时执行，仅执行一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 可用于进行静态变量的初始化或其他静态操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态内部类，与外部类间没有直接的关联，可以直接创建静态内部类的实例对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">StaticInnerClass</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticInnerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;静态内部方法被执行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">instanceInnerMethod</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;实例内部方法被执行&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="final关键字（最终）"><a href="#final关键字（最终）" class="headerlink" title="final关键字（最终）"></a>final关键字（最终）</h2><p>final关键字可以用来修饰的结构：类、方法、变量（成员变量、局部变量、形参、引用地址）</p><ul><li><strong>修饰类</strong>：用<code>final</code>修饰的类不能被其他类继承</li><li><strong>修饰方法</strong>：用<code>final</code>修饰的方法不能被子类重写</li><li><strong>修饰变量</strong>：用<code>final</code>修饰的变量表示常量，即其值一旦被初始化后就不能被修改。对于基本数据类型的变量，该值是不可变的；对于引用类型的变量，该引用不能再指向其他对象，但是该对象的内容可以被修改。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;<span class="comment">// 使用final修饰的 类MyClass，不能被继承</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">30</span>; <span class="comment">// 使用final修饰的 成员变量age，值不能被修改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用final修饰的 方法myMethod，不能被子类重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> num)</span> &#123;<span class="comment">// 使用final修饰方法的 形参num，值不能被修改</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 使用final修饰的 局部变量message，值不能被修改</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">// 使用final修饰的 引用地址obj，不能再指向其他对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h2><p>在Java中，<code>transient</code>是一个关键字，用来修饰类的成员变量。当一个变量被声明为<code>transient</code>时，它表示该变量不参与对象的序列化过程，将被跳过，不会被序列化，通常用于一些敏感信息或者不需要被序列化和传输的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="native关键字"><a href="#native关键字" class="headerlink" title="native关键字"></a>native关键字</h2><p>（1）native关键字用于表示该方法是调用其他语言编写的实现。</p><p>（2）出现原因：由于某些情况使用Java语言不易编写或效率不高，此时可以使用其他语言实现，然后再通过Java来进行调用</p><p>（3）Java源码中有的方法是native修饰的，例如：Object类中的hashCode()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Java栈、堆、方法区"><a href="#Java栈、堆、方法区" class="headerlink" title="Java栈、堆、方法区"></a>Java栈、堆、方法区</h1><h2 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h2><p>栈是一种后进先出（LIFO）的数据结构，用于存储方法调用时的局部变量、基本数据类型和对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>; <span class="comment">// 基本数据类型，存储在栈区</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 引用类型，存储在栈区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h2><p>堆用于存储动态分配的对象，所有通过 new 关键字创建的对象都存储在堆中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>(); <span class="comment">// 创建一个对象，存储在堆区</span></span><br><span class="line">        <span class="type">MyClass</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClass</span>(); <span class="comment">// 创建另一个对象，存储在堆区</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>方法区用于存储类的信息、常量池、静态变量等数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CONSTANT</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 常量，存储在方法区</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 静态变量，存储在方法区</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(CONSTANT);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象实例化的过程"><a href="#对象实例化的过程" class="headerlink" title="对象实例化的过程"></a>对象实例化的过程</h2><ol><li><strong>内存分配</strong>：在对象实例化之前，需要为对象分配内存空间。对于全局对象、静态对象和栈区域内的对象，内存分配在编译阶段完成；而对于堆空间中的对象，内存分配是在运行阶段进行的。</li><li><strong>类加载</strong>：在对象实例化之前，需要先加载对象所属的类。类的加载包括加载类的字节码文件，并将类信息存储在方法区中。</li><li><strong>初始化</strong>：初始化是在对象创建时进行的过程。它发生在赋值之前，主要用来设置对象的初始状态。初始化包括对对象的成员变量进行默认初始化（如整型默认为0，引用类型默认为null）以及执行构造函数中的初始化代码。</li><li><strong>执行构造方法</strong>：构造方法是一种特殊的方法，用于创建和初始化对象。在对象创建后，会自动调用相应的构造方法。构造方法中可以进行一些额外的初始化操作，如给对象的成员变量赋值、执行特定的逻辑等。</li><li><strong>赋值</strong>：赋值是在对象初始化完成后，为对象的成员变量设置具体的值。赋值过程可以在构造方法的函数体中进行。在赋值过程中，可以使用构造方法的参数或其他逻辑进行赋值操作，将对象的成员变量设置为所需的值。</li><li><strong>返回对象引用</strong>：在对象初始化完成后，可以通过返回对象引用来使用和操作该对象。</li></ol><h2 id="对象实例化的例子"><a href="#对象实例化的例子" class="headerlink" title="对象实例化的例子"></a>对象实例化的例子</h2><ol><li>程序从<code>main</code>方法开始执行，将<code>main</code>方法压栈。</li><li>在执行到<code>Student student = new Student(&quot;Tom&quot;, 18);</code>这行代码时，会在堆内存中分配一块空间存储创建的<code>Student</code>对象。</li><li>假设分配的内存地址是<code>0x0101</code>，那么变量<code>student</code>会在栈内存中被创建并指向这个内存地址。</li><li>执行<code>Student</code>类的构造方法<code>public Student(String name, int age)</code>，在构造方法中将参数值赋给对象的成员变量<code>name</code>和<code>age</code>。</li><li>完成对象的初始化后，<code>student</code>引用指向了实际的对象。</li><li>执行<code>student.displayInfo()</code>方法，调用<code>Student</code>类中的<code>displayInfo()</code>方法，显示学生的信息。</li><li>执行完该方法内的代码后，将该方法从栈中弹出（即方法出栈）。</li><li>如果还有其他方法调用或代码要执行，继续执行相应的代码块，直到主程序执行完毕。</li><li>程序执行结束，程序退出。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">displayInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Name: &quot;</span> + name);</span><br><span class="line">        System.out.println(<span class="string">&quot;Age: &quot;</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建Student对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;Tom&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">// 调用displayInfo()方法显示学生信息</span></span><br><span class="line">        student.displayInfo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四种拷贝"><a href="#四种拷贝" class="headerlink" title="四种拷贝"></a>四种拷贝</h1><h2 id="引用拷贝"><a href="#引用拷贝" class="headerlink" title="引用拷贝"></a>引用拷贝</h2><blockquote><p>引用拷贝只复制了对象的引用，新旧对象将指向同一块内存地址，修改新对象会影响到原对象，因为它们共享相同的数据</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> class 引用拷贝 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; hobbies = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        hobbies.add(<span class="string">&quot;读书&quot;</span>);</span><br><span class="line">        hobbies.add(<span class="string">&quot;游泳&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小明&quot;</span>, hobbies);</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> person1; <span class="comment">// 引用拷贝</span></span><br><span class="line">        person2.setName(<span class="string">&quot;小刚&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(person1.getName()); <span class="comment">// 输出结果：小刚</span></span><br><span class="line">        System.out.println(person2.getName()); <span class="comment">// 输出结果：小刚</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2020/01/15/JavaSE-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/引用拷贝.png" style="zoom:50%"><h2 id="对象拷贝"><a href="#对象拷贝" class="headerlink" title="对象拷贝"></a>对象拷贝</h2><blockquote><p>对象拷贝是通过调用对象的拷贝构造函数或克隆方法创建一个新的对象的副本。新对象与原对象是完全独立的，修改新对象不会影响到原对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> class 对象拷贝 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        List&lt;String&gt; hobbies = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        hobbies.add(<span class="string">&quot;读书&quot;</span>);</span><br><span class="line">        hobbies.add(<span class="string">&quot;游泳&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小明&quot;</span>, hobbies);</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> (Person) person1.clone(); <span class="comment">// 对象拷贝</span></span><br><span class="line">        person2.setName(<span class="string">&quot;小刚&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(person1.getName()); <span class="comment">// 输出结果：小明</span></span><br><span class="line">        System.out.println(person2.getName()); <span class="comment">// 输出结果：小刚</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2020/01/15/JavaSE-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/对象拷贝.png" style="zoom:50%"><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><blockquote><p>浅拷贝是创建了一个新对象，该对象的非静态成员变量被复制为原始对象的值。对于引用类型的成员变量，浅拷贝只是复制了引用地址，新对象和原对象中的引用类型成员变量仍然指向相同的对象。</p><ul><li><strong>非静态成员变量</strong>：值会复制给新对象</li><li><strong>引用类型成员变量</strong>：只是复制引用地址，新对象和原对象中的引用类型成员变量仍然指向相同的对象。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 浅拷贝</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">shallowCopy</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> class 浅拷贝 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        List&lt;String&gt; hobbies = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        hobbies.add(<span class="string">&quot;读书&quot;</span>);</span><br><span class="line">        hobbies.add(<span class="string">&quot;游泳&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小明&quot;</span>, hobbies);</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> (Person) person1.shallowCopy();<span class="comment">// 浅拷贝</span></span><br><span class="line">        person2.setName(<span class="string">&quot;小刚&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(person1);<span class="comment">// copy.浅拷贝.Person@7f31245a</span></span><br><span class="line">        System.out.println(person2);<span class="comment">// copy.浅拷贝.Person@6d6f6e28</span></span><br><span class="line">        System.out.println(person1 == person2); <span class="comment">// 输出 false 说明引用地址不一样</span></span><br><span class="line"></span><br><span class="line">        System.out.println(person1.getName()); <span class="comment">// 输出 小明</span></span><br><span class="line">        System.out.println(person2.getName()); <span class="comment">// 输出 小刚</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改person2的hobbies列表</span></span><br><span class="line">        person2.getHobbies().add(<span class="string">&quot;跑步&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(person1.getHobbies()); <span class="comment">// 输出 [读书, 游泳, 跑步]</span></span><br><span class="line">        System.out.println(person2.getHobbies()); <span class="comment">// 输出 [读书, 游泳, 跑步]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2020/01/15/JavaSE-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/浅拷贝.png" style="zoom:50%"><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><blockquote><p>深拷贝是在创建新对象时，不仅复制原始对象中的基本类型成员变量的值，还复制引用类型成员变量所引用的对象。换句话说，深拷贝会递归地复制对象及其所有子对象，新对象和原对象完全独立。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">deepCopy</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        List&lt;String&gt; clonedHobbies = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.hobbies);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="built_in">this</span>.name, clonedHobbies);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> class 深拷贝 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        List&lt;String&gt; hobbies = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        hobbies.add(<span class="string">&quot;读书&quot;</span>);</span><br><span class="line">        hobbies.add(<span class="string">&quot;游泳&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小明&quot;</span>, hobbies);</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> person1.deepCopy();<span class="comment">// 深拷贝</span></span><br><span class="line">        person2.setName(<span class="string">&quot;小刚&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(person1);<span class="comment">// copy.浅拷贝.Person@7f31245a</span></span><br><span class="line">        System.out.println(person2);<span class="comment">// copy.浅拷贝.Person@6d6f6e28</span></span><br><span class="line">        System.out.println(person1 == person2); <span class="comment">// 输出 false 说明引用地址不一样</span></span><br><span class="line"></span><br><span class="line">        System.out.println(person1.getName()); <span class="comment">// 输出 小明</span></span><br><span class="line">        System.out.println(person2.getName()); <span class="comment">// 输出 小明</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改person2的hobbies列表</span></span><br><span class="line">        person2.getHobbies().add(<span class="string">&quot;唱歌&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(person1.getHobbies()); <span class="comment">// 输出 [读书, 游泳]</span></span><br><span class="line">        System.out.println(person2.getHobbies()); <span class="comment">// 输出 [读书, 游泳, 唱歌]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2020/01/15/JavaSE-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/深拷贝.png" style="zoom:50%"><h3 id="深拷贝实现方式一：继承Cloneable重写clone方法"><a href="#深拷贝实现方式一：继承Cloneable重写clone方法" class="headerlink" title="深拷贝实现方式一：继承Cloneable重写clone方法"></a>深拷贝实现方式一：继承Cloneable重写clone方法</h3><p>Java中的<code>clone()</code>方法支持对象的复制，但默认仅实现了浅拷贝。如果要实现深拷贝，需要将对象实现<code>Cloneable</code>接口，并重写<code>clone()</code>方法。在<code>clone()</code>方法内部，将对象及其内部所有属性全部复制一份即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">deepCopy</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        List&lt;String&gt; clonedHobbies = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="built_in">this</span>.hobbies);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="built_in">this</span>.name, clonedHobbies);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> class 深拷贝 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        List&lt;String&gt; hobbies = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        hobbies.add(<span class="string">&quot;读书&quot;</span>);</span><br><span class="line">        hobbies.add(<span class="string">&quot;游泳&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小明&quot;</span>, hobbies);</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> person1.deepCopy();<span class="comment">// 深拷贝</span></span><br><span class="line">        person2.setName(<span class="string">&quot;小刚&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(person1);<span class="comment">// copy.浅拷贝.Person@7f31245a</span></span><br><span class="line">        System.out.println(person2);<span class="comment">// copy.浅拷贝.Person@6d6f6e28</span></span><br><span class="line">        System.out.println(person1 == person2); <span class="comment">// 输出 false 说明引用地址不一样</span></span><br><span class="line"></span><br><span class="line">        System.out.println(person1.getName()); <span class="comment">// 输出 小明</span></span><br><span class="line">        System.out.println(person2.getName()); <span class="comment">// 输出 小明</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改person2的hobbies列表</span></span><br><span class="line">        person2.getHobbies().add(<span class="string">&quot;唱歌&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(person1.getHobbies()); <span class="comment">// 输出 [读书, 游泳]</span></span><br><span class="line">        System.out.println(person2.getHobbies()); <span class="comment">// 输出 [读书, 游泳, 唱歌]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深拷贝实现方式二：使用序列化"><a href="#深拷贝实现方式二：使用序列化" class="headerlink" title="深拷贝实现方式二：使用序列化"></a>深拷贝实现方式二：使用序列化</h3><p>通过将对象序列化为字节流，再将字节流反序列化为新的对象，就可以实现深拷贝。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝</span></span><br><span class="line">    <span class="keyword">public</span> Person <span class="title function_">deepCopy</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(byteOut);</span><br><span class="line">        objectOut.writeObject(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(byteOut.toByteArray());</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(byteIn);</span><br><span class="line">        <span class="keyword">return</span> (Person) objectIn.readObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class 深拷贝 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        List&lt;String&gt; hobbies = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        hobbies.add(<span class="string">&quot;读书&quot;</span>);</span><br><span class="line">        hobbies.add(<span class="string">&quot;游泳&quot;</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小明&quot;</span>, hobbies);</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person2</span> <span class="operator">=</span> person1.deepCopy(); <span class="comment">// 深拷贝</span></span><br><span class="line">        person2.setName(<span class="string">&quot;小刚&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(person1); <span class="comment">// 输出 copy.深拷贝.Person@7f31245a</span></span><br><span class="line">        System.out.println(person2); <span class="comment">// 输出 copy.深拷贝.Person@6d6f6e28</span></span><br><span class="line">        System.out.println(person1 == person2); <span class="comment">// 输出 false，说明引用地址不一样</span></span><br><span class="line"></span><br><span class="line">        System.out.println(person1.getName()); <span class="comment">// 输出 小明</span></span><br><span class="line">        System.out.println(person2.getName()); <span class="comment">// 输出 小刚</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改person2的hobbies列表</span></span><br><span class="line">        person2.getHobbies().add(<span class="string">&quot;唱歌&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(person1.getHobbies()); <span class="comment">// 输出 [读书, 游泳]</span></span><br><span class="line">        System.out.println(person2.getHobbies()); <span class="comment">// 输出 [读书, 游泳, 唱歌]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深拷贝实现方式三：使用工具"><a href="#深拷贝实现方式三：使用工具" class="headerlink" title="深拷贝实现方式三：使用工具"></a>深拷贝实现方式三：使用工具</h3><p>Spring包下的org.springframework.beans.BeanUtils.copyProperties()；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyProperties</span><span class="params">(Object source, Object target)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    copyProperties(source, target, <span class="literal">null</span>, (String[]) <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Apeche包下的org.apache.commons.beanutils.BeanUtils.copyProperties();</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">copyProperties</span><span class="params">(Object dest, Object orig)</span> <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException &#123;</span><br><span class="line">    BeanUtilsBean.getInstance().copyProperties(dest, orig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h1><h2 id="强引用（Strong-Reference）"><a href="#强引用（Strong-Reference）" class="headerlink" title="强引用（Strong Reference）"></a>强引用（Strong Reference）</h2><p>强引用是最常见的引用类型，如果一个对象具有强引用，就表示垃圾回收器不会对其进行回收。即使内存空间不足时，垃圾回收器也不会回收被强引用关联的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 强引用</span></span><br></pre></td></tr></table></figure><h2 id="软引用（Soft-Reference）"><a href="#软引用（Soft-Reference）" class="headerlink" title="软引用（Soft Reference）"></a>软引用（Soft Reference）</h2><p>软引用用于描述还有用但并非必需的对象。在系统内存不足时，垃圾回收器可能会回收软引用关联的对象来释放内存。可以使用<code>SoftReference</code>类来创建软引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;Object&gt; softRef = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 软引用</span></span><br></pre></td></tr></table></figure><h2 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a>弱引用（Weak Reference）</h2><p>弱引用用于描述非必需对象。无论系统内存是否充足，只要发生垃圾回收操作，垃圾回收器都会回收掉只被弱引用关联的对象。可以使用<code>WeakReference</code>类来创建弱引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WeakReference&lt;Object&gt; weakRef = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// 弱引用</span></span><br></pre></td></tr></table></figure><h2 id="虚引用（Phantom-Reference）"><a href="#虚引用（Phantom-Reference）" class="headerlink" title="虚引用（Phantom Reference）"></a>虚引用（Phantom Reference）</h2><p>虚引用用于管理对象被垃圾回收器回收的时机。虚引用与其他引用类型的主要区别在于，无法通过虚引用访问对象，也无法通过虚引用获取对对象的引用。可以使用<code>PhantomReference</code>类来创建虚引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhantomReference&lt;Object&gt; phantomRef = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Object</span>(), referenceQueue); <span class="comment">// 虚引用</span></span><br></pre></td></tr></table></figure><h2 id="四种引用的区别"><a href="#四种引用的区别" class="headerlink" title="四种引用的区别"></a>四种引用的区别</h2><table><thead><tr><th>引用类型</th><th>垃圾回收行为</th><th>生存时间</th><th>用途</th></tr></thead><tbody><tr><td>强引用 (Strong Reference)</td><td>不会被回收</td><td>长期存在，直到引用被显式释放</td><td>主要引用类型，常用于对象的正常引用</td></tr><tr><td>软引用 (Soft Reference)</td><td>在内存不足时可能被回收</td><td>长期存在，直到内存不足时回收</td><td>用于缓存或者需要某些操作前的临时引用</td></tr><tr><td>弱引用 (Weak Reference)</td><td>在垃圾回收时可能被回收</td><td>长期存在，直到没有强引用</td><td>用于实现缓存、监控和弱关联等功能</td></tr><tr><td>虚引用 (Phantom Reference)</td><td>在垃圾回收时可能被回收</td><td>一旦被垃圾回收器处理完毕即消失</td><td>用于对象被回收前的清理工作或跟踪回收状态</td></tr></tbody></table><h1 id="JavaBean"><a href="#JavaBean" class="headerlink" title="JavaBean"></a>JavaBean</h1><blockquote><p>JavaBean是一种符合特定规范的Java类，通常用于在应用程序中传递数据或存储数据。</p></blockquote><h2 id="JavaBean的特征"><a href="#JavaBean的特征" class="headerlink" title="JavaBean的特征"></a>JavaBean的特征</h2><p>满足以下条件才是JavaBean</p><table><thead><tr><th>条件</th><th>描述</th></tr></thead><tbody><tr><td>是一个公共类（public）</td><td>类声明为公共的，这样才能在其他类中访问和使用它。</td></tr><tr><td>具有公共的方法（public）</td><td>提供公共的getter和setter方法来访问和修改私有属性。</td></tr><tr><td>具有私有的属性（private）</td><td>提供私有属性来封装数据，这些属性应该通过访问器（getter）和修改器（setter）来进行访问和修改。</td></tr><tr><td>具有无参的构造方法</td><td>提供公共的无参构造方法，以便在反射时可以实例化对象</td></tr><tr><td>可序列化</td><td>如果需要将JavaBean的对象进行持久化或通过网络进行传输，JavaBean应该实现Serializable接口。</td></tr></tbody></table><h2 id="JavaBean代码示例"><a href="#JavaBean代码示例" class="headerlink" title="JavaBean代码示例"></a>JavaBean代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">// 属性一般定义为private</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无参构造方法 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// get方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaBean的好处"><a href="#JavaBean的好处" class="headerlink" title="JavaBean的好处"></a>JavaBean的好处</h2><ol><li><strong>封装性</strong>：JavaBean通过封装数据和提供访问方法来实现数据的封装，使得代码更加模块化、可维护性更高。</li><li><strong>可重用性</strong>：JavaBean可以在不同的应用程序或模块中被多次使用，提高代码的可重用性。</li><li><strong>可读性</strong>：JavaBean的命名规范和规范化的结构使得代码更加易读和易理解。</li></ol><h1 id="枚举类（enum）"><a href="#枚举类（enum）" class="headerlink" title="枚举类（enum）"></a>枚举类（enum）</h1><h2 id="枚举类简介"><a href="#枚举类简介" class="headerlink" title="枚举类简介"></a>枚举类简介</h2><blockquote><p>枚举类是一种特殊的类，用于声明一组固定且确定的常量</p></blockquote><h2 id="自定义枚举类"><a href="#自定义枚举类" class="headerlink" title="自定义枚举类"></a>自定义枚举类</h2><p>在jdk5.0之前，需要自定义枚举类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DayOfWeek</span> <span class="variable">day1</span> <span class="operator">=</span> DayOfWeek.MONDAY;</span><br><span class="line">        <span class="type">DayOfWeek</span> <span class="variable">day2</span> <span class="operator">=</span> DayOfWeek.FRIDAY;</span><br><span class="line"></span><br><span class="line">        System.out.println(day1);  <span class="comment">// 输出：MONDAY</span></span><br><span class="line">        System.out.println(day2);  <span class="comment">// 输出：FRIDAY</span></span><br><span class="line"></span><br><span class="line">        System.out.println(day1.getDisplayName());  <span class="comment">// 输出：星期一</span></span><br><span class="line">        System.out.println(day2.getDisplayName());  <span class="comment">// 输出：星期五</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义枚举类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">DayOfWeek</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DayOfWeek</span> <span class="variable">MONDAY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DayOfWeek</span>(<span class="string">&quot;星期一&quot;</span>);  <span class="comment">// 星期一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DayOfWeek</span> <span class="variable">TUESDAY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DayOfWeek</span>(<span class="string">&quot;星期二&quot;</span>);  <span class="comment">// 星期二</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DayOfWeek</span> <span class="variable">WEDNESDAY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DayOfWeek</span>(<span class="string">&quot;星期三&quot;</span>);  <span class="comment">// 星期三</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DayOfWeek</span> <span class="variable">THURSDAY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DayOfWeek</span>(<span class="string">&quot;星期四&quot;</span>);  <span class="comment">// 星期四</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DayOfWeek</span> <span class="variable">FRIDAY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DayOfWeek</span>(<span class="string">&quot;星期五&quot;</span>);  <span class="comment">// 星期五</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DayOfWeek</span> <span class="variable">SATURDAY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DayOfWeek</span>(<span class="string">&quot;星期六&quot;</span>);  <span class="comment">// 星期六</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">DayOfWeek</span> <span class="variable">SUNDAY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DayOfWeek</span>(<span class="string">&quot;星期日&quot;</span>);  <span class="comment">// 星期日</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String displayName;  <span class="comment">// 显示名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DayOfWeek</span><span class="params">(String displayName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.displayName = displayName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDisplayName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> displayName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用enum关键字定义枚举类"><a href="#使用enum关键字定义枚举类" class="headerlink" title="使用enum关键字定义枚举类"></a>使用enum关键字定义枚举类</h2><p>jdk5.0之后，可以使用enum关键字定义枚举类</p><ul><li><p>枚举类对象必须在第一行声明，多个枚举类对象之间用”,”隔开，用”;”结束</p></li><li><p>枚举类中的属性，系统会自动添加 public static final 修饰</p></li><li><p>枚举类的构造器只能使用 private 权限修饰符，系统会自动添加 privatel 修饰</p></li></ul><p>使用<code>enum</code>关键字定义的枚举类，默认继承于java.long.Enum类，因此不能继承其他类，但所有枚举实例都可以调用 Enum 类中的方法</p><table><thead><tr><th>方法名称</th><th>说明</th></tr></thead><tbody><tr><td>values()</td><td>返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。</td></tr><tr><td>valueOf(String str)</td><td>返回枚举类中对象名是str的对象，如果没有str的枚举类对象，则抛异常：IllegalArgumentException。</td></tr><tr><td>toString()</td><td>返回当前枚举类对象常量的名称</td></tr><tr><td>compareTo()</td><td>比较两个枚举成员在定义时的顺序</td></tr><tr><td>ordinal()</td><td>获取枚举成员的索引位置</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DayOfWeek</span> <span class="variable">day1</span> <span class="operator">=</span> DayOfWeek.MONDAY;</span><br><span class="line">        <span class="type">DayOfWeek</span> <span class="variable">day2</span> <span class="operator">=</span> DayOfWeek.FRIDAY;</span><br><span class="line"></span><br><span class="line">        System.out.println(day1);  <span class="comment">// 输出：MONDAY</span></span><br><span class="line">        System.out.println(day2);  <span class="comment">// 输出：FRIDAY</span></span><br><span class="line"></span><br><span class="line">        System.out.println(day1.getDisplayName());  <span class="comment">// 输出：星期一</span></span><br><span class="line">        System.out.println(day2.getDisplayName());  <span class="comment">// 输出：星期五</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// values()方法：返回枚举类型的对象数组</span></span><br><span class="line">        DayOfWeek[] values = DayOfWeek.values();</span><br><span class="line">        <span class="keyword">for</span> (DayOfWeek day : values) &#123;</span><br><span class="line">            System.out.println(day);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// valueOf(String str)：返回指定枚举类对象，如果没有这个枚举类对象，则抛异常：IllegalArgumentException。</span></span><br><span class="line">        <span class="type">DayOfWeek</span> <span class="variable">day</span> <span class="operator">=</span> DayOfWeek.valueOf(<span class="string">&quot;MONDAY&quot;</span>);</span><br><span class="line">        System.out.println(day);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ordinal()：获取枚举成员的索引位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ordinal</span> <span class="operator">=</span> DayOfWeek.MONDAY.ordinal();</span><br><span class="line">        System.out.println(ordinal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用enum关键字定义枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">DayOfWeek</span> &#123;</span><br><span class="line">    <span class="comment">// 提供当前枚举类的多个对象，多个对象之间用&quot;,&quot;隔开，用&quot;;&quot;结束</span></span><br><span class="line">    MONDAY(<span class="string">&quot;星期一&quot;</span>),</span><br><span class="line">    TUESDAY(<span class="string">&quot;星期二&quot;</span>),</span><br><span class="line">    WEDNESDAY(<span class="string">&quot;星期三&quot;</span>),</span><br><span class="line">    THURSDAY(<span class="string">&quot;星期四&quot;</span>),</span><br><span class="line">    FRIDAY(<span class="string">&quot;星期五&quot;</span>),</span><br><span class="line">    SATURDAY(<span class="string">&quot;星期六&quot;</span>),</span><br><span class="line">    SUNDAY(<span class="string">&quot;星期日&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明对象的属性，private final修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String displayName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有化的构造器，并给对象属性初始化</span></span><br><span class="line">    DayOfWeek(String displayName) &#123;</span><br><span class="line">        <span class="built_in">this</span>.displayName = displayName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取枚举类对象的显示名称</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDisplayName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> displayName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name();  <span class="comment">// 返回枚举常量的名称，如&quot;MONDAY&quot;、&quot;TUESDAY&quot;等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ipvb.gitee.io/blog">wen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ipvb.gitee.io/blog/2020/01/15/JavaSE-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">https://ipvb.gitee.io/blog/2020/01/15/JavaSE-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ipvb.gitee.io/blog" target="_blank">远方の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/JavaSE/">JavaSE</a></div><div class="post_share"><div class="social-share" data-image="/blog/2020/01/15/JavaSE-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/Java.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/2020/02/01/JavaSE-3-%E5%B8%B8%E7%94%A8%E7%B1%BB/" title="JavaSE笔记-常用类"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2020/02/01/JavaSE-3-%E5%B8%B8%E7%94%A8%E7%B1%BB/Java.png" onerror='onerror=null,src="/blog/img/404.png"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JavaSE笔记-常用类</div></div></a></div><div class="next-post pull-right"><a href="/blog/2020/01/01/JavaSE-1-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/" title="JavaSE笔记-入门基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2020/01/01/JavaSE-1-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/Java.png" onerror='onerror=null,src="/blog/img/404.png"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaSE笔记-入门基础</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blog/2020/01/01/JavaSE-1-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/" title="JavaSE笔记-入门基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2020/01/01/JavaSE-1-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/Java.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-01</div><div class="title">JavaSE笔记-入门基础</div></div></a></div><div><a href="/blog/2020/05/15/JavaSE-10-%E5%8F%8D%E5%B0%84/" title="JavaSE笔记-反射"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2020/05/15/JavaSE-10-%E5%8F%8D%E5%B0%84/Java.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-15</div><div class="title">JavaSE笔记-反射</div></div></a></div><div><a href="/blog/2020/06/01/JavaSE-11-%E6%B3%A8%E8%A7%A3/" title="JavaSE笔记-注解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2020/06/01/JavaSE-11-%E6%B3%A8%E8%A7%A3/Java.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-01</div><div class="title">JavaSE笔记-注解</div></div></a></div><div><a href="/blog/2020/06/15/JavaSE-12-%E6%96%B0%E7%89%B9%E6%80%A7/" title="JavaSE笔记-新特性"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2020/06/15/JavaSE-12-%E6%96%B0%E7%89%B9%E6%80%A7/Java.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-15</div><div class="title">JavaSE笔记-新特性</div></div></a></div><div><a href="/blog/2020/02/15/JavaSE-4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/" title="JavaSE笔记-异常处理机制"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2020/02/15/JavaSE-4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/Java.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-15</div><div class="title">JavaSE笔记-异常处理机制</div></div></a></div><div><a href="/blog/2020/02/01/JavaSE-3-%E5%B8%B8%E7%94%A8%E7%B1%BB/" title="JavaSE笔记-常用类"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2020/02/01/JavaSE-3-%E5%B8%B8%E7%94%A8%E7%B1%BB/Java.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-01</div><div class="title">JavaSE笔记-常用类</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Gitalk</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/img/%E5%A4%B4%E5%83%8F.png" onerror='this.onerror=null,this.src="/blog/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">wen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wen53231323"><i class="fab fa-github"></i><span>我的仓库</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">暂无</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E6%80%9D%E6%83%B3"><span class="toc-number">1.1.</span> <span class="toc-text">面向过程思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是过程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.1.2.</span> <span class="toc-text">什么是面向过程？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3"><span class="toc-number">1.2.</span> <span class="toc-text">面向对象思想</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">什么是对象？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">什么是面向对象？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.</span> <span class="toc-text">面向对象与面向过程对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%8F%8A%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">2.</span> <span class="toc-text">类及类的成员</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">什么是类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">怎么创建类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98"><span class="toc-number">2.3.</span> <span class="toc-text">类的成员</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%EF%BC%88field%EF%BC%89"><span class="toc-number">2.3.1.</span> <span class="toc-text">属性（field）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E4%B8%AD%E5%B1%9E%E6%80%A7%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">类中属性的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">成员变量和局部变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%88method%EF%BC%89"><span class="toc-number">2.3.2.</span> <span class="toc-text">方法（method）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">类中方法的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%EF%BC%88Overload%EF%BC%89"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">方法的重载（Overload）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%EF%BC%88Override%EF%BC%89"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">方法的重写（Override）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%80%92%E5%BD%92%EF%BC%88recursion%EF%BC%89"><span class="toc-number">2.3.2.4.</span> <span class="toc-text">方法的递归（recursion）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%88%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">2.3.3.</span> <span class="toc-text">构造器（构造方法）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E7%AE%80%E4%BB%8B"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">构造器简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">构造器代码示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97%EF%BC%88%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97%EF%BC%89"><span class="toc-number">2.3.4.</span> <span class="toc-text">代码块（初始化块）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E4%B8%AD%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">类中代码块的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">静态代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E4%B8%8E%E9%9D%9E%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.4.3.</span> <span class="toc-text">静态代码块与非静态代码块的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88inner-class%EF%BC%89"><span class="toc-number">2.3.5.</span> <span class="toc-text">内部类（inner class）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E4%B8%AD%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">类中内部类的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">内部的分类</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%88%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">类的实例化（创建对象）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="toc-number">3.1.</span> <span class="toc-text">对象的简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%88%E5%AE%9E%E4%BE%8B%E5%8C%96%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">对象的创建（实例化）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">3.3.</span> <span class="toc-text">对象的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">3.4.</span> <span class="toc-text">使用案例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">4.</span> <span class="toc-text">面向对象的三大特征</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E6%80%A7%EF%BC%88Encapsulation%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">封装性（Encapsulation）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%AE%80%E4%BB%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text">封装简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">4.1.2.</span> <span class="toc-text">四种权限修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6%E8%AE%BF%E9%97%AE%E7%BA%A7%E5%88%AB"><span class="toc-number">4.1.3.</span> <span class="toc-text">权限修饰符访问级别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E6%80%A7%EF%BC%88Inheritance%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">继承性（Inheritance）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%AE%80%E4%BB%8B"><span class="toc-number">4.2.1.</span> <span class="toc-text">继承简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95"><span class="toc-number">4.2.2.</span> <span class="toc-text">继承语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%86%99%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">4.2.3.</span> <span class="toc-text">重写父类方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E6%80%A7%EF%BC%88Polymorphism%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">多态性（Polymorphism）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81%E7%AE%80%E4%BB%8B"><span class="toc-number">4.3.1.</span> <span class="toc-text">多态简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.3.2.</span> <span class="toc-text">实现多态的条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.3.3.</span> <span class="toc-text">代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">4.3.4.</span> <span class="toc-text">静态绑定和动态绑定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.3.5.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.3.6.</span> <span class="toc-text">instanceof关键字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.</span> <span class="toc-text">抽象类与接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">5.1.</span> <span class="toc-text">抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="toc-number">5.1.1.</span> <span class="toc-text">定义方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">5.1.2.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.3.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">5.1.4.</span> <span class="toc-text">代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">5.1.5.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BB%A7%E6%89%BF"><span class="toc-number">5.1.6.</span> <span class="toc-text">单继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.1.7.</span> <span class="toc-text">完整代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.2.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F-1"><span class="toc-number">5.2.1.</span> <span class="toc-text">定义方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-1"><span class="toc-number">5.2.2.</span> <span class="toc-text">成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="toc-number">5.2.3.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97-1"><span class="toc-number">5.2.4.</span> <span class="toc-text">代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-1"><span class="toc-number">5.2.5.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.6.</span> <span class="toc-text">多实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">5.2.7.</span> <span class="toc-text">完整代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.3.</span> <span class="toc-text">抽象类与接口的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.</span> <span class="toc-text">常见关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.1.</span> <span class="toc-text">this关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.2.</span> <span class="toc-text">super关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#abstract%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E6%8A%BD%E8%B1%A1%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">abstract关键字（抽象）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#interface%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E6%8E%A5%E5%8F%A3%EF%BC%89"><span class="toc-number">6.4.</span> <span class="toc-text">interface关键字（接口）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#package%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E5%8C%85%EF%BC%89"><span class="toc-number">6.5.</span> <span class="toc-text">package关键字（包）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E6%A6%82%E5%BF%B5%E7%9B%B8%E5%85%B3"><span class="toc-number">6.5.1.</span> <span class="toc-text">包概念相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.5.2.</span> <span class="toc-text">语法格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E5%AF%BC%E5%85%A5%EF%BC%88import%EF%BC%89"><span class="toc-number">6.5.3.</span> <span class="toc-text">包导入（import）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%8C%85"><span class="toc-number">6.5.4.</span> <span class="toc-text">系统包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jar%E5%8C%85"><span class="toc-number">6.5.5.</span> <span class="toc-text">Jar包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E9%9D%99%E6%80%81%EF%BC%89"><span class="toc-number">6.6.</span> <span class="toc-text">static关键字（静态）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E6%9C%80%E7%BB%88%EF%BC%89"><span class="toc-number">6.7.</span> <span class="toc-text">final关键字（最终）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#transient%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.8.</span> <span class="toc-text">transient关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#native%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.9.</span> <span class="toc-text">native关键字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E6%A0%88%E3%80%81%E5%A0%86%E3%80%81%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="toc-number">7.</span> <span class="toc-text">Java栈、堆、方法区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%EF%BC%88Stack%EF%BC%89"><span class="toc-number">7.1.</span> <span class="toc-text">栈（Stack）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%EF%BC%88Heap%EF%BC%89"><span class="toc-number">7.2.</span> <span class="toc-text">堆（Heap）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88Method-Area%EF%BC%89"><span class="toc-number">7.3.</span> <span class="toc-text">方法区（Method Area）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">7.4.</span> <span class="toc-text">对象实例化的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">7.5.</span> <span class="toc-text">对象实例化的例子</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E6%8B%B7%E8%B4%9D"><span class="toc-number">8.</span> <span class="toc-text">四种拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%8B%B7%E8%B4%9D"><span class="toc-number">8.1.</span> <span class="toc-text">引用拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D"><span class="toc-number">8.2.</span> <span class="toc-text">对象拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">8.3.</span> <span class="toc-text">浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">8.4.</span> <span class="toc-text">深拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E7%BB%A7%E6%89%BFCloneable%E9%87%8D%E5%86%99clone%E6%96%B9%E6%B3%95"><span class="toc-number">8.4.1.</span> <span class="toc-text">深拷贝实现方式一：继承Cloneable重写clone方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">8.4.2.</span> <span class="toc-text">深拷贝实现方式二：使用序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-number">8.4.3.</span> <span class="toc-text">深拷贝实现方式三：使用工具</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="toc-number">9.</span> <span class="toc-text">四种引用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%88Strong-Reference%EF%BC%89"><span class="toc-number">9.1.</span> <span class="toc-text">强引用（Strong Reference）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8%EF%BC%88Soft-Reference%EF%BC%89"><span class="toc-number">9.2.</span> <span class="toc-text">软引用（Soft Reference）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%88Weak-Reference%EF%BC%89"><span class="toc-number">9.3.</span> <span class="toc-text">弱引用（Weak Reference）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8%EF%BC%88Phantom-Reference%EF%BC%89"><span class="toc-number">9.4.</span> <span class="toc-text">虚引用（Phantom Reference）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">9.5.</span> <span class="toc-text">四种引用的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaBean"><span class="toc-number">10.</span> <span class="toc-text">JavaBean</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaBean%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">10.1.</span> <span class="toc-text">JavaBean的特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaBean%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">10.2.</span> <span class="toc-text">JavaBean代码示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaBean%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">10.3.</span> <span class="toc-text">JavaBean的好处</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%88enum%EF%BC%89"><span class="toc-number">11.</span> <span class="toc-text">枚举类（enum）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%AE%80%E4%BB%8B"><span class="toc-number">11.1.</span> <span class="toc-text">枚举类简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">11.2.</span> <span class="toc-text">自定义枚举类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8enum%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">11.3.</span> <span class="toc-text">使用enum关键字定义枚举类</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/CSS/" title="CSS笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/CSS/CSS.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="CSS笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/CSS/" title="CSS笔记">CSS笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/HTML/" title="HTML笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/HTML/HTML.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="HTML笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/HTML/" title="HTML笔记">HTML笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/JavaScript/" title="JavaScript笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/JavaScript/JavaScript.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="JavaScript笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/JavaScript/" title="JavaScript笔记">JavaScript笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/Linux/" title="Linux笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/Linux/Linux.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="Linux笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/Linux/" title="Linux笔记">Linux笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/JavaWeb/" title="JavaWeb笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/JavaWeb/JavaWeb.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="JavaWeb笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/JavaWeb/" title="JavaWeb笔记">JavaWeb笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By wen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '701b8bc001a40a760558',
      clientSecret: 'a51b436adc471c3949a8f41be05c2d58cccab10a',
      repo: 'Hexo-Butterfly-Comment',
      owner: 'wen53231323',
      admin: ['wen53231323'],
      id: '92b8424616e918742b586b9a0b037980',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'VI32wmbmMoxvlhpTpoDBNeOk-MdYXbMMI',
      appKey: 'oFstfBFkCQIkjuk4ibCpbGqz',
      avatar: 'monsterid',
      serverURLs: 'https://vi32wmbm.api.lncldglobal.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Gitalk' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/blog/js/search/local-search.js"></script></div></div></body></html>