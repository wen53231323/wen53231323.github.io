<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>JavaSE笔记-多线程 | 远方の博客</title><meta name="author" content="wen"><meta name="copyright" content="wen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="多线程相关概念进程与线程一个应用程序，既可以有多个进程，也可以有多个线程，一个进程可以包含多个线程，每个线程相互独立  进程（Process）：是一个运行程序的实例 线程（Thread）：是程序中的一个执行单元  拿浏览器举例，打开一个浏览器，浏览器是一个进程，浏览器中可以打开很多标签页，每个标签页都是这个浏览器进程的子进程，每个子进程中可以有多个线程来协同完成页面的加载和渲染，比如图片、CSS"><meta property="og:type" content="article"><meta property="og:title" content="JavaSE笔记-多线程"><meta property="og:url" content="https://w_e_n.gitee.io/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html"><meta property="og:site_name" content="远方の博客"><meta property="og:description" content="多线程相关概念进程与线程一个应用程序，既可以有多个进程，也可以有多个线程，一个进程可以包含多个线程，每个线程相互独立  进程（Process）：是一个运行程序的实例 线程（Thread）：是程序中的一个执行单元  拿浏览器举例，打开一个浏览器，浏览器是一个进程，浏览器中可以打开很多标签页，每个标签页都是这个浏览器进程的子进程，每个子进程中可以有多个线程来协同完成页面的加载和渲染，比如图片、CSS"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://w_e_n.gitee.io/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java.png"><meta property="article:published_time" content="2020-04-30T16:00:00.000Z"><meta property="article:modified_time" content="2023-08-27T15:52:13.120Z"><meta property="article:author" content="wen"><meta property="article:tag" content="JavaSE"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://w_e_n.gitee.io/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java.png"><link rel="shortcut icon" href="/blog/img/favicon.png"><link rel="canonical" href="https://w_e_n.gitee.io/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//static.cloudflareinsights.com"><link rel="preconnect" href="//www.clarity.ms"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?[object Object]";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=[object Object]"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","[object Object]")</script><script defer data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;[object Object]&quot;}"></script><script>!function(t,e,c,n,a,r){t[c]=t[c]||function(){(t[c].q=t[c].q||[]).push(arguments)},(a=e.createElement(n)).async=1,a.src="https://www.clarity.ms/tag/[object Object]",(r=e.getElementsByTagName(n)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><script>const GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: {"path":"/blog/search.xml","preload":true,"top_n_per_article":5,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"JavaSE笔记-多线程",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-08-27 23:52:13"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/img/%E5%A4%B4%E5%83%8F.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/picture/"><i class="fa-fw fas fa-images"></i><span> 图片库</span></a></li><li><a class="site-page child" href="/blog/music/"><i class="fa-fw fas fa-music"></i><span> 音乐库</span></a></li><li><a class="site-page child" href="/blog/movies/"><i class="fa-fw fas fa-video"></i><span> 视频库</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/link/"><span>导航链接</span></a></li><li><a class="site-page child" href="/blog/comment_loading/"><span>评论管理</span></a></li><li><a class="site-page child" href="/blog/custom/"><span>自定义页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/blog/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java.png)"><nav id="nav"><span id="blog-info"><a href="/blog/" title="远方の博客"><span class="site-name">远方の博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/blog/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/picture/"><i class="fa-fw fas fa-images"></i><span> 图片库</span></a></li><li><a class="site-page child" href="/blog/music/"><i class="fa-fw fas fa-music"></i><span> 音乐库</span></a></li><li><a class="site-page child" href="/blog/movies/"><i class="fa-fw fas fa-video"></i><span> 视频库</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/link/"><span>导航链接</span></a></li><li><a class="site-page child" href="/blog/comment_loading/"><span>评论管理</span></a></li><li><a class="site-page child" href="/blog/custom/"><span>自定义页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/blog/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JavaSE笔记-多线程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-04-30T16:00:00.000Z" title="发表于 2020-05-01 00:00:00">2020-05-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-27T15:52:13.120Z" title="更新于 2023-08-27 23:52:13">2023-08-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="JavaSE笔记-多线程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="多线程相关概念"><a href="#多线程相关概念" class="headerlink" title="多线程相关概念"></a>多线程相关概念</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>一个应用程序，既可以有多个进程，也可以有多个线程，一个进程可以包含多个线程，每个线程相互独立</p><ul><li><strong>进程（Process）</strong>：是一个运行程序的实例</li><li><strong>线程（Thread）</strong>：是程序中的一个执行单元</li></ul><p>拿浏览器举例，打开一个浏览器，浏览器是一个进程，浏览器中可以打开很多标签页，每个标签页都是这个浏览器进程的子进程，每个子进程中可以有多个线程来协同完成页面的加载和渲染，比如图片、CSS 和 JS 文件等都是线程来做的</p><ul><li><strong>多进程模式</strong>：每个进程只有一个线程</li><li><strong>多线程模式</strong>：一个进程有多个线程</li><li><strong>多进程＋多线程模式</strong>：多个进程，每个进程有多个线程</li></ul><h2 id="单核CPU和多核CPU"><a href="#单核CPU和多核CPU" class="headerlink" title="单核CPU和多核CPU"></a>单核CPU和多核CPU</h2><p>单核CPU和多核CPU是指计算机处理器的核心数量不同。</p><ul><li><strong>单核CPU</strong>：单核CPU拥有一个物理处理核心，它只能同时执行一个线程。在单核CPU上运行的多个线程实际上是通过CPU调度算法快速切换执行的，由于处理速度非常快，会给用户造成一种貌似同时执行的错觉。但因为只有一个物理核心，所以在同一时间点上只能处理一个线程的指令。</li><li><strong>多核CPU</strong>：多核CPU拥有多个物理处理核心，可以同时执行多个线程。每个核心都独立地进行指令执行，因此可以同时运行多个线程，提高了系统的并发性能。多核CPU可以根据具体的负载情况将多个线程分配到不同的核心上执行，从而提高整体的处理能力。</li></ul><h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><p>单核CPU只能实现并发，多核CPU既可以实现并行又可以实现并发</p><ul><li><strong>并行</strong>：同一时刻，多个任务同时执行，每个任务在不同的处理单元上独立执行</li><li><strong>并发</strong>：同一时刻，多个任务交替执行，所有任务在同一个处理单元上执行</li></ul><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/并行和并发.png" style="zoom:50%"><h1 id="多线程的使用"><a href="#多线程的使用" class="headerlink" title="多线程的使用"></a>多线程的使用</h1><h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><p>Thread类是Java中用于创建和操作线程的核心类之一，提供了多种方法来管理线程的生命周期、优先级、状态等属性，常用方法如下</p><table><thead><tr><th>方法名</th><th>介绍</th></tr></thead><tbody><tr><td><code>run()</code></td><td>线程执行体，在线程被调度时执行的操作，单独调用不会启动新线程</td></tr><tr><td><code>start()</code></td><td><code>启动当前线程</code>，使其进入就绪状态并等待CPU调度，底层调用当前线程的run()方法</td></tr><tr><td><code>sellp(long millis)</code></td><td><code>睡眠</code>，使当前线程暂停指定的时间（以毫秒为单位）</td></tr><tr><td><code>yield()</code></td><td><code>线程的礼让</code>，让出当前CPU执行权，让优先级相同或更高的线程先执行，但礼让的时间不确定，所以不一定礼让成功</td></tr><tr><td><code>join()</code></td><td><code>线程的插队</code>，等待插入的线程执行完毕后，再继续执行当前线程</td></tr><tr><td><code>interrupt()</code></td><td><code>中断线程</code>，不是停止，一般用于中断正在休眠的线程</td></tr><tr><td><code>currentThread()</code></td><td>静态方法，返回执行当前代码的线程</td></tr><tr><td><code>getName()</code></td><td>获取当前线程的名称</td></tr><tr><td><code>setName(String name)</code></td><td>设置当前线程名称</td></tr><tr><td><code>getPriority()</code></td><td>获取线程优先级，默认为5，取值范围为1~10</td></tr><tr><td><code>setPriority(int newPriority)</code></td><td><code>设置线程的优先级</code>，取值范围为1~10，数字越大表示优先级越高</td></tr><tr><td><code>getState()</code></td><td>获取线程状态</td></tr><tr><td><code>isAlive()</code></td><td>判断该线程是否仍在运行</td></tr><tr><td><code>stop()</code></td><td>已过时，当执行此方法时，强制结束当前线程</td></tr></tbody></table><h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><h3 id="方式一：继承于Thread类（重点）"><a href="#方式一：继承于Thread类（重点）" class="headerlink" title="方式一：继承于Thread类（重点）"></a>方式一：继承于Thread类（重点）</h3><h4 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h4><ol><li>创建一个继承于Thread类的子类</li><li>重写Thread类的run()</li><li>创建Thread类的子类对象</li><li>通过此子类对象调用start()启动线程</li></ol><h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）通过继承于Thread类，重写Thread类的run()方法，来开发线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">// （2）重写Thread类的run()，写上自己的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// currentThread()：静态方法，返回执行当前代码的线程</span></span><br><span class="line">                System.out.println(i +<span class="string">&quot;线程名：&quot;</span> + Thread.currentThread().getName() +  <span class="string">&quot;   优先级：&quot;</span> + getPriority());</span><br><span class="line">                <span class="comment">// 让线程休眠1秒</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="comment">// 如果i等于5，则退出线程</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// （3）创建Thread类的子类MyThread的对象，可以当做线程使用</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">// （4）通过此子类对象调用start()启动线程</span></span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式二：实现Runnable接口（重点）"><a href="#方式二：实现Runnable接口（重点）" class="headerlink" title="方式二：实现Runnable接口（重点）"></a>方式二：实现Runnable接口（重点）</h3><h4 id="创建步骤-1"><a href="#创建步骤-1" class="headerlink" title="创建步骤"></a>创建步骤</h4><ol><li>创建一个实现Runnable接口的实现类</li><li>实现类重写Runnable接口中的抽象方法run()</li><li>创建Runnable接口实现类的对象</li><li>创建Thread类的对象，将实现类的对象作为参数，传递到Thread类的构造器中</li><li>通过Thread类的对象调用start()启动线程</li></ol><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）通过实现Runnable接口，重写run()方法，来开发线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// （2）重写Runnable接口的run()方法，写上自己的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// currentThread()：静态方法，返回执行当前代码的线程</span></span><br><span class="line">                System.out.println(i +<span class="string">&quot;线程名：&quot;</span> + Thread.currentThread().getName());</span><br><span class="line">                <span class="comment">// 让线程休眠1秒</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="comment">// 如果i等于5，则退出线程</span></span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// （3）创建Runnable接口实现类的对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">// （4）创建Thread类的对象，将实现类的对象作为参数，传递到Thread类的构造器中</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">        <span class="comment">// （5）通过Thread类的对象调用start()启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方式三：实现Callable接口（了解）"><a href="#方式三：实现Callable接口（了解）" class="headerlink" title="方式三：实现Callable接口（了解）"></a>方式三：实现Callable接口（了解）</h3><h4 id="创建步骤-2"><a href="#创建步骤-2" class="headerlink" title="创建步骤"></a>创建步骤</h4><ol><li>创建一个实现Callable接口的实现类</li><li>实现call方法，将此线程需要执行的操作声明在call()中</li><li>创建Callable接口实现类的对象</li><li>创建FutureTask的对象，将Callable接口实现类的对象作为参数传递到FutureTask构造器中</li><li>创建Thread对象，将FutureTask的对象作为参数传递到Thread类的构造器中，并调用start</li><li>获取Callable中call方法的返回值</li></ol><h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// （1）创建一个实现Callable接口的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;</span><br><span class="line">    <span class="comment">// （2）实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行任务...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;call()方法返回值&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// （3）创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// （4）创建FutureTask的对象，将Callable接口实现类的对象，作为参数传递到FutureTask构造器中</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(myThread);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// （5）将FutureTask的对象，作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// （6）获取Callable中call方法的返回值</span></span><br><span class="line">        <span class="comment">// get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程返回的结果为：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三种创建方式的对比"><a href="#三种创建方式的对比" class="headerlink" title="三种创建方式的对比"></a>三种创建方式的对比</h3><p>使用实现Runnable接口创建线程的方式比继承Thread类更推荐一些，因为Java是单继承的语言，通过实现接口可以更灵活地扩展其他类或实现其他接口。如果你只需要简单地启动一个线程，并不需要获得执行结果或向上抛出异常，那么继承Thread类或实现Runnable接口都是可以的。如果你需要获得线程的执行结果，或者需要向上抛出异常，那么实现Callable接口创建线程是更好的选择。</p><ul><li><strong>继承 Thread 类创建线程</strong>：简单直观，但 Java 语言是单继承的，如果继承了 Thread 类，那就不能再继承其他类了。</li><li><strong>实现Runnable接口创建线程</strong>：可以解决单继承的问题，同时继承其他类或实现其他接口，但不能向上抛出异常，不能获得线程的执行结果。</li><li><strong>实现Callable接口创建线程</strong>：可以解决以上问题，可以向上抛出异常，可以通过返回值来获取任务的执行结果。</li></ul><table><thead><tr><th align="left">特性</th><th align="left">继承Thread类</th><th align="left">实现Runnable接口</th><th align="left">实现Callable接口</th></tr></thead><tbody><tr><td align="left">是否可以有返回值和异常</td><td align="left">×</td><td align="left">×</td><td align="left">√</td></tr><tr><td align="left">是否重写run方法</td><td align="left">√</td><td align="left">√</td><td align="left">√</td></tr><tr><td align="left">是否支持多线程共享数据</td><td align="left">√</td><td align="left">√</td><td align="left">√</td></tr><tr><td align="left">是否可以继承其他类</td><td align="left">√</td><td align="left">×</td><td align="left">×</td></tr><tr><td align="left">是否支持Lambda</td><td align="left">×</td><td align="left">√</td><td align="left">√</td></tr><tr><td align="left">是否支持启动线程</td><td align="left">start()</td><td align="left">new Thread().start()</td><td align="left">Executors.newFixedThreadPool等方式</td></tr><tr><td align="left">实现方式的灵活性</td><td align="left">不够灵活，需要继承</td><td align="left">更加灵活，可以顶替其他类的实例</td><td align="left">最灵活，可以按需实现</td></tr></tbody></table><h2 id="线程的终止（stop）"><a href="#线程的终止（stop）" class="headerlink" title="线程的终止（stop）"></a>线程的终止（stop）</h2><p>如果一个线程已经完成了它的任务，或者不再需要运行，或者需要停止执行，那么我们就需要终止该线程，以便回收资源和避免资源的浪费，终止方式有正常结束、异常结束和强制结束等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过继承于Thread类，重写Thread类的run()方法，来开发线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">loop</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLoop</span><span class="params">(<span class="type">boolean</span> loop)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.loop = loop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写Thread类的run()，写上自己的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// currentThread()：静态方法，返回执行当前代码的线程</span></span><br><span class="line">                System.out.println(++sum + <span class="string">&quot;线程名：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;   优先级：&quot;</span> + getPriority());</span><br><span class="line">                <span class="comment">// 让线程休眠1秒</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建Thread类的子类MyThread的对象，可以当做线程使用</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">// 调用start()启动线程</span></span><br><span class="line">        myThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// stop()：已过时，当执行此方法时，强制结束当前线程</span></span><br><span class="line">        <span class="comment">// myThread.stop();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 休眠5秒</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span> * <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置false，使用变量停止线程</span></span><br><span class="line">        myThread.setLoop(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/线程的终止.png" style="zoom:50%"><h2 id="线程的中断（interrupt）"><a href="#线程的中断（interrupt）" class="headerlink" title="线程的中断（interrupt）"></a>线程的中断（interrupt）</h2><p>线程的中断通过 <code>interrupt()</code> 方法实现，用来通知线程停止正在进行的工作，会抛出InterruptedException异常并转移到运行状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过继承于Thread类，重写Thread类的run()方法，来开发线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写Thread类的run()，写上自己的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// currentThread()：静态方法，返回执行当前代码的线程</span></span><br><span class="line">                System.out.println(++sum + <span class="string">&quot;线程名：&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;   优先级：&quot;</span> + getPriority());</span><br><span class="line">                <span class="comment">// 让线程休眠1秒</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程被中断了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建Thread类的子类MyThread1的对象，可以当做线程使用</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">// 调用start()启动线程</span></span><br><span class="line">        myThread.start();</span><br><span class="line">        <span class="comment">// 睡眠5秒</span></span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        <span class="comment">// interrupt()：中断线程，不是停止，一般用于中断正在休眠的线程</span></span><br><span class="line">        myThread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/线程的中断.png" style="zoom:50%"><h2 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h2><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>（1）高优先级的线程要抢占低优先级线程的CPU的执行权，但是只是从概率上讲，高优先级的线程高概率被执行，并不意外着只有当高优先级的线程执行完以后，低优先级的线程才执行</p><table><thead><tr><th>优先级</th><th>值</th></tr></thead><tbody><tr><td>MIN_PRIORITY</td><td>1</td></tr><tr><td>NORM_PRIORITY</td><td>5，默认优先级</td></tr><tr><td>MAX_PRIORITY</td><td>10</td></tr></tbody></table><p>（2）相关方法</p><table><thead><tr><th>方法</th><th>简介</th></tr></thead><tbody><tr><td>getPriority()</td><td>获取线程优先级</td></tr><tr><td>setPriority(int newPriority)</td><td>设置线程的优先级</td></tr></tbody></table><h3 id="线程的礼让（yield）"><a href="#线程的礼让（yield）" class="headerlink" title="线程的礼让（yield）"></a>线程的礼让（yield）</h3><p>yield方法用于暂停当前线程，让出当前CPU执行权，让优先级相同或更高的线程先执行，但礼让的时间不确定，所以不一定礼让成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过继承于Thread类，重写Thread类的run()方法，来开发线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">// 重写Thread类的run()，写上自己的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot;子线程------&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//创建Thread类的子类MyThread1的对象，可以当做线程使用</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        myThread.start();</span><br><span class="line">        <span class="comment">// 设置子线程插队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------主线程&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;=================礼让子线程================&quot;</span>);</span><br><span class="line">                <span class="comment">// 调用Thread的静态方法yield()，设置线程礼让，让主线程暂停执行，将 CPU 时间片让给其他正在运行的线程</span></span><br><span class="line">                Thread.<span class="keyword">yield</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/线程的礼让.png" style="zoom:50%"><h3 id="线程的插队（join）"><a href="#线程的插队（join）" class="headerlink" title="线程的插队（join）"></a>线程的插队（join）</h3><p>创建三个线程A、B、C，使用join()方法来让它们按照顺序执行，每个线程执行完毕后，都会插队主线程，阻塞主线程的执行，等待主线程唤醒并继续执行下一个线程，直到所有线程都执行完毕才会执行主线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过继承于Thread类，重写Thread类的run()方法，来开发线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写Thread类的run()，写上自己的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + name + <span class="string">&quot;开始执行...&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);<span class="comment">// 让线程睡眠1秒，模拟执行任务</span></span><br><span class="line">            System.out.println(<span class="string">&quot;线程&quot;</span> + name + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">threadA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">threadB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">threadC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;线程&quot;</span> + threadA.name + <span class="string">&quot;开始插队主线程&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">        threadA.join(); <span class="comment">// A 执行完成后才会轮到 B</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程&quot;</span> + threadA.name + <span class="string">&quot;插队主线程结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadB.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;线程&quot;</span> + threadB.name + <span class="string">&quot;开始插队主线程&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">        threadB.join(); <span class="comment">// B 执行完成后才会轮到 C</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程&quot;</span> + threadB.name + <span class="string">&quot;插队主线程结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">        threadC.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;线程&quot;</span> + threadC.name + <span class="string">&quot;开始插队主线程&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">        threadC.join();<span class="comment">// C 执行完成后才会轮到 主线程</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程&quot;</span> + threadC.name + <span class="string">&quot;插队主线程结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主线程任务开始执行...&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程任务执行完毕&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/线程的插队.png" style="zoom:50%"><h1 id="线程的分类"><a href="#线程的分类" class="headerlink" title="线程的分类"></a>线程的分类</h1><h2 id="用户线程setDeamon-false"><a href="#用户线程setDeamon-false" class="headerlink" title="用户线程setDeamon(false)"></a>用户线程setDeamon(false)</h2><p>用户线程也叫工作线程，指程序中创建的普通线程，即使所有用户线程都结束了，程序仍会继续执行，不会影响 JVM 的退出，直到所有非守护线程都执行完毕，用户线程可以通过调用 Thread 类的 setDaemon(false) 方法，将其设置为非守护线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过继承于Thread类，重写Thread类的run()方法，来开发线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">// 重写Thread类的run()，写上自己的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程------&quot;</span>);</span><br><span class="line">                <span class="comment">// 让线程休眠1秒</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建Thread类的子类MyThread的对象，可以当做线程使用</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置线程为非守护线程（默认即为非守护线程）</span></span><br><span class="line">        myThread.setDaemon(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        myThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程循环输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------主线程&quot;</span> + i);</span><br><span class="line">            <span class="comment">// 让当前线程（即主线程）休眠1秒</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/用户线程.png" style="zoom:50%"><h2 id="守护线程setDeamon-true"><a href="#守护线程setDeamon-true" class="headerlink" title="守护线程setDeamon(true)"></a>守护线程setDeamon(true)</h2><p>作用是为其他线程提供服务，无论其他线程是否执行完毕，只要守护线程的任务执行完毕，JVM 就会自动退出，常见的守护线程：垃圾回收机制、异常处理线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过继承于Thread类，重写Thread类的run()方法，来开发线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">// 重写Thread类的run()，写上自己的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 无限循环</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程------&quot;</span>);</span><br><span class="line">                <span class="comment">// 让线程休眠1秒</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">// 创建Thread类的子类MyThread的对象，可以当做线程使用</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将该线程设置为守护线程，当主线程结束时，守护线程自动结束（设置守护进程 应在启动线程之前）</span></span><br><span class="line">        myThread.setDaemon(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        myThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程循环输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;--------主线程&quot;</span> + i);</span><br><span class="line">            <span class="comment">// 让当前线程（即主线程）休眠1秒</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/守护线程.png" style="zoom:50%"><h1 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h1><p>线程的生命周期是指线程从创建到终止的整个过程，可以分为以下几个阶段：</p><ol><li><strong>新建（New）</strong>：当一个 Thread 类型的实例被创建（new），处于新建状态，此时该线程还没有被启动</li><li><strong>就绪（Runnable）</strong>：新建状态的线程调用 start() 方法后，线程进入就绪状态，等待系统分配 CPU 使用权，此时线程有执行资格，但是没有执行权</li><li><strong>运行（Running）</strong>：就绪的线程被调度并获得CPU资源时，便进入运行状态，开始执行 run() 方法中的操作和功能，此时线程有执行资格，同时也有执行权</li><li><strong>阻塞（Blocked）</strong>：当线程因为某些原因被阻塞时，例如线程在等待获取锁时，如果锁已经被其他线程占用，会等待其他线程释放锁，进入阻塞状态，此时线程没有执行资格，也没有执行权</li><li><strong>等待（Waiting）</strong>：线程调用了 Object.wait()、Thread.join() 等方法时，将进入等待状态，等待其他线程调用相应的 notify()、notifyAll() 方法唤醒或等待Thread.join()插队完毕，如果线程在等待一定时间后，如果还没有接收到唤醒信号，就会一直处于等待状态，如果线程使用 interrupt() 方法中断，它会抛出InterruptedException异常并转移到运行状态，此时线程没有执行资格，也没有执行权</li><li><strong>限时等待（Timed Waiting）</strong>：线程调用了Thread.sleep()、Object.wait(timeout)、Thread.join(timeout)等方法后，将进入限时等待状态，等调用的时间到达或者等待其他线程调用相应的唤醒方法，如果线程使用 interrupt() 方法中断，会抛出InterruptedException异常并转移到运行状态，此时线程没有执行资格，也没有执行权</li><li><strong>终止（Terminated）</strong>：当线程执行完毕（run() 方法 &#x2F; call() 方法执行完毕）、发生了异常而导致线程停止、调用Thread.stop()方法，线程将进入终止状态，此时线程死亡，变成垃圾，不能再重复使用</li></ol><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/线程的生命周期.png" style="zoom:50%"><h1 id="线程安全性问题"><a href="#线程安全性问题" class="headerlink" title="线程安全性问题"></a>线程安全性问题</h1><h2 id="线程安全问题简介"><a href="#线程安全问题简介" class="headerlink" title="线程安全问题简介"></a>线程安全问题简介</h2><p>Java中的线程安全性问题是指在多线程环境下，多个线程同时访问共享资源时可能导致的数据不一致或者意外行为的情况。</p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul><li><strong>原子性</strong>：原子性指的是一个操作是不可中断的，要么全部执行完成，要么完全不执行。</li><li><strong>可见性</strong>：可见性指的是当一个线程对共享变量进行修改后，其他线程能够立即看到修改的结果。</li><li><strong>有序性</strong>：有序性指的是程序执行的顺序与代码的编写顺序是一致的。</li></ul><h3 id="常见的线程安全性问题"><a href="#常见的线程安全性问题" class="headerlink" title="常见的线程安全性问题"></a>常见的线程安全性问题</h3><ul><li><p><strong>数据竞争问题（Race Condition）</strong>：多个线程并发访问和修改共享数据时，一个线程修改或访问了另一个线程未修改完毕的数据，可能导致数据的不一致、数据丢失或造成错误。</p></li><li><p><strong>线程死锁问题（Deadlock）</strong>：多个线程相互等待对方释放持有的资源，但不肯相让，导致的互相等待（死锁）</p></li><li><p><strong>内存可见性问题</strong>：当一个线程修改了共享变量的值后，其他线程无法立即看到最新值的情况</p></li></ul><h2 id="数据竞争问题"><a href="#数据竞争问题" class="headerlink" title="数据竞争问题"></a>数据竞争问题</h2><h3 id="模拟数据竞争问题"><a href="#模拟数据竞争问题" class="headerlink" title="模拟数据竞争问题"></a>模拟数据竞争问题</h3><ol><li>创建MyThread的实例myThread，并创建两个线程thread1和thread2。</li><li>启动两个线程，每个线程在run()方法中执行10000次<code>counter = counter + 1</code>的操作，即将<code>counter</code>累加1。</li><li>调用<code>thread1.join()</code>和<code>thread2.join()</code>方法，等待两个子线程执行完成</li><li>执行代码，计数器的结果应该是20000，但是发现输出最终的<code>counter</code>值会有偏差，出现了数据丢失问题</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过实现Runnable，重写run()方法，来开发线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写接口的run()方法，编写线程的执行逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            counter = counter + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();<span class="comment">// 插队主线程，等待线程1完成</span></span><br><span class="line">        thread2.join();<span class="comment">// 插队主线程，等待线程2完成</span></span><br><span class="line">        System.out.println(<span class="string">&quot;累加器的值: &quot;</span> + counter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>使用互斥锁（Mutex）或 synchronized 关键字来保护共享数据的访问，在同一时间只允许一个线程访问。</li><li>使用原子操作类（Atomic Class）来执行共享数据的非阻塞更新。</li><li>使用线程安全的数据结构，如 ConcurrentHashMap，它提供了内部一致性保证。</li></ul><h2 id="线程死锁问题"><a href="#线程死锁问题" class="headerlink" title="线程死锁问题"></a>线程死锁问题</h2><h3 id="死锁产生的原因？"><a href="#死锁产生的原因？" class="headerlink" title="死锁产生的原因？"></a>死锁产生的原因？</h3><ul><li><strong>互斥条件</strong>：资源不能被同时占用，即在某一时刻只能由一个进程使用</li><li><strong>请求与保持条件</strong>：进程已经保持至少一个资源，并且正在等待获取其他的资源，但是这些资源可能被其他进程占用</li><li><strong>不可剥夺条件</strong>：进程已经获得的资源，在未使用完之前，不能被其他进程强制抢占</li><li><strong>循环等待条件</strong>：若干进程之间形成一种头尾相接的循环等待资源关系</li></ul><h3 id="模拟线程死锁"><a href="#模拟线程死锁" class="headerlink" title="模拟线程死锁"></a>模拟线程死锁</h3><ol><li><p>定义两个线程 “线程A” 和 “线程B”，每个线程都需要获取资源 A 和资源 B。</p></li><li><p>线程 A 获取了资源 A 后，需要获取资源 B</p></li><li><p>线程 B 已经获取了资源 B，需要获取资源 A</p></li><li><p>两个线程就陷入了互相等待的状态，导致死锁</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过继承于Thread类，重写Thread类的run()方法，来开发线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">resourceA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">resourceB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">currentThreadName</span> <span class="operator">=</span> Thread.currentThread().getName();</span><br><span class="line">        <span class="keyword">if</span> (currentThreadName.equals(<span class="string">&quot;线程A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                System.out.println(currentThreadName + <span class="string">&quot; 获取了资源A&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(currentThreadName + <span class="string">&quot; 需要资源B&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                    System.out.println(currentThreadName + <span class="string">&quot; 获取了资源B&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (currentThreadName.equals(<span class="string">&quot;线程B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                System.out.println(currentThreadName + <span class="string">&quot; 获取了资源B&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(currentThreadName + <span class="string">&quot; 需要资源A&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    System.out.println(currentThreadName + <span class="string">&quot; 获取了资源A&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟线程死锁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread, <span class="string">&quot;线程A&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(myThread, <span class="string">&quot;线程B&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        <span class="comment">// 睡眠三秒，让线程有足够的时间去获取资源</span></span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="comment">// 线程状态（BLOCKED）</span></span><br><span class="line">        System.out.println(<span class="string">&quot;线程A状态：&quot;</span> + thread1.getState());</span><br><span class="line">        System.out.println(<span class="string">&quot;线程B状态：&quot;</span> + thread2.getState());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/线程死锁.png" style="zoom:50%"><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><strong>加锁顺序</strong>：确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。</li><li><strong>超时机制</strong>：当请求资源的等待时间超过一定阈值时，放弃请求并进行回退策略。</li><li><strong>死锁检测</strong>：JDK提供了两种方式来给我们检测死锁位置，图形化工具JConsole和命令行工具Jstack</li></ul><h2 id="内存可见性问题"><a href="#内存可见性问题" class="headerlink" title="内存可见性问题"></a>内存可见性问题</h2><h3 id="模拟内存可见性问题"><a href="#模拟内存可见性问题" class="headerlink" title="模拟内存可见性问题"></a>模拟内存可见性问题</h3><ul><li>线程1通过循环检测<code>flag</code>是否为0，如果是0则继续循环，直到<code>flag</code>的值被线程2更新为非0，循环结束后输出提示信息。</li><li>线程2使用<code>Scanner</code>类从控制台接收一个整数，并将其赋值给<code>flag</code>，从而修改<code>flag</code>的值不为0。</li><li>线程1永远无法检测到线程2对<code>counter.flag</code>的修改，导致死循环。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 线程1：检测flag是否为0，循环结束后输出提示信息</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (Counter.flag == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 空循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程一循环结束，flag：&quot;</span> + Counter.flag);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 线程2：从控制台输入一个整数赋值给flag</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入一个整数:&quot;</span>);</span><br><span class="line">            Counter.flag = scanner.nextInt();</span><br><span class="line">            System.out.println(<span class="string">&quot;修改完毕，flag：&quot;</span> + Counter.flag);</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();<span class="comment">// 启动线程一</span></span><br><span class="line">        t2.start();<span class="comment">// 启动线程二</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Counter类，用于保存共享变量flag</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 确保线程对其进行读取和写入操作时的可见性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li><strong>使用 volatile 关键字修饰共享变量</strong>：<code>volatile</code>关键字修饰的变量可以确保线程对其进行读取和写入操作时的可见性。当一个线程修改了<code>volatile</code>修饰的变量的值时，该变量的新值会立即被其他线程看到，避免了线程间的数据不一致问题。</li><li><strong>使用 synchronized 或 Lock 来加锁</strong>：进入临界区前将共享变量刷新到主内存，退出临界区后从主内存更新缓存。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 线程1：检测flag是否为0，循环结束后输出提示信息</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (Counter.flag == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 空循环</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程一循环结束，flag：&quot;</span> + Counter.flag);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 线程2：从控制台输入一个整数赋值给flag</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入一个整数:&quot;</span>);</span><br><span class="line">            Counter.flag = scanner.nextInt();</span><br><span class="line">            System.out.println(<span class="string">&quot;修改完毕，flag：&quot;</span> + Counter.flag);</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();<span class="comment">// 启动线程一</span></span><br><span class="line">        t2.start();<span class="comment">// 启动线程二</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Counter类，用于保存共享变量flag</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 确保线程对其进行读取和写入操作时的可见性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决线程安全性问题的方案"><a href="#解决线程安全性问题的方案" class="headerlink" title="解决线程安全性问题的方案"></a>解决线程安全性问题的方案</h2><p>在多线程编程中，当多个线程同时访问和修改同一个变量时，可能会导致数据竞争和不一致的问题。为了解决这个线程安全问题，可以采用两种常见的解决方案：</p><ul><li><strong>时间换空间</strong>：通过使用同步机制（如synchronized关键字或Lock对象），确保在同一时间只有一个线程可以访问共享变量。当一个线程正在访问共享变量时，其他线程需要等待，从而避免了并发访问导致的线程安全问题。这种方式以时间换取了空间，但可能会引入线程竞争和上下文切换的开销。</li><li><strong>空间换时间</strong>：通过使用ThreadLocal将共享变量复制多份，每个线程都拥有自己独立的副本。这样，各个线程之间相互独立，彼此的操作不会相互干扰，避免了数据竞争和不一致的问题。虽然这种方式增加了内存消耗，但提高了程序的并发性能。</li></ul><h1 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h1><h2 id="线程同步的概念"><a href="#线程同步的概念" class="headerlink" title="线程同步的概念"></a>线程同步的概念</h2><p>线程同步是一种多线程编程的机制，通常用于协调多个线程之间对共享资源的访问和操作，以避免数据竞争和其他并发问题的发生</p><h2 id="线程同步的优点"><a href="#线程同步的优点" class="headerlink" title="线程同步的优点"></a>线程同步的优点</h2><ul><li><strong>避免数据竞争和并发问题</strong>：多线程环境下，如果多个线程同时访问共享资源而没有同步机制，就会导致数据错误或程序崩溃，线程同步技术能够有效避免这种情况的发生，确保共享资源的完整性。</li><li><strong>确保共享资源的完整性</strong>：线程同步技术可以保证多个线程对共享资源的访问和操作是有序的，并且只能有一个线程进行，避免了不正确的并发访问，确保了共享资源的完整性。</li><li><strong>解决并发问题</strong>：线程同步技术能够有效解决多线程环境下的并发问题，确保程序的正确性。</li></ul><h2 id="线程同步的缺点"><a href="#线程同步的缺点" class="headerlink" title="线程同步的缺点"></a>线程同步的缺点</h2><ul><li><strong>导致程序性能下降</strong>：因为只能有一个线程进行同步代码的访问和操作，其他线程需要等待，所以会导致执行效率下降，影响程序的性能。</li><li><strong>可能引起死锁</strong>：如果同步代码中出现了交叉等待的情况，就可能形成死锁，导致程序无法继续执行，甚至崩溃。</li><li><strong>容易出错</strong>：线程同步涉及到复杂的并发控制问题，需要精确控制线程的执行顺序和状态，容易出现各种锁定、竞争等问题，需要仔细考虑和测试。</li></ul><h2 id="线程同步方式一：使用synchronized关键字"><a href="#线程同步方式一：使用synchronized关键字" class="headerlink" title="线程同步方式一：使用synchronized关键字"></a>线程同步方式一：使用synchronized关键字</h2><p>（1）使用<code>synchronized</code>关键字可以实现线程同步，从而确保同一时间，只有一个线程可以访问被保护的代码块或方法</p><p>（2）根据<code>synchronized</code>关键字位置不同分为同步代码块和同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步方法</span></span><br><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值 方法名(方法形参)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步代码块</span></span><br><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;需要被同步的代码&#125;</span><br></pre></td></tr></table></figure><p>（3）同步方法和同步代码块代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法中加入synchronized关键字，就是同步方法，该线程完成操作，其他线程才能对该内存地址进行操作</span></span><br><span class="line">    <span class="comment">// 非静态的同步方法，此时互斥锁在 this对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程同步---&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的同步方法，此时互斥锁在 当前类本身（MyThread.class）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;线程同步---&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非静态的同步方法，此时互斥锁在 this对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 同步代码块</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程同步---&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态的同步方法，此时互斥锁在 当前类本身（MyThread.class）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 同步代码块</span></span><br><span class="line">        <span class="keyword">synchronized</span> (MyThread.class) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;线程同步---&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程同步方式二：使用Lock接口"><a href="#线程同步方式二：使用Lock接口" class="headerlink" title="线程同步方式二：使用Lock接口"></a>线程同步方式二：使用Lock接口</h2><p>（1）除了使用关键字synchronized外，Java还提供了<code>Lock接口</code>来实现线程同步</p><p>（2）Lock接口是Java提供的一种线程同步机制，可以实现对共享资源的互斥访问，但Lock接口不能直接实例化，一般使用实现了Lock接口的ReentrantLock类来创建锁对象</p><p>（3）ReentrantLock是一个可重入锁，支持公平锁和非公平锁，可以控制多个线程对共享资源的访问，类中的常用方法如下</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>lock()</code></td><td>尝试获取锁，如果锁已经被其他线程获取，则当前线程会阻塞。如果当前线程已经持有锁，则可以重入获取锁，而不会被阻塞。</td></tr><tr><td><code>tryLock()</code></td><td>尝试获取锁，如果锁没有被其他线程获取，则获取锁并返回true；否则返回false，不会阻塞当前线程。</td></tr><tr><td><code>unlock()</code></td><td>释放锁，与lock()方法对应使用。只有当前线程获得锁后才能释放锁，否则会抛出IllegalMonitorStateException异常。</td></tr><tr><td><code>newCondition()</code></td><td>创建一个Condition对象，该对象可以用于实现更加复杂的线程同步逻辑，比如多个线程协作完成某项任务。</td></tr><tr><td><code>isFair()</code></td><td>判断当前锁是否公平锁。</td></tr><tr><td><code>isHeldByCurrentThread()</code></td><td>判断当前线程是否持有锁。</td></tr><tr><td><code>getHoldCount()</code></td><td>获取当前线程在已经获取锁的情况下重入的次数，即获取锁的次数。</td></tr><tr><td><code>getQueueLength()</code></td><td>获取等待锁的线程数。</td></tr><tr><td><code>isLocked()</code></td><td>判断当前锁是否被任意一个线程获取。</td></tr></tbody></table><p>（4）使用ReentrantLock类实现线程同步案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过实现Runnable，重写run()方法，来开发线程</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 实例化锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写接口的run()方法，写上自己的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 使用lock锁住关键代码段，只有一个线程能够进入</span></span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行操作</span></span><br><span class="line">                System.out.println(<span class="string">&quot;线程同步---&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                lock.unlock(); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="synchronized与ReentrantLock的异同"><a href="#synchronized与ReentrantLock的异同" class="headerlink" title="synchronized与ReentrantLock的异同"></a>synchronized与ReentrantLock的异同</h2><p>使用优先顺序：ReentrantLock -&gt; 同步代码块 -&gt; 同步方法</p><table><thead><tr><th>特性</th><th>ReentrantLock</th><th>synchronized</th></tr></thead><tbody><tr><td>是否可重入</td><td>是，同一个线程可以多次加锁</td><td>是，同一个线程可多次进入同步代码块或方法</td></tr><tr><td>是否公平锁</td><td>可以选择公平锁或非公平锁</td><td>默认为非公平锁</td></tr><tr><td>锁的粒度</td><td>可以设置不同粒度的锁，提高并发性能</td><td>锁整个方法或代码块</td></tr><tr><td>锁的获取方式</td><td><code>tryLock()</code> 方法可以尝试非阻塞地获取锁</td><td>只能等待锁释放</td></tr><tr><td>等待通知机制</td><td>可以通过 <code>Condition</code> 接口实现复杂的线程间通信</td><td>无</td></tr><tr><td>中断处理</td><td>支持</td><td>不支持</td></tr><tr><td>可轮询的锁请求</td><td>支持</td><td>不支持</td></tr><tr><td>使用方式</td><td>需要手动获取和释放锁，需要在 finally 块中确保锁被正确释放</td><td>自动获取和释放锁</td></tr></tbody></table><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>volatile关键字是一种轻量级的同步机制，使用volatile修饰的变量对所有线程可见，即一个线程修改了该变量的值，其他线程能够立即看到最新的值。</p><ol><li>为了提高程序的运行效率，编译器会对经常访问的变量进行缓存优化，将其缓存在寄存器或高速缓存中。当程序读取这些变量时，可以直接从缓存中获取值，而不需要每次都去访问内存，从而提高程序的执行效率。</li><li>然而，在多线程环境下，由于每个线程都有自己的缓存，当一个线程修改了变量的值时，其他线程可能仍然使用旧的缓存值，导致数据不一致。为了解决这个问题，可以使用volatile关键字修饰需要共享的变量。</li><li>使用volatile修饰的变量，编译器不会对该变量进行缓存优化，每次访问时都直接从主内存中读取值或写入值。当一个线程修改了volatile修饰的变量，其他线程立即能够看到最新的值，从而避免了数据不一致的问题。</li><li>需要注意的是，volatile关键字只保证变量的可读性和可写性，并不能保证对volatile变量的操作是原子性。如果需要保证多个操作的原子性，仍然需要使用锁或其他的同步机制。</li></ol><h2 id="ThreadLocal线程本地变量"><a href="#ThreadLocal线程本地变量" class="headerlink" title="ThreadLocal线程本地变量"></a>ThreadLocal线程本地变量</h2><h2 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h2><p>（1）ThreadLocal是Java中的一个类，用于在多线程环境下实现线程局部变量。它提供了一种机制，使得每个线程都可以拥有自己独立的变量副本，而不会与其他线程共享。<code>该变量对其他线程而言是隔离的</code>，也就是说<code>该变量是当前线程独有的变量</code>。</p><p>（2）ThreadLocal的主要作用是在多线程场景下，将数据与线程进行绑定，使得每个线程都拥有自己独立的数据副本，互不干扰，解决共享变量的线程安全问题。</p><p>（3）一般都会将ThreadLocal声明成一个静态字段，同时初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Object&gt; threadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>get()</code></td><td>获取当前线程持有的变量的值。如果没有设置过变量，则返回初始值（null）或通过<code>initialValue()</code>方法指定的初始值。</td></tr><tr><td><code>set(T value)</code></td><td>设置当前线程持有的变量的值为指定的值。</td></tr><tr><td><code>remove()</code></td><td>删除当前线程持有的变量。相当于将该变量从当前线程的ThreadLocalMap中移除。</td></tr><tr><td><code>initialValue()</code></td><td>返回初始化的变量值。该方法的默认实现返回null，可以通过继承ThreadLocal并重写该方法来指定自定义的初始化值。</td></tr><tr><td><code>withInitial(Supplier&lt;? extends T&gt; supplier)</code></td><td>返回一个新的ThreadLocal对象，并将其初始值设置为由给定的Supplier提供的值。该方法可以方便地通过lambda表达式或方法引用指定初始化值。</td></tr><tr><td><code>getMap(Thread t)</code></td><td>返回给定线程t关联的ThreadLocalMap对象。ThreadLocalMap用于存储每个线程对应的ThreadLocal变量。</td></tr><tr><td><code>createMap(Thread t, T firstValue)</code></td><td>创建一个新的ThreadLocalMap对象，并将给定线程t关联到该Map。同时将初始值firstValue设置为该线程的ThreadLocal变量的值。</td></tr></tbody></table><h1 id="售票案例"><a href="#售票案例" class="headerlink" title="售票案例"></a>售票案例</h1><h2 id="线程不安全的售票"><a href="#线程不安全的售票" class="headerlink" title="线程不安全的售票"></a>线程不安全的售票</h2><p>假设有3个售票员同时卖票，一共有100张票。每个售票员会执行一个循环，每次从总票数中减去1，并输出当前售票员的编号和剩余票数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过实现Runnable，重写run()方法，来开发线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketSeller</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一百张票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 总票数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写接口的run()方法，编写线程的执行逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 卖出了第 &quot;</span> + num + <span class="string">&quot; 张票，剩余 &quot;</span> + --num + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TicketSeller</span> <span class="variable">seller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketSeller</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(seller, <span class="string">&quot;售票员1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(seller, <span class="string">&quot;售票员2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(seller, <span class="string">&quot;售票员3&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/线程不安全的售票.png" style="zoom:50%"><p>由于多个线程同时对共享资源进行修改，并没有进行同步控制，可能出现以下的线程不安全现象</p><ol><li>出现重复售票：由于多个线程同时访问tickets变量并修改它，可能导致多个线程同时卖出同一张票，从而造成售票的重复。</li><li>出现负数售票：由于多个线程同时访问tickets变量并修改它，在最后几张票的情况下，一个线程将tickets减为1时，另一个线程仍然有可能减为0，进而导致tickets变为负数，从而造成程序异常。</li><li>票数不准确：由于多个线程同时访问tickets变量并修改它，可能导致票数不准确。例如，有时候可能只卖出了99张票，或者卖出了101张票。</li></ol><h2 id="使用synchronized关键字解决售票问题"><a href="#使用synchronized关键字解决售票问题" class="headerlink" title="使用synchronized关键字解决售票问题"></a>使用synchronized关键字解决售票问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过实现Runnable，重写run()方法，来开发线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketSeller</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一百张票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 总票数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写接口的run()方法，写上自己的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 同步控制代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 卖出了第 &quot;</span> + num + <span class="string">&quot; 张票，剩余 &quot;</span> + --num + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TicketSeller</span> <span class="variable">seller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketSeller</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(seller, <span class="string">&quot;售票员1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(seller, <span class="string">&quot;售票员2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(seller, <span class="string">&quot;售票员3&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/使用synchronized关键字解决售票问题.png" style="zoom:50%"><h2 id="使用Lock接口解决售票问题"><a href="#使用Lock接口解决售票问题" class="headerlink" title="使用Lock接口解决售票问题"></a>使用Lock接口解决售票问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过实现Runnable，重写run()方法，来开发线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TicketSeller</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 定义一百张票</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 总票数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">// 创建一个ReentrantLock对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写接口的run()方法，写上自己的逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                lock.lock(); <span class="comment">// 获取锁</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 卖出了第 &quot;</span> + num + <span class="string">&quot; 张票，剩余 &quot;</span> + --num + <span class="string">&quot; 张票&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock(); <span class="comment">// 释放锁</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">TicketSeller</span> <span class="variable">seller</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TicketSeller</span>();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(seller, <span class="string">&quot;售票员1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(seller, <span class="string">&quot;售票员2&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(seller, <span class="string">&quot;售票员3&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/使用Lock接口解决售票问题.png" style="zoom:50%"><h1 id="线程的阻塞"><a href="#线程的阻塞" class="headerlink" title="线程的阻塞"></a>线程的阻塞</h1><h2 id="常见阻塞方式"><a href="#常见阻塞方式" class="headerlink" title="常见阻塞方式"></a>常见阻塞方式</h2><table><thead><tr><th>阻塞状态</th><th>简介</th></tr></thead><tbody><tr><td>synchronized同步阻塞</td><td>当多个线程同时访问同一个对象的 synchronized 代码块或方法时，只有一个线程获得了锁<br>其他线程需要等待该锁被释放后才能执行，这个过程称为 synchronized 阻塞</td></tr><tr><td>wait()等待通知阻塞</td><td>运行状态中的线程执行 <code>wait()</code> 方法，使线程进入到等待阻塞状态<br>直到另一个线程调用该对象的 notify() 或 notifyAll() 方法来通知它继续执行，这个过程称为等待通知阻塞</td></tr><tr><td>sleep()睡眠阻塞</td><td>当线程调用 <code>Thread.sleep()</code> 方法时，会进入休眠状态<br>等待指定的时间后才能继续执行，这个过程称为 sleep 阻塞</td></tr><tr><td>join()线程插队阻塞</td><td>当一个线程调用另一个线程的 <code>join()</code> 方法时，它将被阻塞，直到被等待线程执行完毕为止</td></tr></tbody></table><h2 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h2><p>wait()、notify()、notifyAll()方法定义在Object类中，必须使用在同步代码块或同步方法中，否则会出现异常</p><table><thead><tr><th>方法名</th><th>描述</th><th>状态</th></tr></thead><tbody><tr><td><code>sleep()</code></td><td>使当前线程休眠指定的时间（单位毫秒），进入 TIMED_WAITING 状态。</td><td>阻塞</td></tr><tr><td><code>wait()</code></td><td>当前线程进入阻塞状态并释放锁，等待某个对象使用notify()或notifyAll()方法唤醒，进入WAITING状态</td><td>阻塞</td></tr><tr><td><code>notify()</code></td><td>唤醒被wait()的一个线程，使其进入可运行状态，但不释放对象锁<br>如果有多个线程被wait()，则任意唤醒其中一个线程。</td><td>非阻塞</td></tr><tr><td><code>notifyAll()</code></td><td>唤醒被wait()的所有线程，使它们进入可运行状态，但不释放对象锁。</td><td>非阻塞</td></tr><tr><td><code>yield()</code></td><td>暂停当前线程的执行，并放弃 CPU 的时间片，让其他线程有机会执行。</td><td>非阻塞</td></tr><tr><td><code>park()</code></td><td>暂停当前线程的执行，并使其进入 WAITING 状态，等待 unpark() 方法的唤醒。</td><td>阻塞</td></tr><tr><td><code>join()</code></td><td>等待目标线程执行结束，并且将目标线程的返回值传递给调用 join() 的线程。</td><td>阻塞</td></tr></tbody></table><h2 id="sellp-和wait-异同"><a href="#sellp-和wait-异同" class="headerlink" title="sellp()和wait()异同"></a>sellp()和wait()异同</h2><p>sellp()和wait()一旦执行，都可以使当前的线程进入阻塞状态，但是存在一些区别</p><table><thead><tr><th>特征</th><th>sleep() 方法</th><th>wait() 方法</th></tr></thead><tbody><tr><td>所处位置</td><td>Thread类中</td><td>Object 类中</td></tr><tr><td>调用方式</td><td>sleep() 方法是静态的，可以在任何地方被调用</td><td>必须在 synchronized 块或方法中被调用</td></tr><tr><td>等待时间</td><td>指定时间后自动唤醒</td><td>需要另外线程调用 notify() 或 notifyAll() 才能被唤醒</td></tr><tr><td>线程状态</td><td>进入 TIMED_WAITING 状态</td><td>进入 WAITING 状态</td></tr><tr><td>锁释放</td><td>不释放持有的锁</td><td>释放持有的锁</td></tr><tr><td>异常处理</td><td>不会抛出 InterruptedException 异常</td><td>会抛出 InterruptedException 异常</td></tr></tbody></table><h2 id="synchronized同步阻塞"><a href="#synchronized同步阻塞" class="headerlink" title="synchronized同步阻塞"></a>synchronized同步阻塞</h2><p>由于线程在执行 synchronized 块时会占用锁，所以当 Thread A 获取到锁并开始执行 synchronized 块时，Thread B 需要等待 Thread A 释放锁之后才能获取锁并执行 synchronized 块，这样就会出现同步阻塞的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过实现Runnable，重写run()方法，来开发线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedExample</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写接口的run()方法，编写线程的执行逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedExample.class) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始执行任务&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                count++;<span class="comment">// 对共享资源count进行加1操作</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行了第&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot;次操作，count=&quot;</span> + count);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行完毕&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SynchronizedExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedExample</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(example, <span class="string">&quot;线程A&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(example, <span class="string">&quot;线程B&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/同步阻塞.png" style="zoom:50%"><h2 id="wait-等待通知阻塞"><a href="#wait-等待通知阻塞" class="headerlink" title="wait()等待通知阻塞"></a>wait()等待通知阻塞</h2><ol><li>创建WaitNotifyExample实例example，构造两个线程thread1和thread2，并且启动这两个线程。</li><li>当启动线程后，线程A和线程B都进入了run方法，并在synchronized块中使用 lock.wait() 进入等待通知状态</li><li>主线程睡眠一秒钟后，调用 lock.notifyAll() 方法通知所有等待的线程唤醒</li><li>被唤醒后的线程输出收到通知的信息并继续执行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过实现Runnable，重写run()方法，来开发线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyExample</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写接口的run()方法，编写线程的执行逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取了锁&quot;</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;等待通知...&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 使用 lock.wait() 进入等待状态并释放锁</span></span><br><span class="line">                lock.wait();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 被唤醒后，继续执行任务</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;被唤醒，继续执行...&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">WaitNotifyExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitNotifyExample</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(example, <span class="string">&quot;线程A&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(example, <span class="string">&quot;线程B&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程等待 1 秒钟，等待线程进入等待状态</span></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程获取锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;开始唤醒等待中的线程&quot;</span>);</span><br><span class="line">            lock.notifyAll();<span class="comment">// 使用 lock.notifyAll() 方法通知所有等待的线程唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/等待通知阻塞.png" style="zoom:50%"><h2 id="sleep-睡眠阻塞"><a href="#sleep-睡眠阻塞" class="headerlink" title="sleep()睡眠阻塞"></a>sleep()睡眠阻塞</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过实现Runnable，重写run()方法，来开发线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SleepExample</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写接口的run()方法，编写线程的执行逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取了锁&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 线程休眠3秒钟</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始休眠&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 休眠结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 休眠结束后继续执行任务</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行任务&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SleepExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SleepExample</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(example, <span class="string">&quot;线程A&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/sleep()阻塞.png" style="zoom:50%"><h2 id="join-线程插队阻塞"><a href="#join-线程插队阻塞" class="headerlink" title="join()线程插队阻塞"></a>join()线程插队阻塞</h2><ol><li>创建一个 JoinExample 的实例，构造两个线程thread1和thread2，并且启动这两个线程</li><li>主线程调用 thread2.start() 使线程A进入就绪状态</li><li>主线程调用 thread1.join() 方法，将主线程阻塞</li><li>线程A开始执行</li><li>线程A执行结束后，主线程执行thread2.start()使线程B进入就绪状态</li><li>主线程输出 “主线程继续执行” 的信息，因为线程B是在主线程中等待的，只有在主线程所有任务执行完成之后才会开始执行</li><li>线程B开始执行</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过实现Runnable，重写run()方法，来开发线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinExample</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 重写接口的run()方法，编写线程的执行逻辑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始执行任务&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 执行完毕&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">JoinExample</span> <span class="variable">example</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JoinExample</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(example, <span class="string">&quot;线程A&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(example, <span class="string">&quot;线程B&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程A</span></span><br><span class="line">        thread1.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过join方法阻塞主线程，等待线程1执行结束后再继续执行</span></span><br><span class="line">        thread1.join();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动线程B</span></span><br><span class="line">        thread2.start();</span><br><span class="line">        System.out.println(<span class="string">&quot;主线程继续执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/join()阻塞.png" style="zoom:50%"><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="什么是线程池？"><a href="#什么是线程池？" class="headerlink" title="什么是线程池？"></a>什么是线程池？</h2><p>线程池是指预先创建一定数量的线程，放置到一个池中，等待调用任务，任务完成后，该线程并不会被销毁，而是重新放回线程池中等待下一次调用</p><h2 id="为什么使用线程池？"><a href="#为什么使用线程池？" class="headerlink" title="为什么使用线程池？"></a>为什么使用线程池？</h2><p>在高并发情况下，需要频繁地创建线程和销毁线程，对性能影响很大。有了线程池，可以提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁，实现重复利用，提高系统性能和效率，以下是线程池的优点：</p><ul><li><strong>降低系统消耗</strong>：重复利用已经创建的线程降低线程创建和销毁造成的资源消耗</li><li><strong>提高响应速度</strong>：当任务到达时，任务不需要等到线程创建就可以立即执行</li><li><strong>提供线程管理</strong>：可以通过设置合理分配、调优、监控</li></ul><h2 id="线程池的常见相关接口和类"><a href="#线程池的常见相关接口和类" class="headerlink" title="线程池的常见相关接口和类"></a>线程池的常见相关接口和类</h2><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/线程池的常见相关接口和类.png" style="zoom:50%"><h3 id="Executors线程池工厂类"><a href="#Executors线程池工厂类" class="headerlink" title="Executors线程池工厂类"></a>Executors线程池工厂类</h3><p><code>Executors</code> 是 Java 中提供的线程池工厂类，它包含一些静态方法用于创建不同类型的线程池。</p><p><code>Executors</code> 是一个类而不是接口，提供了一些静态工厂方法来创建不同类型的线程池。</p><table><thead><tr><th>Executors类中方法</th><th>简介</th></tr></thead><tbody><tr><td><code>newFixedThreadPool(nThreads)</code></td><td>创建固定大小的线程池，线程池中的线程数量固定为 <code>nThreads</code>。</td></tr><tr><td><code>newSingleThreadExecutor()</code></td><td>创建只有一个线程的线程池。</td></tr><tr><td><code>newCachedThreadPool()</code></td><td>创建可缓存的线程池，线程池的大小可以根据需要自动调整。</td></tr><tr><td><code>newScheduledThreadPool(int corePoolSize)</code></td><td>创建定时执行任务的线程池。</td></tr><tr><td><code>newSingleThreadScheduledExecutor()</code></td><td>创建只有一个线程的定时执行任务的线程池。</td></tr><tr><td><code>newWorkStealingPool()</code></td><td>创建工作窃取线程池，Java 8 中新增的方法。</td></tr></tbody></table><h3 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h3><p>定义了执行任务的方法，是线程池的顶层接口。</p><h3 id="ExecutorService接口"><a href="#ExecutorService接口" class="headerlink" title="ExecutorService接口"></a>ExecutorService接口</h3><p>继承自 <code>Executor</code> 接口，定义了一些管理线程池的方法，如提交任务、关闭线程池等。常用的实现类有 <code>ThreadPoolExecutor</code>、<code>ScheduledThreadPoolExecutor</code>。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>execute(Runnable command)</code></td><td>执行给定的任务</td></tr><tr><td><code>submit(Runnable task)</code></td><td>提交一个可运行的任务，并返回一个表示任务结果的 <code>Future</code> 对象</td></tr><tr><td><code>submit(Callable&lt;T&gt; task)</code></td><td>提交一个可调用的任务，并返回一个表示任务结果的 <code>Future</code> 对象</td></tr><tr><td><code>invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</code></td><td>执行给定的任务集合，并返回一个包含所有任务执行结果的 <code>Future</code> 对象列表</td></tr><tr><td><code>invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</code></td><td>执行给定的任务集合，并返回其中任意一个任务的执行结果，无法保证返回的是哪个任务的结果</td></tr><tr><td><code>boolean isShutdown()</code></td><td>判断线程池是否已经调用了 <code>shutdown()</code> 方法</td></tr><tr><td><code>isTerminated()</code></td><td>判断线程池是否已经完全终止</td></tr><tr><td><code>shutdown()</code></td><td>优雅地关闭线程池，等待已提交的任务执行完成后关闭</td></tr><tr><td><code>shutdownNow()</code></td><td>立即关闭线程池，尝试取消所有正在执行的任务，并丢弃等待执行的任务</td></tr><tr><td><code>awaitTermination(long timeout, TimeUnit unit)</code></td><td>等待线程池终止</td></tr></tbody></table><h3 id="ThreadPoolExecutor类"><a href="#ThreadPoolExecutor类" class="headerlink" title="ThreadPoolExecutor类"></a>ThreadPoolExecutor类</h3><p>实现了 <code>ExecutorService</code> 接口，是<code>线程池的核心实现类</code>。用于创建和管理线程池的具体实现类，提供了丰富的功能和灵活的配置选项，构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">int</span> corePoolSize, // 线程池的核心线程数，即线程池中同时可以执行的线程数量。</span></span><br><span class="line"><span class="params">    <span class="type">int</span> maximumPoolSize, // 线程池的最大线程数，即线程池中最多可以创建的线程数量。</span></span><br><span class="line"><span class="params">    <span class="type">long</span> keepAliveTime, // 空闲线程的存活时间。</span></span><br><span class="line"><span class="params">    TimeUnit unit, // 空闲线程存活时间的单位。</span></span><br><span class="line"><span class="params">    BlockingQueue&lt;Runnable&gt; workQueue, // 用于存放待执行任务的阻塞队列。</span></span><br><span class="line"><span class="params">    ThreadFactory threadFactory, // 用于创建新线程的工厂。</span></span><br><span class="line"><span class="params">    RejectedExecutionHandler handler // 线程池的饱和策略，即当线程池和阻塞队列都满了之后，如何处理新提交的任务。</span></span><br><span class="line"><span class="params">)</span> &#123; ... &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>描述</th><th>简介</th></tr></thead><tbody><tr><td>corePoolSize</td><td>线程池的核心线程数</td><td>线程池中始终保持存活的线程数</td></tr><tr><td>maximumPoolSize</td><td>线程池的最大线程数</td><td>线程池中允许的最大线程数</td></tr><tr><td>keepAliveTime</td><td>空闲线程的存活时间</td><td>当线程池中的线程数量超过 corePoolSize 且没有任务可执行时<br>多余的空闲线程会根据 keepAliveTime 进行存活时间的判断<br>如果超过指定时间仍然没有任务可执行，则会被回收。</td></tr><tr><td>unit</td><td>keepAliveTime 参数的时间单位</td><td>可选秒(<code>TimeUnit.SECONDS</code>)、毫秒(<code>TimeUnit.MILLISECONDS</code>)等</td></tr><tr><td>workQueue</td><td>线程池中的任务队列</td><td>存储等待执行的任务的阻塞队列，一般可选如下<br><code>ArrayBlockingQueue</code>：基于数组的有界阻塞队列<br><code>LinkedBlockingQueue</code>：基于链表的阻塞队列<br><code>SynchronizedQueue</code>：一个不存储元素的阻塞队列<br><code>PriorityBlockingQueue</code>：一个具有优先级的阻塞队列</td></tr><tr><td>threadFactory</td><td>创建新线程的工厂</td><td>用于创建新线程的工厂类，不指定时会使用默认的线程工厂来创建线程</td></tr><tr><td>handler</td><td>拒绝策略</td><td>当线程池无法接受新任务时的处理策略，可选的策略如下<br><code>AbortPolicy</code>：直接抛出异常<br><code>CallerRunsPolicy</code>：调用者所在的线程来运行任务<br><code>DiscardPolicy</code>：丢弃队列里最近的一个任务，并执行当前任务<br><code>DiscardOldestPolicy</code>：不处理，直接丢掉</td></tr></tbody></table><h3 id="ScheduledExecutorService接口"><a href="#ScheduledExecutorService接口" class="headerlink" title="ScheduledExecutorService接口"></a>ScheduledExecutorService接口</h3><p>继承自 <code>ExecutorService</code> 接口，定义了一些定时执行任务的方法。常用的实现类有 <code>ScheduledThreadPoolExecutor</code>。</p><h3 id="ScheduledThreadPoolExecutor类"><a href="#ScheduledThreadPoolExecutor类" class="headerlink" title="ScheduledThreadPoolExecutor类"></a>ScheduledThreadPoolExecutor类</h3><p><code>ScheduledThreadPoolExecutor</code>类继承了 <code>ThreadPoolExecutor</code> 类，在其基础上增加了对定时任务的支持，可以按照固定延迟或固定频率执行任务。</p><table><thead><tr><th>方法签名</th><th>描述</th></tr></thead><tbody><tr><td><code>schedule(Runnable command, long delay, TimeUnit unit)</code></td><td>在给定的延迟时间后执行任务。</td></tr><tr><td><code>schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</code></td><td>在给定的延迟时间后执行可调用任务，并返回表示任务结果的 <code>Future</code> 对象。</td></tr><tr><td><code>scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</code></td><td>以固定的速率执行任务，从指定的初始延迟开始，然后以固定的时间间隔重复执行。</td></tr><tr><td><code>scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</code></td><td>以固定的延迟执行任务，从指定的初始延迟开始，然后在每次执行完成之后等待固定的时间间隔。</td></tr><tr><td><code>setContinueExistingPeriodicTasksAfterShutdownPolicy(boolean value)</code></td><td>设置在调用 <code>shutdown</code> 后是否继续执行现有周期性任务的策略。如果为 <code>true</code>，则会继续执行现有任务；如果为 <code>false</code>，则会取消现有任务。</td></tr><tr><td><code>setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value)</code></td><td>设置在调用 <code>shutdown</code> 后是否继续执行现有延迟任务的策略。如果为 <code>true</code>，则会继续执行现有任务；如果为 <code>false</code>，则会取消现有任务。</td></tr><tr><td><code>setRemoveOnCancelPolicy(boolean value)</code></td><td>设置在任务被取消时是否从工作队列中移除该任务的策略。如果为 <code>true</code>，则会从队列中移除；如果为 <code>false</code>，则会保留在队列中等待执行。</td></tr><tr><td><code>shutdown()</code></td><td>平滑关闭线程池，不再接受新任务，但会等待已提交的任务完成执行。</td></tr><tr><td><code>shutdownNow()</code></td><td>立即关闭线程池，尝试取消所有运行中的任务，并返回等待执行的任务列表。</td></tr><tr><td><code>isShutdown()</code></td><td>判断线程池是否已调用了 <code>shutdown</code> 方法。</td></tr><tr><td><code>isTerminated()</code></td><td>判断线程池是否已完全终止。</td></tr><tr><td><code>awaitTermination(long timeout, TimeUnit unit)</code></td><td>阻塞等待线程池终止，直到超时或线程池终止。</td></tr></tbody></table><h2 id="如何创建线程池？"><a href="#如何创建线程池？" class="headerlink" title="如何创建线程池？"></a>如何创建线程池？</h2><blockquote><p>线程池的创建方式共包含七种（其中六种是通过 <code>Executors</code> 创建的，一种是通过<code>ThreadPoolExecutor</code> 创建的）根据阿里巴巴的Java技术手册（编码规约），不推荐使用<code>Executors</code>工具类去创建线程池，而是推荐直接使用<code>ThreadPoolExecutor</code>的方式进行创建。</p></blockquote><h3 id="通过Executors线程池工厂类创建线程池"><a href="#通过Executors线程池工厂类创建线程池" class="headerlink" title="通过Executors线程池工厂类创建线程池"></a>通过<code>Executors</code>线程池工厂类创建线程池</h3><p>创建线程池可以通过 <code>java.util.concurrent.Executors</code> 类中提供的静态方法来完成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建固定大小的线程池，线程池中的线程数量为3</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">fixedThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 创建只有一个线程的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">singleThreadExecutor</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="comment">// 创建可缓存的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">cachedThreadPool</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 创建定时执行任务的线程池，线程池中的线程数量为3</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledThreadPool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 创建只有一个线程的定时执行任务的线程池</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">singleThreadScheduledExecutor</span> <span class="operator">=</span> Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">        <span class="comment">// 创建工作窃取线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">workStealingPool</span> <span class="operator">=</span> Executors.newWorkStealingPool();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向线程池中添加任务并执行</span></span><br><span class="line">        fixedThreadPool.execute(() -&gt; System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在执行任务&quot;</span>));</span><br><span class="line">        singleThreadExecutor.execute(() -&gt; System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在执行任务&quot;</span>));</span><br><span class="line">        cachedThreadPool.execute(() -&gt; System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在执行任务&quot;</span>));</span><br><span class="line">        scheduledThreadPool.schedule(() -&gt; System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在执行任务&quot;</span>), <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        singleThreadScheduledExecutor.schedule(() -&gt; System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在执行任务&quot;</span>), <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">        workStealingPool.execute(() -&gt; System.out.println(<span class="string">&quot;线程&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在执行任务&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池，不再接收新的任务，并等待已经提交的任务执行完毕</span></span><br><span class="line">        fixedThreadPool.shutdown();</span><br><span class="line">        singleThreadExecutor.shutdown();</span><br><span class="line">        cachedThreadPool.shutdown();</span><br><span class="line">        scheduledThreadPool.shutdown();</span><br><span class="line">        singleThreadScheduledExecutor.shutdown();</span><br><span class="line">        workStealingPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过ThreadPoolExecutor创建线程池"><a href="#通过ThreadPoolExecutor创建线程池" class="headerlink" title="通过ThreadPoolExecutor创建线程池"></a>通过<code>ThreadPoolExecutor</code>创建线程池</h3><p>除了使用<code>Executors</code>类提供的方法外，我们还可以直接使用<code>ThreadPoolExecutor</code>类来创建线程池，这样可以更加灵活地配置线程池的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建线程池，核心线程数为2，最大线程数为5，等待队列容量为10</span></span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">                <span class="number">2</span>,  <span class="comment">// 核心线程数</span></span><br><span class="line">                <span class="number">5</span>,  <span class="comment">// 最大线程数</span></span><br><span class="line">                <span class="number">1</span>,  <span class="comment">// 线程空闲时间</span></span><br><span class="line">                TimeUnit.MINUTES,  <span class="comment">// 空闲时间单位</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">10</span>),  <span class="comment">// 等待队列</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()  <span class="comment">// 拒绝策略（当线程池和等待队列都满了时，由提交任务的线程来执行该任务）</span></span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向线程池中添加任务并执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">            threadPool.execute(() -&gt; System.out.println(<span class="string">&quot;任务&quot;</span> + taskId + <span class="string">&quot;正在执行，线程&quot;</span> + Thread.currentThread().getName()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池，不再接收新的任务，并等待已经提交的任务执行完毕</span></span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h2><ol><li><strong>创建线程池</strong>：首先，创建一个线程池对象。可以使用 <code>java.util.concurrent.Executors</code> 类提供的静态方法来创建不同类型的线程池，如 <code>newFixedThreadPool()</code>、<code>newCachedThreadPool()</code> 等。</li><li><strong>提交任务</strong>：通过调用线程池对象的 <code>submit()</code> 或 <code>execute()</code> 方法来提交任务。任务可以是实现了 <code>Runnable</code> 接口或者 <code>Callable</code> 接口的对象。</li><li><strong>任务接收</strong>：线程池接收到任务后，会根据线程池的状态和配置来确定如何处理任务。如果线程池中的线程数小于核心线程数，会创建新的线程来执行任务；如果线程池中的线程数已达到核心线程数，任务会被放入任务队列等待执行；如果任务队列已满且线程池中的线程数未达到最大线程数，则会创建新的线程来执行任务；如果线程池中的线程数已达到最大线程数，且任务队列已满，根据拒绝策略来处理任务（如抛出异常、丢弃任务等）。</li><li><strong>任务执行</strong>：线程池中的线程从任务队列中取出任务，执行任务的逻辑。执行的方式取决于具体的任务类型，可以是 <code>Runnable</code> 对象的 <code>run()</code> 方法或 <code>Callable</code> 对象的 <code>call()</code> 方法。</li><li><strong>结果返回（仅适用于 <code>Callable</code> 任务）</strong>：如果任务是 <code>Callable</code> 类型的，并且需要返回结果，线程执行任务后会将结果返回。</li><li><strong>线程回收</strong>：任务执行完毕后，线程池中的线程可能会被回收。具体回收的条件取决于线程池的配置，例如空闲时间超过一定阈值、线程池关闭等。</li><li><strong>关闭线程池</strong>：当不再需要线程池时，可以调用 <code>shutdown()</code> 方法请求关闭线程池。这会停止接受新的任务，并等待线程池中正在执行的任务执行完毕。然后可以选择调用 <code>awaitTermination()</code> 方法等待线程池中的任务执行完毕，或者直接终止尚未完成的任务。</li></ol><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/线程池的执行流程.png" style="zoom:50%"></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://w_e_n.gitee.io/blog">wen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://w_e_n.gitee.io/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">https://w_e_n.gitee.io/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://w_e_n.gitee.io/blog" target="_blank">远方の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/blog/tags/JavaSE/">JavaSE</a></div><div class="post_share"><div class="social-share" data-image="/blog/2020/05/01/JavaSE-9-%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/2020/05/15/JavaSE-10-%E5%8F%8D%E5%B0%84/" title="JavaSE笔记-反射"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2020/05/15/JavaSE-10-%E5%8F%8D%E5%B0%84/Java.png" onerror='onerror=null,src="/blog/img/404.png"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JavaSE笔记-反射</div></div></a></div><div class="next-post pull-right"><a href="/blog/2020/04/15/JavaSE-8-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" title="JavaSE笔记-网络编程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2020/04/15/JavaSE-8-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Java.png" onerror='onerror=null,src="/blog/img/404.png"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaSE笔记-网络编程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/blog/2020/06/01/JavaSE-11-%E6%B3%A8%E8%A7%A3/" title="JavaSE笔记-注解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2020/06/01/JavaSE-11-%E6%B3%A8%E8%A7%A3/Java.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-01</div><div class="title">JavaSE笔记-注解</div></div></a></div><div><a href="/blog/2020/01/01/JavaSE-1-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/" title="JavaSE笔记-入门基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2020/01/01/JavaSE-1-%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/Java.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-01</div><div class="title">JavaSE笔记-入门基础</div></div></a></div><div><a href="/blog/2020/05/15/JavaSE-10-%E5%8F%8D%E5%B0%84/" title="JavaSE笔记-反射"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2020/05/15/JavaSE-10-%E5%8F%8D%E5%B0%84/Java.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-15</div><div class="title">JavaSE笔记-反射</div></div></a></div><div><a href="/blog/2020/06/15/JavaSE-12-%E6%96%B0%E7%89%B9%E6%80%A7/" title="JavaSE笔记-新特性"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2020/06/15/JavaSE-12-%E6%96%B0%E7%89%B9%E6%80%A7/Java.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-06-15</div><div class="title">JavaSE笔记-新特性</div></div></a></div><div><a href="/blog/2020/02/15/JavaSE-4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/" title="JavaSE笔记-异常处理机制"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2020/02/15/JavaSE-4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/Java.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-02-15</div><div class="title">JavaSE笔记-异常处理机制</div></div></a></div><div><a href="/blog/2020/01/15/JavaSE-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" title="JavaSE笔记-面向对象"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2020/01/15/JavaSE-2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/Java.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-15</div><div class="title">JavaSE笔记-面向对象</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Gitalk</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/img/%E5%A4%B4%E5%83%8F.png" onerror='this.onerror=null,this.src="/blog/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">wen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/blog/archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="/blog/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/blog/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wen53231323"><i class="fab fa-github"></i><span>我的仓库</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">暂无</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">多线程相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">进程与线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E6%A0%B8CPU%E5%92%8C%E5%A4%9A%E6%A0%B8CPU"><span class="toc-number">1.2.</span> <span class="toc-text">单核CPU和多核CPU</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91"><span class="toc-number">1.3.</span> <span class="toc-text">并行和并发</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.</span> <span class="toc-text">多线程的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">Thread类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.2.</span> <span class="toc-text">线程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E7%BB%A7%E6%89%BF%E4%BA%8EThread%E7%B1%BB%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">方式一：继承于Thread类（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">创建步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">代码实例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">2.2.2.</span> <span class="toc-text">方式二：实现Runnable接口（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">创建步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">2.2.3.</span> <span class="toc-text">方式三：实现Callable接口（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%AD%A5%E9%AA%A4-2"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">创建步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">2.2.4.</span> <span class="toc-text">三种创建方式的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2%EF%BC%88stop%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">线程的终止（stop）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD%EF%BC%88interrupt%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">线程的中断（interrupt）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">2.5.</span> <span class="toc-text">线程的调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">2.5.1.</span> <span class="toc-text">线程的优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%A4%BC%E8%AE%A9%EF%BC%88yield%EF%BC%89"><span class="toc-number">2.5.2.</span> <span class="toc-text">线程的礼让（yield）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8F%92%E9%98%9F%EF%BC%88join%EF%BC%89"><span class="toc-number">2.5.3.</span> <span class="toc-text">线程的插队（join）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">线程的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8BsetDeamon-false"><span class="toc-number">3.1.</span> <span class="toc-text">用户线程setDeamon(false)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8BsetDeamon-true"><span class="toc-number">3.2.</span> <span class="toc-text">守护线程setDeamon(true)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.</span> <span class="toc-text">线程的生命周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">线程安全性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%AE%80%E4%BB%8B"><span class="toc-number">5.1.</span> <span class="toc-text">线程安全问题简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.1.</span> <span class="toc-text">相关概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.2.</span> <span class="toc-text">常见的线程安全性问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.</span> <span class="toc-text">数据竞争问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.1.</span> <span class="toc-text">模拟数据竞争问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">5.2.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.</span> <span class="toc-text">线程死锁问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9F"><span class="toc-number">5.3.1.</span> <span class="toc-text">死锁产生的原因？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-number">5.3.2.</span> <span class="toc-text">模拟线程死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-1"><span class="toc-number">5.3.3.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">5.4.</span> <span class="toc-text">内存可见性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">5.4.1.</span> <span class="toc-text">模拟内存可见性问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-2"><span class="toc-number">5.4.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%A1%88"><span class="toc-number">5.5.</span> <span class="toc-text">解决线程安全性问题的方案</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">6.</span> <span class="toc-text">线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.</span> <span class="toc-text">线程同步的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">6.2.</span> <span class="toc-text">线程同步的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">6.3.</span> <span class="toc-text">线程同步的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E4%BD%BF%E7%94%A8synchronized%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.4.</span> <span class="toc-text">线程同步方式一：使用synchronized关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8Lock%E6%8E%A5%E5%8F%A3"><span class="toc-number">6.5.</span> <span class="toc-text">线程同步方式二：使用Lock接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E4%B8%8EReentrantLock%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">6.6.</span> <span class="toc-text">synchronized与ReentrantLock的异同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.7.</span> <span class="toc-text">volatile关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%8F%98%E9%87%8F"><span class="toc-number">6.8.</span> <span class="toc-text">ThreadLocal线程本地变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal%E7%AE%80%E4%BB%8B"><span class="toc-number">6.9.</span> <span class="toc-text">ThreadLocal简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">6.10.</span> <span class="toc-text">常用方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%94%AE%E7%A5%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">7.</span> <span class="toc-text">售票案例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%94%AE%E7%A5%A8"><span class="toc-number">7.1.</span> <span class="toc-text">线程不安全的售票</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E5%86%B3%E5%94%AE%E7%A5%A8%E9%97%AE%E9%A2%98"><span class="toc-number">7.2.</span> <span class="toc-text">使用synchronized关键字解决售票问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Lock%E6%8E%A5%E5%8F%A3%E8%A7%A3%E5%86%B3%E5%94%AE%E7%A5%A8%E9%97%AE%E9%A2%98"><span class="toc-number">7.3.</span> <span class="toc-text">使用Lock接口解决售票问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E"><span class="toc-number">8.</span> <span class="toc-text">线程的阻塞</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%98%BB%E5%A1%9E%E6%96%B9%E5%BC%8F"><span class="toc-number">8.1.</span> <span class="toc-text">常见阻塞方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">相关方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sellp-%E5%92%8Cwait-%E5%BC%82%E5%90%8C"><span class="toc-number">8.3.</span> <span class="toc-text">sellp()和wait()异同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E"><span class="toc-number">8.4.</span> <span class="toc-text">synchronized同步阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#wait-%E7%AD%89%E5%BE%85%E9%80%9A%E7%9F%A5%E9%98%BB%E5%A1%9E"><span class="toc-number">8.5.</span> <span class="toc-text">wait()等待通知阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sleep-%E7%9D%A1%E7%9C%A0%E9%98%BB%E5%A1%9E"><span class="toc-number">8.6.</span> <span class="toc-text">sleep()睡眠阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#join-%E7%BA%BF%E7%A8%8B%E6%8F%92%E9%98%9F%E9%98%BB%E5%A1%9E"><span class="toc-number">8.7.</span> <span class="toc-text">join()线程插队阻塞</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">9.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">9.1.</span> <span class="toc-text">什么是线程池？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">9.2.</span> <span class="toc-text">为什么使用线程池？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%B8%B8%E8%A7%81%E7%9B%B8%E5%85%B3%E6%8E%A5%E5%8F%A3%E5%92%8C%E7%B1%BB"><span class="toc-number">9.3.</span> <span class="toc-text">线程池的常见相关接口和类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Executors%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E5%8E%82%E7%B1%BB"><span class="toc-number">9.3.1.</span> <span class="toc-text">Executors线程池工厂类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.3.2.</span> <span class="toc-text">Executor接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ExecutorService%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.3.3.</span> <span class="toc-text">ExecutorService接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadPoolExecutor%E7%B1%BB"><span class="toc-number">9.3.4.</span> <span class="toc-text">ThreadPoolExecutor类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ScheduledExecutorService%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.3.5.</span> <span class="toc-text">ScheduledExecutorService接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ScheduledThreadPoolExecutor%E7%B1%BB"><span class="toc-number">9.3.6.</span> <span class="toc-text">ScheduledThreadPoolExecutor类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">9.4.</span> <span class="toc-text">如何创建线程池？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Executors%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E5%8E%82%E7%B1%BB%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">9.4.1.</span> <span class="toc-text">通过Executors线程池工厂类创建线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87ThreadPoolExecutor%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">9.4.2.</span> <span class="toc-text">通过ThreadPoolExecutor创建线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">9.5.</span> <span class="toc-text">线程池的执行流程</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/CSS/" title="CSS笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/CSS/CSS.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="CSS笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/CSS/" title="CSS笔记">CSS笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/HTML/" title="HTML笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/HTML/HTML.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="HTML笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/HTML/" title="HTML笔记">HTML笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/JavaScript/" title="JavaScript笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/JavaScript/JavaScript.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="JavaScript笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/JavaScript/" title="JavaScript笔记">JavaScript笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/JavaWeb/" title="JavaWeb笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/JavaWeb/JavaWeb.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="JavaWeb笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/JavaWeb/" title="JavaWeb笔记">JavaWeb笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2023/01/01/Linux/" title="Linux笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/blog/2023/01/01/Linux/Linux.png" onerror='this.onerror=null,this.src="/blog/img/404.png"' alt="Linux笔记"></a><div class="content"><a class="title" href="/blog/2023/01/01/Linux/" title="Linux笔记">Linux笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By wen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '701b8bc001a40a760558',
      clientSecret: 'a51b436adc471c3949a8f41be05c2d58cccab10a',
      repo: 'Hexo-Butterfly-Comment',
      owner: 'wen53231323',
      admin: ['wen53231323'],
      id: '5b6118cc53e0bdea14f1df11ddd7aace',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'VI32wmbmMoxvlhpTpoDBNeOk-MdYXbMMI',
      appKey: 'oFstfBFkCQIkjuk4ibCpbGqz',
      avatar: 'monsterid',
      serverURLs: 'https://vi32wmbm.api.lncldglobal.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Gitalk' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/blog/js/search/local-search.js"></script></div></div></body></html>