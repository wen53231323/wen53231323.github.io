<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>MySQL笔记-数据库性能优化 | 远方の博客</title><meta name="author" content="wen"><meta name="copyright" content="wen"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="SQL性能分析查看SQL执行信息（Profile）Profile简介在MySQL中，”Profile”是一个用于性能分析和调优的特殊功能。Profile允许捕获并分析查询语句的执行情况，以便确定潜在的性能问题和瓶颈。Profile通常提供以下信息：  查询执行时间：SQL查询的总执行时间以及每个操作阶段的执行时间。 资源使用情况：CPU、内存和磁盘等资源在执行过程中的使用情况。 操作顺序：SQL查"><meta property="og:type" content="article"><meta property="og:title" content="MySQL笔记-数据库性能优化"><meta property="og:url" content="https://ipvb.gitee.io/2020/11/15/MySQL-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/index.html"><meta property="og:site_name" content="远方の博客"><meta property="og:description" content="SQL性能分析查看SQL执行信息（Profile）Profile简介在MySQL中，”Profile”是一个用于性能分析和调优的特殊功能。Profile允许捕获并分析查询语句的执行情况，以便确定潜在的性能问题和瓶颈。Profile通常提供以下信息：  查询执行时间：SQL查询的总执行时间以及每个操作阶段的执行时间。 资源使用情况：CPU、内存和磁盘等资源在执行过程中的使用情况。 操作顺序：SQL查"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://ipvb.gitee.io/2020/11/15/MySQL-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/MySQL.png"><meta property="article:published_time" content="2020-11-14T16:00:00.000Z"><meta property="article:modified_time" content="2023-09-04T13:09:14.780Z"><meta property="article:author" content="wen"><meta property="article:tag" content="MySQL"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://ipvb.gitee.io/2020/11/15/MySQL-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/MySQL.png"><link rel="shortcut icon" href="./img/favicon.png"><link rel="canonical" href="https://ipvb.gitee.io/2020/11/15/MySQL-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//static.cloudflareinsights.com"><link rel="preconnect" href="//www.clarity.ms"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="./css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?[object Object]";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=[object Object]"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","[object Object]")</script><script defer data-pjax="data-pjax" src="https://static.cloudflareinsights.com/beacon.min.js" data-cf-beacon="{&quot;token&quot;: &quot;[object Object]&quot;}"></script><script>!function(t,e,c,n,a,r){t[c]=t[c]||function(){(t[c].q=t[c].q||[]).push(arguments)},(a=e.createElement(n)).async=1,a.src="https://www.clarity.ms/tag/[object Object]",(r=e.getElementsByTagName(n)[0]).parentNode.insertBefore(a,r)}(window,document,"clarity","script")</script><script>const GLOBAL_CONFIG = { 
  root: './',
  algolia: undefined,
  localSearch: {"path":"./search.xml","preload":true,"top_n_per_article":5,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"MySQL笔记-数据库性能优化",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-09-04 21:09:14"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./img/%E5%A4%B4%E5%83%8F.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="./archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="./tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="./categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="./"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="./archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="./tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="./categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="./picture/"><i class="fa-fw fas fa-images"></i><span> 图片库</span></a></li><li><a class="site-page child" href="./music/"><i class="fa-fw fas fa-music"></i><span> 音乐库</span></a></li><li><a class="site-page child" href="./movies/"><i class="fa-fw fas fa-video"></i><span> 视频库</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="./link/"><span>导航链接</span></a></li><li><a class="site-page child" href="./comment_loading/"><span>评论管理</span></a></li><li><a class="site-page child" href="./custom/"><span>自定义页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="./about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(2020/11/15/MySQL-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/MySQL.png)"><nav id="nav"><span id="blog-info"><a href="./" title="远方の博客"><span class="site-name">远方の博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="./"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="./archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="./tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="./categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="./picture/"><i class="fa-fw fas fa-images"></i><span> 图片库</span></a></li><li><a class="site-page child" href="./music/"><i class="fa-fw fas fa-music"></i><span> 音乐库</span></a></li><li><a class="site-page child" href="./movies/"><i class="fa-fw fas fa-video"></i><span> 视频库</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="./link/"><span>导航链接</span></a></li><li><a class="site-page child" href="./comment_loading/"><span>评论管理</span></a></li><li><a class="site-page child" href="./custom/"><span>自定义页</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="./about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL笔记-数据库性能优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-14T16:00:00.000Z" title="发表于 2020-11-15 00:00:00">2020-11-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-04T13:09:14.780Z" title="更新于 2023-09-04 21:09:14">2023-09-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="./categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="MySQL笔记-数据库性能优化"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="SQL性能分析"><a href="#SQL性能分析" class="headerlink" title="SQL性能分析"></a>SQL性能分析</h1><h2 id="查看SQL执行信息（Profile）"><a href="#查看SQL执行信息（Profile）" class="headerlink" title="查看SQL执行信息（Profile）"></a>查看SQL执行信息（Profile）</h2><h3 id="Profile简介"><a href="#Profile简介" class="headerlink" title="Profile简介"></a>Profile简介</h3><p>在MySQL中，”Profile”是一个用于性能分析和调优的特殊功能。Profile允许捕获并分析查询语句的执行情况，以便确定潜在的性能问题和瓶颈。Profile通常提供以下信息：</p><ul><li><strong>查询执行时间</strong>：SQL查询的总执行时间以及每个操作阶段的执行时间。</li><li><strong>资源使用情况</strong>：CPU、内存和磁盘等资源在执行过程中的使用情况。</li><li><strong>操作顺序</strong>：SQL查询中每个操作的执行顺序。</li></ul><h3 id="开启Profile"><a href="#开启Profile" class="headerlink" title="开启Profile"></a>开启Profile</h3><p>Profile是MySQL数据库提供的一种用于查看SQL查询执行信息的功能，默认默认是关闭的，可以执行以下命令来开启Profile功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前的 MySQL 版本是否支持 profile</span><br><span class="line">select @@have_profiling</span><br><span class="line"></span><br><span class="line"># 查询 MySQL Server 的 profiling 功能是否已经开启，返回的值为 1，则表示 profiling 已经启用，否则表示未启用</span><br><span class="line">select @@profiling</span><br><span class="line"></span><br><span class="line"># 开启 profiling 记录执行时间超过一定阈值的语句的执行统计信息</span><br><span class="line">set profiling = 1;</span><br></pre></td></tr></table></figure><h3 id="使用Profile"><a href="#使用Profile" class="headerlink" title="使用Profile"></a>使用Profile</h3><p>运行需要分析的SQL查询，然后可以通过Profile查看执行过程和资源消耗统计信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 运行需要分析的SQL查询</span><br><span class="line">SELECT * FROM table_name</span><br><span class="line"></span><br><span class="line"># 查看每一条SQL的耗时基本情况，结果的三个字段：查询的唯一标识符（Query_ID）查询的执行时间（Duration）被执行的查询语句（Query）</span><br><span class="line">show profiles;</span><br><span class="line"></span><br><span class="line"># 查看指定查询ID的SQL语句各个阶段的耗时情况</span><br><span class="line">show profile for query 查询ID;</span><br><span class="line"></span><br><span class="line"># 查看指定查询ID的SQL语句CPU的使用情况</span><br><span class="line">show profile cpu for query 查询ID;</span><br><span class="line"></span><br><span class="line"># 查看指定查询ID的SQL语句阻塞IO的情况</span><br><span class="line">show profile block io for query 查询ID;</span><br></pre></td></tr></table></figure><h2 id="查看状态变量（Status）"><a href="#查看状态变量（Status）" class="headerlink" title="查看状态变量（Status）"></a>查看状态变量（Status）</h2><h3 id="状态变量简介"><a href="#状态变量简介" class="headerlink" title="状态变量简介"></a>状态变量简介</h3><p>状态变量（Status Variables）是用于描述和监控数据库服务器运行状态的参数。这些状态变量包括各种指标和操作次数，如连接数、线程数、查询次数、I&#x2F;O 操作和内存使用等。通过查看状态变量，可以了解数据库服务器的实时性能和资源占用情况。根据会话域的不同，可以分为会话服务器状态变量和全局服务器状态变量，可以使用下面的命令查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前会话服务器状态变量，仅适用于当前会话，并在会话结束后被重置。</span><br><span class="line">SHOW SESSION STATUS;</span><br><span class="line"># 查看全局服务器状态变量,显示了整个服务器实例的状态，反映了所有会话的综合情况</span><br><span class="line">SHOW GLOBAL STATUS;</span><br></pre></td></tr></table></figure><p>这两个命令共享同一套变量名称，但显示的是不同的作用域和范围。具体解释如下：</p><ol><li><code>Com_xxx</code>：这些变量记录了执行各种 SQL 语句的次数，如<code>Com_insert</code>表示执行了多少次插入语句。</li><li><code>Connections</code>：当前已经建立的连接数量。</li><li><code>Threads_connected</code>：当前正在使用的连接数量。</li><li><code>Threads_running</code>：正在运行的线程数量。</li><li><code>Innodb_xxx</code>：这些变量提供了 InnoDB 存储引擎的相关信息，如<code>Innodb_buffer_pool_reads</code>表示从磁盘读取的页数。</li><li><code>Created_tmp_xxx</code>：这些变量记录了创建临时表和文件的次数和数量。</li><li><code>Handler_xxx</code>：这些变量提供了关于查询处理器操作的信息，如<code>Handler_read_first</code>表示读取表的第一行的次数。</li><li><code>Bytes_xxx</code>：这些变量记录了传输的字节数量，如<code>Bytes_received</code>表示已接收的字节数。</li><li><code>Uptime</code>：MySQL 服务器运行的时间。</li></ol><h3 id="Com前缀"><a href="#Com前缀" class="headerlink" title="Com前缀"></a>Com前缀</h3><p>在MySQL中，<code>Com</code> 前缀的状态变量记录了执行各种 SQL 语句的次数。可以通过执行以下命令来查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 查看当前会话的状态计数器</span><br><span class="line">show session status like &#x27;Com%&#x27;;</span><br><span class="line"># 查看全局的状态计数器</span><br><span class="line">show global status like &#x27;Com%&#x27;;</span><br></pre></td></tr></table></figure><p>下面是几个常见的以 <code>Com</code> 前缀开头的状态变量：</p><ol><li><code>Com_select</code>：表示执行 SELECT 查询语句的次数。</li><li><code>Com_insert</code>：表示执行 INSERT 插入语句的次数。</li><li><code>Com_update</code>：表示执行 UPDATE 更新语句的次数。</li><li><code>Com_delete</code>：表示执行 DELETE 删除语句的次数。</li><li><code>Com_commit</code>：表示执行 COMMIT 事务提交的次数。</li><li><code>Com_rollback</code>：表示执行 ROLLBACK 事务回滚的次数。</li><li><code>Com_create_table</code>：表示执行 CREATE TABLE 创建表的次数。</li><li><code>Com_alter_table</code>：表示执行 ALTER TABLE 修改表结构的次数。</li><li><code>Com_drop_table</code>：表示执行 DROP TABLE 删除表的次数。</li><li><code>Com_show_tables</code>：表示执行 SHOW TABLES 显示表列表的次数。</li></ol><p>根据<code>Com</code> 前缀的状态变量可以确定当前数据库到底是以查询为主，还是以增删改为主</p><ul><li><strong>数据库以查询为主</strong>：可以考虑对查询频繁的表进行索引优化；如果数据库以增删改为主，</li><li><strong>数据库以增删改为主</strong>：不进行索引优化，重点关注事务处理、缓存策略、数据分片等方面的优化。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前会话中执行了多少次删除操作（Com_delete）</span><br><span class="line">show session status like &quot;Com_delete&quot;</span><br><span class="line"># 显示当前会话中执行了多少次插入操作（Com_insert）</span><br><span class="line">show session status like &quot;Com_insert&quot;</span><br><span class="line"># 显示当前会话中执行了多少次查询操作（Com_select）</span><br><span class="line">show session status like &quot;Com_select&quot;</span><br><span class="line"># 显示当前会话中执行了多少次更新操作（Com_update）</span><br><span class="line">show session status like &quot;Com_update&quot;</span><br><span class="line"></span><br><span class="line"># 显示 MySQL 服务器实例中执行了多少次删除操作（Com_delete）</span><br><span class="line">show global status like &quot;Com_delete&quot;</span><br><span class="line"># 显示 MySQL 服务器实例中执行了多少次插入操作（Com_insert）</span><br><span class="line">show global status like &quot;Com_insert&quot;</span><br><span class="line"># 显示 MySQL 服务器实例中执行了多少次查询操作（Com_select）</span><br><span class="line">show global status like &quot;Com_select&quot;</span><br><span class="line"># 显示 MySQL 服务器实例中执行了多少次更新操作（Com_update）</span><br><span class="line">show global status like &quot;Com_update&quot;</span><br></pre></td></tr></table></figure><h2 id="查看SQL慢查询日志（localhost-slow-log）"><a href="#查看SQL慢查询日志（localhost-slow-log）" class="headerlink" title="查看SQL慢查询日志（localhost-slow.log）"></a>查看SQL慢查询日志（localhost-slow.log）</h2><h3 id="慢查询简介"><a href="#慢查询简介" class="headerlink" title="慢查询简介"></a>慢查询简介</h3><p>慢查询日志记录了所有执行时间超过指定参数的所有 SQL语句的日志，通过慢查询日志，就可以定位出执行效率比较低的SQL，从而有针对性的进行优化。默认情况下，慢查询日志在数据库中是关闭状态，可以通过下面的命令查看是否开启慢查询日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &quot;slow_%&quot;</span><br></pre></td></tr></table></figure><ul><li><strong>slow_query_log</strong>：若值为 ON，则表示慢查询日志已开启；若值为 OFF，则表示慢查询日志已关闭。</li><li><strong>slow_launch_time</strong>：慢查询阈值（单位为秒），超过该阈值的 SQL 语句将被记录在慢查询日志中。</li><li><strong>slow_query_log_file</strong>：表示慢查询日志的文件路径，默认文件名称为<code>主机名-slow.log</code>。</li></ul><h3 id="开启慢查询日志"><a href="#开启慢查询日志" class="headerlink" title="开启慢查询日志"></a>开启慢查询日志</h3><p>修改在MySQL的my.cnf配置文件，开启慢查询日志（修改后需要重启服务）</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启MySQL慢日志查询开关</span></span><br><span class="line"><span class="attr">slow_query_log</span> = <span class="number">1</span></span><br><span class="line"><span class="comment"># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志</span></span><br><span class="line"><span class="attr">long_query_time</span> = <span class="number">2</span></span><br><span class="line"><span class="comment"># 修改慢查询日志存储路径</span></span><br><span class="line"><span class="attr">slow_query_log_file</span> = /path/to/slow-query.log</span><br></pre></td></tr></table></figure><h3 id="慢查询日志的存储位置"><a href="#慢查询日志的存储位置" class="headerlink" title="慢查询日志的存储位置"></a>慢查询日志的存储位置</h3><p>默认慢查询日志的存储位置如下</p><ul><li><strong>Windows操作系统默认存储位置</strong>：C:\ProgramData\MySQL\MySQL Server 8.0\data\主机名-slow.log</li><li><strong>Linux操作系统默认存储位置</strong>： &#x2F;var&#x2F;log&#x2F;mysql&#x2F;mysql-slow.log</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看慢查询日志的存储位置</span><br><span class="line">SHOW VARIABLES LIKE &#x27;slow_query_log_file&#x27;;</span><br></pre></td></tr></table></figure><h2 id="查看SQL执行计划（Explain）"><a href="#查看SQL执行计划（Explain）" class="headerlink" title="查看SQL执行计划（Explain）"></a>查看SQL执行计划（Explain）</h2><h3 id="执行计划简介"><a href="#执行计划简介" class="headerlink" title="执行计划简介"></a>执行计划简介</h3><p>每条SQL语句执行之前，都会先计算该SQL语句需要调用的相关资源，再决定该SQL语句是否要最终执行，该行为被称为“执行计划”。执行计划主要用于分析 SQL 语句的执行情况，包括索引的使用情况、表的访问方式、连接操作的顺序等，并不实际执行查询。</p><h3 id="执行计划使用"><a href="#执行计划使用" class="headerlink" title="执行计划使用"></a>执行计划使用</h3><p>MySQL 提供了一个内置的查询执行计划分析工具，称为 EXPLAIN。使用EXPLAIN查看 SQL 语句的执行计划，语法如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain SQL语句;</span><br></pre></td></tr></table></figure><h3 id="执行计划字段信息"><a href="#执行计划字段信息" class="headerlink" title="执行计划字段信息"></a>执行计划字段信息</h3><p>MySQL执行计划 EXPLAIN 命令获取到的字段信息如下</p><table><thead><tr><th>参数</th><th>简介</th></tr></thead><tbody><tr><td>id</td><td>查询块的唯一标识符。对于复杂的查询语句，查询块会按照特定的顺序被编号，id 值越小表示该查询块的执行优先级越高。</td></tr><tr><td>select_type</td><td>查询的类型，常见取值有以下几种：<br><code>SIMPLE</code>：简单查询，不包含子查询或 UNION 查询<br><code>PRIMARY</code>：主查询，最外层的查询<br><code>SUBQUERY</code>：子查询，嵌套在其他查询中<br><code>DERIVED</code>：派生表中的 SELECT 查询<br><code>UNION</code>：UNION操作查询<br><code>UNION RESULT</code>：UNION 查询结果</td></tr><tr><td>table</td><td>当前查询涉及的表名称</td></tr><tr><td>partitions</td><td>当前查询涉及的分区名称</td></tr><tr><td>type</td><td>查询的连接类型，常见取值有以下几种：<br><code>system</code>：表示结果只有一行<br><code>const</code>：使用常量值进行匹配，通常是在没有索引的情况下<br><code>eq_ref</code>：唯一索引等值匹配<br><code>ref</code>：非唯一索引等值匹配<br><code>fulltext</code>: 全文检索<br><code>range</code>：使用索引范围匹配<br><code>index</code>：扫描全索引<br><code>all</code>：全表扫描<br><code>ref_or_null</code>：类似于 ref，但还包括对 NULL 值的引用<br><code>index_merge</code>: 使用了多个索引进行合并扫描<br><code>unique_subquery</code>: 在子查询中使用了唯一索引查找结果<br><code>index_subquery</code>: 在子查询中使用了非唯一索引查找结果</td></tr><tr><td>possible_keys</td><td>可能会用到的索引，索引越多，说明有更多的选择余地。</td></tr><tr><td>key</td><td>实际上使用的索引，如果为NULL，则没有使用索引。</td></tr><tr><td>key_len</td><td>使用的索引长度（以字节数表示）， 该值是最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好</td></tr><tr><td>ref</td><td>连接使用的列或常量</td></tr><tr><td>rows</td><td>MySQL 认为必须检查的行数。这个值是优化器根据统计信息和查询条件的估计值，并不总是准确的。</td></tr><tr><td>filtered</td><td>表示返回结果的行数占需读取行数的百分比， 值越大越好。</td></tr><tr><td>Extra</td><td>额外信息，用于进一步解释查询执行的细节和附加操作，常见取值有以下几种：<br><code>Using index</code>：表示查询使用了覆盖索引（Covering Index）查询时可以直接从索引中获取所需的数据，不必回到表中检索数据<br><code>Using index condition</code>：表示查询时利用索引中的部分列进行了过滤，需要回到表中检索符合条件的所有行<br><code>Using index for group-by</code>：表示查询使用了索引来进行 GROUP BY 操作<br><code>Using index for order by</code>：表示查询使用了索引来进行 ORDER BY 操作<br><code>Using where</code>：表示查询需要在结果集中使用 WHERE 子句进行过滤<br><code>Using join buffer</code>：表示查询使用了连接缓冲区（Join Buffer）<br><code>Using temporary</code>：表示查询需要使用临时表（Temporary Table）来处理结果集<br><code>Using filesort</code>：表示查询需要对结果集进行排序<br><code>Using disk sort</code>：表示查询需要使用外部磁盘进行排序<br><code>Using union</code>：表示查询使用了 UNION 操作<br><code>Using intersect</code>：在多个全文索引之间进行交集计算<br><code>Using sort_union</code>：在联合子查询中使用了排序和并集优化器。</td></tr></tbody></table><h1 id="索引（index）"><a href="#索引（index）" class="headerlink" title="索引（index）"></a>索引（index）</h1><h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><p>索引是一种数据结构，用于加速数据库中的数据查询。类似于书籍的目录，可以帮助我们快速地找到需要的内容。在数据库中，索引通常是一张包含键值和指向实际数据行的指针的表格</p><h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><h4 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h4><ul><li><strong>提高查询效率</strong>：索引可以提高查询效率，因为它可以使MySQL直接跳过不需要检索的行，从而减少了IO操作和CPU消耗。</li><li><strong>确保数据完整性</strong>：索引可以确保数据的完整性，因为可以强制执行唯一性约束、非空值约束等。</li><li><strong>加速排序</strong>：当使用ORDER BY操作时，MySQL可以利用索引的排序特性来进行快速排序，从而加快查询速度</li><li><strong>加速分组</strong>：对分组操作的字段建立索引，可直接利用索引的排序特性来执行分组操作，减少了排序和分组的时间和资源消耗</li></ul><h4 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h4><ul><li><strong>需要持续维护</strong>：索引需要随着数据的变更而维护，这会增加数据库的负担</li><li><strong>占用磁盘空间</strong>：索引也是一个文件，需要额外的空间来存储，这可能会占用大量的磁盘空间</li><li><strong>降低更新性能</strong>：降低更新的速度，每次插入、更新或删除操作都需要更新索引，这可能会使写入操作的性能下降</li><li><strong>不适合小表</strong>：对于非常小的表格来说，使用索引可能会降低查询性能，因为索引本身需要消耗资源</li><li><strong>可能导致锁冲突</strong>：当多个事务同时访问同一个表时，索引可能会导致锁冲突，从而影响并发性能</li></ul><h2 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h2><h3 id="根据索引的字段特性分类"><a href="#根据索引的字段特性分类" class="headerlink" title="根据索引的字段特性分类"></a>根据索引的字段特性分类</h3><table><thead><tr><th>索引</th><th>简介</th></tr></thead><tbody><tr><td>常规索引</td><td>快速定位特定数据</td></tr><tr><td>主键索引</td><td>针对于表中主键创建的索引</td></tr><tr><td>唯一索引</td><td>索引列的值必须唯一，但允许有空值。</td></tr><tr><td>全文索引</td><td>全文索引查找的是文本中的关键词，而不是比 较索引中的值</td></tr><tr><td>空间索引</td><td>空间索引 是对 空间数据类型 的字段 建立的索引</td></tr><tr><td>前缀索引</td><td>对索引列的前缀进行索引，可以节省索引存储空间</td></tr></tbody></table><h3 id="根据索引的字段个数分类"><a href="#根据索引的字段个数分类" class="headerlink" title="根据索引的字段个数分类"></a>根据索引的字段个数分类</h3><table><thead><tr><th>索引</th><th>简介</th></tr></thead><tbody><tr><td>单值索引</td><td>即一个索引只包含单个列，一个表可以有多个单列索引</td></tr><tr><td>复合索引</td><td>即一个索引包含多个列</td></tr></tbody></table><h3 id="根据索引的存储形式分类"><a href="#根据索引的存储形式分类" class="headerlink" title="根据索引的存储形式分类"></a>根据索引的存储形式分类</h3><table><thead><tr><th>索引</th><th>简介</th></tr></thead><tbody><tr><td>聚集(簇)索引</td><td>聚集（簇）索引是基于表中的主键或唯一约束创建的一种索引，主要作用是对表进行物理排序，使得相邻的行存储在一起，每个表只能有一个，并且该索引决定了数据在物理上的存储顺序</td></tr><tr><td>非聚集(簇)索引（也称为辅助索引或二级索引）</td><td>非聚集（簇）索引，也称为辅助索引或二级索引，是基于表中的普通列创建的一种索引，用于加速对这些列的查询和排序操作，可以有多个</td></tr></tbody></table><h2 id="索引的语法"><a href="#索引的语法" class="headerlink" title="索引的语法"></a>索引的语法</h2><h3 id="建表时指定索引"><a href="#建表时指定索引" class="headerlink" title="建表时指定索引"></a>建表时指定索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> [if <span class="keyword">not</span> <span class="keyword">exists</span>]表名称(</span><br><span class="line">	字段信息,</span><br><span class="line">	<span class="keyword">primary</span> key 索引名称(主键索引的列名称[(length)] [<span class="keyword">asc</span><span class="operator">/</span><span class="keyword">desc</span>]), </span><br><span class="line">	<span class="keyword">unique</span> 索引名称(唯一索引的列名称[(length)] [<span class="keyword">asc</span><span class="operator">/</span><span class="keyword">desc</span>]),</span><br><span class="line">	index 索引名称(普通索引的列名称[(length)) [<span class="keyword">asc</span><span class="operator">/</span><span class="keyword">desc</span>],</span><br><span class="line">	fulltext 索引名称(全文索引的列名称[(length)] [<span class="keyword">asc</span><span class="operator">/</span><span class="keyword">desc</span>]),</span><br><span class="line">	spatial 索引名称(空间索引的列名称[(length)] [<span class="keyword">asc</span><span class="operator">/</span><span class="keyword">desc</span>])</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>注意事项：</p><ul><li>一个表只能创建一个主键索引，但可以创建多个唯一索引、普通索引、全文索引</li><li>空间索引只能添加在非空的空间类型字段上</li><li>length 为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度</li><li>MySQL5.7索引默认asc升序排序，MySQL8.0支持desc降序索引，空间索引和全文索引不支持指定排序顺序</li></ul><p>使用案例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> users(</span><br><span class="line">    id <span class="type">INT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT, </span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">150</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">    password <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">    location GEOMETRY <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">primary</span> key (id <span class="keyword">asc</span>), </span><br><span class="line">    <span class="keyword">unique</span> (email(<span class="number">3</span>) <span class="keyword">desc</span>), </span><br><span class="line">    index idx_users_name (name(<span class="number">3</span>) <span class="keyword">asc</span>), </span><br><span class="line">    fulltext ft_users_name (name(<span class="number">3</span>)),</span><br><span class="line">    spatial INDEX idx_users_location (location) </span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><h3 id="建表后指定索引"><a href="#建表后指定索引" class="headerlink" title="建表后指定索引"></a>建表后指定索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 为指定表字段创建主键索引，确保表中某列（或多列）数据的唯一性和非空性</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">primary</span> key index 索引名称 <span class="keyword">on</span> 表名称(列名称)</span><br><span class="line"></span><br><span class="line"># 为指定表字段创建唯一索引，确保表中某列（或多列）数据的唯一性</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index 索引名称 <span class="keyword">on</span> 表名称(列名称)</span><br><span class="line"></span><br><span class="line"># 为指定表字段创建普通索引，提高 <span class="keyword">SELECT</span> 查询的效率</span><br><span class="line"><span class="keyword">create</span> index 索引名称 <span class="keyword">on</span> 表名称(列名称)</span><br><span class="line"></span><br><span class="line"># 为指定表字段创建全文索引，支持对文本列进行全文搜索</span><br><span class="line"><span class="keyword">create</span> fulltext index 索引名称 <span class="keyword">on</span> 表名称(列名称)</span><br><span class="line"></span><br><span class="line"># 为指定表非空的空间类型字段创建空间索引</span><br><span class="line"><span class="keyword">create</span> spatial index 索引名称 <span class="keyword">on</span> 表名称(列名称)</span><br></pre></td></tr></table></figure><h3 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 方式一</span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> 表名称</span><br><span class="line"># 方式二</span><br><span class="line"><span class="keyword">show</span> kwys <span class="keyword">from</span> 表名称</span><br></pre></td></tr></table></figure><h3 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 添加主键索引，确保表中某列（或多列）数据的唯一性和非空性</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">add</span> <span class="keyword">primary</span> key 索引名称(列名称)</span><br><span class="line"></span><br><span class="line"># 添加唯一索引，确保表中某列（或多列）数据的唯一性</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">add</span> <span class="keyword">unique</span> 索引名称(列名称)</span><br><span class="line"></span><br><span class="line"># 添加普通索引，提高 <span class="keyword">SELECT</span> 查询的效率</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">add</span> index 索引名称 (列名称)</span><br><span class="line"></span><br><span class="line"># 添加全文索引，支持对文本列进行全文搜索</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">add</span> fulltext 索引名称(列名称)</span><br></pre></td></tr></table></figure><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 方式一</span><br><span class="line"><span class="keyword">drop</span> index 索引名称 <span class="keyword">on</span> 表名</span><br><span class="line"># 方式二</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> index 索引名;</span><br></pre></td></tr></table></figure><h3 id="索引的禁用与开启"><a href="#索引的禁用与开启" class="headerlink" title="索引的禁用与开启"></a>索引的禁用与开启</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 禁用索引，只会禁用非唯一索引，唯一索引和主键索引不会被禁用</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 disable keys</span><br><span class="line"></span><br><span class="line"># 重新启用表的索引，MySQL 会更新所有被修改过的键值，以保证索引的正确性和完整性</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 enable keys</span><br></pre></td></tr></table></figure><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><p>MySQL的索引是在存储引擎层实现的，平常所说的索引，如果没有特别指明，都是指B+树结构组织的索引</p><table><thead><tr><th>索引结构</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+Tree</td><td>√（MySQL5.6+）</td><td>√（MySQL4.0+）</td><td>√（ALL）</td></tr><tr><td>Hash</td><td>×（不支持）</td><td>×（不支持）</td><td>×（ALL）</td></tr><tr><td>R-Tree</td><td>√（MySQL5.6+）</td><td>×（NO）</td><td>×（不支持）</td></tr><tr><td>Full-text</td><td>√（MySQL5.6+）</td><td>√（MySQL4.1+）</td><td>×（不支持）</td></tr></tbody></table><table><thead><tr><th>索引结构</th><th>简介</th></tr></thead><tbody><tr><td>Hash（哈希索引）</td><td>使用哈希表进行存储的索引类型，Key 存储索引列，Value 存储行记录或行磁盘地址<br>Hash 只支持等值查询（&#x3D;，IN，&lt;&#x3D;&gt;）<br>Hash 不支持任何范围查询（ between ， &gt; ， &lt; ， … ），因为每个键之间没有任何的联系</td></tr><tr><td>B+Tree（B+树索引）</td><td>最常见的索引类型，大部分引擎都支持 B+ 树索引，用于存储有序数据，适合范围查询、排序和分组等操作</td></tr><tr><td>R-tree（空间索引）</td><td>空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td>Full-text（全文索引）</td><td>全文索引，是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene、Solr、ES</td></tr></tbody></table><h3 id="哈希索引（Hash）"><a href="#哈希索引（Hash）" class="headerlink" title="哈希索引（Hash）"></a>哈希索引（Hash）</h3><p>哈希表（Hash table），存储键值对（Key Value）数据的一种数据结构</p><p>哈希表可以看作是由数组和链表组成的数据结构，其中数组被称为哈希桶（bucket），每个桶中存储一个链表</p><p>哈希表通过哈希函数，将键映射到数组的某个位置上，当需要存储数据时，先根据哈希函数，计算出数据对应的哈希桶的位置，然后将数据插入到该位置对应的链表中</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2020/11/15/MySQL-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/Hash.png" style="zoom:50%"><h3 id="B-树（B-Tree）"><a href="#B-树（B-Tree）" class="headerlink" title="B 树（B Tree）"></a>B 树（B Tree）</h3><p>B树是一种自平衡多叉搜索树，所有节点既存放键（key）也存放数据（data）</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2020/11/15/MySQL-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/B-树.png" style="zoom:50%"><h3 id="B-树（B-Tree）-1"><a href="#B-树（B-Tree）-1" class="headerlink" title="B + 树（B + Tree）"></a>B + 树（B + Tree）</h3><p>B + Tree是B 树的变种，在 B 树基础上为叶子节点增加了单向指针，形成有序链表，并且只有叶子节点存放键（key）和数据（data），非叶子节点只存放键（key）</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2020/11/15/MySQL-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/B+树.png" style="zoom:50%"><h3 id="MySQL中的-B-树（B-Tree）"><a href="#MySQL中的-B-树（B-Tree）" class="headerlink" title="MySQL中的 B + 树（B + Tree）"></a>MySQL中的 B + 树（B + Tree）</h3><p>MySQL索引数据结构对经典的B+Tree进行了优化，将B+ 树中叶子节点之间的<code>单向指针改为双向指针</code>，形成双向链表，可以从两个方向依次遍历叶子节点，可以更快速地定位范围内的数据块，提高查询效率</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2020/11/15/MySQL-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/MySQL中的B+树.png" style="zoom:50%"><h4 id="InnoDB中一颗B-树可以存放多少行数据？"><a href="#InnoDB中一颗B-树可以存放多少行数据？" class="headerlink" title="InnoDB中一颗B+树可以存放多少行数据？"></a>InnoDB中一颗B+树可以存放多少行数据？</h4><p>在InnoDB中，一颗B+树可以存放多少行数据是由多个因素决定的，包括页大小，数据行大小以及树的层级等，一个三层的B+树大约可存2200万条数据。</p><ul><li><strong>页大小</strong>：在InnoDB的B+树结构中，数据是以页（Page）为单位进行存储和管理的，每个页的默认大小为16KB（16 * 1024字节）。</li><li><strong>数据行大小</strong>：每行数据的大小取决于所存储的列以及其数据类型，不同的列会占用不同的空间。假设一条数据占 1 kb 的空间，那么一个页可以存放 16 条这样的数据。</li></ul><p>每个B+树节点都对应一个页（page），这些页通常被称为数据页或索引页，它们存储了数据库中的索引和数据。</p><ul><li><strong>B+树叶子节点</strong>：每个叶子节点对应一个数据页，用来存放实际的数据行。假设一条数据占 1 kb 的空间，那么一个叶子节点可以存放 16 条这样的数据。</li><li><strong>B+树非叶子节点</strong>：每个非叶子节点都对应一个索引页，用来存放索引信息，由指向下一层地址的指针和主键值组成。指针大小在InnoDB源码中设置为6字节，如果主键是bigint类型，会占8个字节。</li></ul><p>根据上述信息，可以计算出一个非叶子节点（索引页）中可以存储的索引信息（主键+指针）数量：(16 * 1024) &#x2F; (6 + 8) ≈ 1170，就是说一个非叶子节点（索引页）中可以存放大约1170个指向下一层地址的指针，下一层大约有1170个叶子节点（数据页）。</p><p>综合上述信息，可以得出不同B+树层级的数据存储情况：</p><ul><li>如果B+树有1层，那么根节点就是叶子节点（数据页），最多能存放 <code>16</code> 条记录，大约占用<code>16 KB</code>空间；</li><li>如果B+树有2层，那么第一层是非叶子节点（索引页），指向下一层地址的指针有<code>1170</code>个，第二层都是叶子节点（数据页）会有<code>1170</code>个，最多能存放 <code>1170 × 16 = 18720</code> 条记录，大约占用<code>18.72 MB</code>空间；</li><li>如果B+树有3层，那么第二层是非叶子节点（索引页），指向下一层地址的指针有<code>1170 x 1170</code>个，第三层都是叶子节点（数据页）会有<code>1170 x 1170</code>个，最多能存放 <code>1170 x 1170 x 16 = 21902400</code> 条记录，大约占用<code>21.9 GB</code>空间；</li></ul><h2 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>（1）在InnoDB中，每张表都有一个特殊的索引叫做聚簇索引（也叫聚集索引），它是按照主键顺序存储的B+树，叶子节点同时存储了主键值和整行数据，整张表的数据都存储在聚簇索引中</p><p>（2）一个表只能有一个聚簇索引，主键一定是聚簇索引</p><p>（3）通过主键可以直接在聚簇索引找到对应的行数据</p><p>（4）聚簇索引的建立原则</p><ul><li>如果一个主键被定义了，那么这个主键就是作为聚簇索引</li><li>如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚簇索引</li><li>如果没有主键也没有合适的唯一索引，那么InnoDB内部会生成一个隐藏的主键作为聚簇索引</li></ul><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>（1）除了聚簇索引外的其它索引都叫非聚簇索引（也称为非聚集索引或辅助索引或二级索引），与聚簇索引的区别是叶子节点中只存了索引列和主键值，索引和数据是分开的</p><p>（2）一个表可以有多个非聚簇索引，唯一索引、单列索引、复合索引都属于二次索引，只是从逻辑角度进行的分类</p><p>（3）通过二级索引需要先找到主键值，再根据主键值到聚簇索引找到对应的行，也就是平常说的要进行一次回表操作</p><h3 id="聚簇索引与非聚簇索引区别"><a href="#聚簇索引与非聚簇索引区别" class="headerlink" title="聚簇索引与非聚簇索引区别"></a>聚簇索引与非聚簇索引区别</h3><table><thead><tr><th>区别</th><th>聚集(簇)索引</th><th>非聚集(簇)索引（也称为辅助索引或二级索引）</th></tr></thead><tbody><tr><td>索引数量</td><td>每张表只能有一个</td><td>每张表可以有多个</td></tr><tr><td>叶子节点</td><td>叶子节点存储的是整行数据</td><td>叶子节点存储的是键值和指向对应数据行的物理地址（也称为指针）</td></tr><tr><td>非叶子节点</td><td>非叶子节点存储的是键值和指向下一级节点的地址</td><td>非叶子结点存储的是键值和指向下一级节点的指针</td></tr><tr><td>返回数据的方式</td><td>找到一个符合条件的记录时可以直接返回整行数据</td><td>先通过索引找到对应的记录地址 再根据地址访问数据页 最终获取整行数据</td></tr><tr><td>存储方式</td><td>数据和索引结构存储在一起</td><td>数据和索引结构分开存储</td></tr><tr><td>存储顺序</td><td>以聚集索引的索引树作为表数据的存储顺序</td><td>无固定存储顺序</td></tr><tr><td>性能影响</td><td>更新、插入操作性能好；</td><td>查询操作性能好，更新、插入操作性能差；</td></tr></tbody></table><h2 id="覆盖索引和回表查询"><a href="#覆盖索引和回表查询" class="headerlink" title="覆盖索引和回表查询"></a>覆盖索引和回表查询</h2><h3 id="已知信息"><a href="#已知信息" class="headerlink" title="已知信息"></a>已知信息</h3><p>已知下表tb_user，id是主键，是一个聚集索引。 name字段建立了普通索引，是一个二级索引（辅助索引）</p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2020/11/15/MySQL-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/聚集索引和非聚集索引.png" style="zoom:50%"><p>执行如下SQL根据id查询一条数据，会直接走聚集索引查询并返回数据，只会涉及一次索引扫描，性能高。因为id是主键，主键默认会建立聚集索引，并且聚集索引叶子节点含有完整数据，可以直接利用该索引定位到指定的数据行，并且直接返回相应的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2020/11/15/MySQL-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/聚集索引.png" style="zoom:50%"><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>执行如下SQL会根据id查询id和name，因为id和name两个值都是可以直接获取到的，属于覆盖索引，会直接走二级索引并返回数据，性能高</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name <span class="keyword">from</span> tb_user <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Arm&#x27;</span>;</span><br></pre></td></tr></table></figure><p>&lt;img src&#x3D;”MySQL-4-数据库优化\覆盖索引.png” style&#x3D;”zoom:50%;” &#x2F;</p><h3 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h3><p>执行如下SQL时，由于是根据name字段进行查询，所以不能直接使用聚集索引进行查询，而是先根据name&#x3D;’Arm’到name字段的二级索引中进行匹配查找主键ID值10，根据主键ID值10，到聚集索引中查找10对应的记录，最终找到10对应的row行数据返回，性能相对较差一点</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Arm&#x27;</span>;</span><br></pre></td></tr></table></figure><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2020/11/15/MySQL-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/回表查询.png" style="zoom:50%"><h2 id="索引的失效情况"><a href="#索引的失效情况" class="headerlink" title="索引的失效情况"></a>索引的失效情况</h2><h3 id="测试表和测试数据"><a href="#测试表和测试数据" class="headerlink" title="测试表和测试数据"></a>测试表和测试数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `users` (</span><br><span class="line">    `id` <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    `name` <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    `gender` <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    `age` <span class="type">INT</span>,</span><br><span class="line">    `height` <span class="type">INT</span>,</span><br><span class="line">	`weight` <span class="type">INT</span>,</span><br><span class="line">    `email` <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">    `create_time` DATETIME</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (id, name, gender, age, height, weight, email, create_time)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">&#x27;郑一&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">25</span>, <span class="number">170</span>, <span class="number">65</span>, <span class="string">&#x27;lixiaoming@example.com&#x27;</span>, <span class="string">&#x27;2023-01-01 12:00:00&#x27;</span>),</span><br><span class="line">(<span class="number">2</span>, <span class="string">&#x27;钟二&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">28</span>, <span class="number">165</span>, <span class="number">55</span>, <span class="string">&#x27;wangxiaohong@example.com&#x27;</span>, <span class="string">&#x27;2023-02-03 09:30:00&#x27;</span>),</span><br><span class="line">(<span class="number">3</span>, <span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">22</span>, <span class="number">180</span>, <span class="number">75</span>, <span class="string">&#x27;zhangdazhi@example.com&#x27;</span>, <span class="string">&#x27;2023-03-05 15:45:00&#x27;</span>),</span><br><span class="line">(<span class="number">4</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">31</span>, <span class="number">160</span>, <span class="number">50</span>, <span class="string">&#x27;zhaoxiaofang@example.com&#x27;</span>, <span class="string">&#x27;2023-04-07 18:20:00&#x27;</span>),</span><br><span class="line">(<span class="number">5</span>, <span class="string">&#x27;王五&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">27</span>, <span class="number">175</span>, <span class="number">70</span>, <span class="string">&#x27;liujianhua@example.com&#x27;</span>, <span class="string">&#x27;2023-05-09 11:10:00&#x27;</span>),</span><br><span class="line">(<span class="number">6</span>, <span class="string">&#x27;赵六&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">24</span>, <span class="number">165</span>, <span class="number">60</span>, <span class="string">&#x27;zhengyulan@example.com&#x27;</span>, <span class="string">&#x27;2023-06-11 14:55:00&#x27;</span>),</span><br><span class="line">(<span class="number">7</span>, <span class="string">&#x27;钱七&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">29</span>, <span class="number">172</span>, <span class="number">68</span>, <span class="string">&#x27;huangxiaolong@example.com&#x27;</span>, <span class="string">&#x27;2023-07-13 17:30:00&#x27;</span>),</span><br><span class="line">(<span class="number">8</span>, <span class="string">&#x27;孙八&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">26</span>, <span class="number">168</span>, <span class="number">58</span>, <span class="string">&#x27;chenlihua@example.com&#x27;</span>, <span class="string">&#x27;2023-08-15 10:25:00&#x27;</span>),</span><br><span class="line">(<span class="number">9</span>, <span class="string">&#x27;周九&#x27;</span>, <span class="string">&#x27;男&#x27;</span>, <span class="number">23</span>, <span class="number">178</span>, <span class="number">72</span>, <span class="string">&#x27;yangjun@example.com&#x27;</span>, <span class="string">&#x27;2023-09-17 13:40:00&#x27;</span>),</span><br><span class="line">(<span class="number">10</span>, <span class="string">&#x27;吴十&#x27;</span>, <span class="string">&#x27;女&#x27;</span>, <span class="number">30</span>, <span class="number">162</span>, <span class="number">53</span>, <span class="string">&#x27;wuxiaoxue@example.com&#x27;</span>, <span class="string">&#x27;2023-10-19 16:15:00&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="对索引列使用不等于匹配"><a href="#对索引列使用不等于匹配" class="headerlink" title="对索引列使用不等于匹配"></a>对索引列使用不等于匹配</h3><p>当查询条件中使用<code>!=</code>或<code>&lt;&gt;</code>符号来匹配索引列时，索引将无法使用。这是因为索引通常按照值的顺序进行存储和排序，不等于操作需要对所有可能的值进行比较，无法有效利用索引的有序性进行快速查找。使用等于符号<code>=</code>来匹配索引列时，能使用索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 为name字段创建索引</span><br><span class="line">CREATE INDEX index_users_name ON users(name);</span><br><span class="line"># 索引失效</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM users WHERE name != &#x27;张三&#x27;;</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM users WHERE name &lt;&gt; &#x27;张三&#x27;;</span><br><span class="line"># 可以使用索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM users WHERE name = &#x27;张三&#x27;;</span><br></pre></td></tr></table></figure><h3 id="对索引列使用IS-NOT-NULL"><a href="#对索引列使用IS-NOT-NULL" class="headerlink" title="对索引列使用IS NOT NULL"></a>对索引列使用IS NOT NULL</h3><p>当查询条件使用<code>IS NOT NULL</code>来匹配索引列时，索引将失效。原因是索引只包含有值的行，而IS NOT NULL操作需要检查所有行，因此无法使用索引加速查询。使用<code>IS NULL</code>来匹配索引列时，能使用索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 为gender字段创建索引</span><br><span class="line">CREATE INDEX index_users_gender ON users(gender);</span><br><span class="line"># 索引失效</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE gender IS NOT NULL;</span><br><span class="line"># 可以使用索引</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE gender IS NULL;</span><br></pre></td></tr></table></figure><h3 id="对索引列进行模糊查询like以-开头"><a href="#对索引列进行模糊查询like以-开头" class="headerlink" title="对索引列进行模糊查询like以%开头"></a>对索引列进行模糊查询like以%开头</h3><p>当使用LIKE语句进行模糊查询时，如果通配符%出现在查询模式的起始位置，索引也会失效。因为索引是按照值的顺序存储的，无法利用索引的有序性，必须逐行扫描表中的数据。可以通过使用覆盖索引，只查询索引列来避免索引失效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 为email字段创建索引</span><br><span class="line">CREATE INDEX index_users_email ON users(email);</span><br><span class="line"># 索引失效</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE email like &quot;%user&quot;;</span><br><span class="line"># 索引失效</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE email like &quot;%user%&quot;;</span><br><span class="line"># 可以使用索引</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE email like &quot;user%&quot;;</span><br><span class="line"># 使用覆盖索引避免失效</span><br><span class="line">EXPLAIN SELECT email FROM users WHERE email like &quot;%user%&quot;;</span><br></pre></td></tr></table></figure><h3 id="对索引列进行运算操作"><a href="#对索引列进行运算操作" class="headerlink" title="对索引列进行运算操作"></a>对索引列进行运算操作</h3><p>当查询条件对索引列进行运算操作时，索引将失效。运算操作会改变列的值，使得索引无法提供正确的匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 为age字段创建索引</span><br><span class="line">CREATE INDEX index_users_age ON users(age);</span><br><span class="line"># 索引失效</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE age + 1 = 100;</span><br></pre></td></tr></table></figure><h3 id="对索引列进行函数操作"><a href="#对索引列进行函数操作" class="headerlink" title="对索引列进行函数操作"></a>对索引列进行函数操作</h3><p>当查询条件对索引列进行函数操作时，索引将失效。函数操作会生成新的值，无法在索引中进行匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 为create_time字段创建索引</span><br><span class="line">CREATE INDEX index_users_create_time ON users(create_time);</span><br><span class="line"># 索引失效</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE year(create_time) = 2019;</span><br></pre></td></tr></table></figure><h3 id="使用运算符OR前后存在非索引的列"><a href="#使用运算符OR前后存在非索引的列" class="headerlink" title="使用运算符OR前后存在非索引的列"></a>使用运算符OR前后存在非索引的列</h3><p>如果查询条件中使用了 OR，那么除非每个 OR 条件都能使用索引，否则索引可能会失效。要保证每个OR条件都能使用索引才能保证索引有效。因为OR操作需要对所有的条件进行计算，一旦出现非索引列，就无法使用索引加速查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 为name字段创建索引</span><br><span class="line">CREATE INDEX index_users_name ON users(name);</span><br><span class="line"># 索引失效</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE name = &quot;张三&quot; OR age = 20;</span><br><span class="line"># 为age字段创建索引</span><br><span class="line">CREATE INDEX index_users_age ON users(age);</span><br><span class="line"># 可以使用索引</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE name = &quot;张三&quot; OR age = 20;</span><br></pre></td></tr></table></figure><h3 id="复合索引违反最左前缀法则"><a href="#复合索引违反最左前缀法则" class="headerlink" title="复合索引违反最左前缀法则"></a>复合索引违反最左前缀法则</h3><p>如果不使用该复合索引的最左边的索引列，则该复合索引会失效，如果跳过复合索引中的某一索引列，则这一索引列后面的索引会失效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个复合索引</span><br><span class="line">CREATE INDEX index_users_name_age_gender ON users(name, age, gender);</span><br><span class="line"># 索引失效</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE age = 20 and gender = &#x27;男&#x27;;</span><br><span class="line"># name索引有效，age和gender失效</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE name = &quot;张三&quot; and gender = &#x27;男&#x27;;</span><br><span class="line"># name、age、gender都有效</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE name = &quot;张三&quot; and age = 20 and gender = &#x27;男&#x27;;</span><br></pre></td></tr></table></figure><h1 id="数据库优化"><a href="#数据库优化" class="headerlink" title="数据库优化"></a>数据库优化</h1><h2 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h2><h3 id="避免使用SELECT-查询"><a href="#避免使用SELECT-查询" class="headerlink" title="避免使用SELECT * 查询"></a>避免使用SELECT * 查询</h3><p>使用 SELECT * 会查询表中的所有列，包括不需要的列，这会增加数据传输量和内存消耗。明确指定需要查询的列可以减少不必要的资源消耗。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 不推荐</span><br><span class="line">SELECT * FROM table_name;</span><br><span class="line"></span><br><span class="line"># 推荐</span><br><span class="line">SELECT column1, column2, ... FROM table_name;</span><br></pre></td></tr></table></figure><h3 id="避免使用不必要的DISTINCT去重"><a href="#避免使用不必要的DISTINCT去重" class="headerlink" title="避免使用不必要的DISTINCT去重"></a>避免使用不必要的DISTINCT去重</h3><p>使用 SELECT DISTINCT 去重会增加查询的开销，因为它需要在结果集上执行排序和比较操作。如果不必要，尽量避免使用 DISTINCT，而是通过其他方式进行去重操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 不推荐</span><br><span class="line">SELECT DISTINCT column1, column2 FROM table_name;</span><br><span class="line"></span><br><span class="line"># 推荐</span><br><span class="line">SELECT column1, column2 FROM table_name;</span><br></pre></td></tr></table></figure><h3 id="避免不必要的ORDER-BY排序"><a href="#避免不必要的ORDER-BY排序" class="headerlink" title="避免不必要的ORDER BY排序"></a>避免不必要的ORDER BY排序</h3><p>如果只关心查询结果的数据，而不需要按特定顺序排列，那么可以删除 ORDER BY 子句，提高查询性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 不推荐</span><br><span class="line">SELECT column1, column2</span><br><span class="line">FROM table1</span><br><span class="line">ORDER BY column1;</span><br><span class="line"># 推荐</span><br><span class="line">SELECT column1, column2</span><br><span class="line">FROM table1;</span><br></pre></td></tr></table></figure><h3 id="避免使用多个JOIN联表查询"><a href="#避免使用多个JOIN联表查询" class="headerlink" title="避免使用多个JOIN联表查询"></a>避免使用多个JOIN联表查询</h3><p>多个 JOIN 联表查询会引入更多的关联和数据扫描成本。在实际应用中，可以考虑拆分查询进行优化，以减少联接操作的复杂性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 不推荐</span><br><span class="line">SELECT t1.column1, t2.column2, t3.column3</span><br><span class="line">FROM table1 t1</span><br><span class="line">JOIN table2 t2 ON t1.id = t2.id</span><br><span class="line">JOIN table3 t3 ON t2.id = t3.id;</span><br></pre></td></tr></table></figure><h3 id="避免使用子查询"><a href="#避免使用子查询" class="headerlink" title="避免使用子查询"></a>避免使用子查询</h3><p>子查询可能会执行多次，每次执行都会引入额外的开销。通过使用 JOIN 或临时表进行联接，可以将子查询转换为更高效的连接操作，从而提高查询性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 不推荐</span><br><span class="line">SELECT column1</span><br><span class="line">FROM table1</span><br><span class="line">WHERE column2 IN (SELECT column3 FROM table2);</span><br><span class="line"></span><br><span class="line"># 推荐</span><br><span class="line">SELECT t1.column1</span><br><span class="line">FROM table1 t1</span><br><span class="line">JOIN table2 t2 ON t1.column2 = t2.column3;</span><br></pre></td></tr></table></figure><h3 id="使用INNER-JOIN代替LEFT-JOIN或RIGHT-JOIN"><a href="#使用INNER-JOIN代替LEFT-JOIN或RIGHT-JOIN" class="headerlink" title="使用INNER JOIN代替LEFT JOIN或RIGHT JOIN"></a>使用INNER JOIN代替LEFT JOIN或RIGHT JOIN</h3><p>INNER JOIN 只返回匹配的行，而 LEFT JOIN 或 RIGHT JOIN 还会返回左表或右表中未匹配的行。如果不需要这些额外的数据，尽量使用 INNER JOIN，可以减少不必要的数据扫描和连接操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 不推荐</span><br><span class="line">SELECT t1.column1, t2.column2</span><br><span class="line">FROM table1 t1</span><br><span class="line">LEFT JOIN table2 t2 ON t1.id = t2.id;</span><br><span class="line"></span><br><span class="line"># 推荐</span><br><span class="line">SELECT t1.column1, t2.column2</span><br><span class="line">FROM table1 t1</span><br><span class="line">INNER JOIN table2 t2 ON t1.id = t2.id;</span><br></pre></td></tr></table></figure><h3 id="使用WHERE替换HAVING子句"><a href="#使用WHERE替换HAVING子句" class="headerlink" title="使用WHERE替换HAVING子句"></a>使用WHERE替换HAVING子句</h3><p>HAVING 子句用于对分组后的结果进行过滤，而 WHERE 子句用于对原始数据进行过滤。将过滤条件放在 WHERE 子句中可以减少分组的数据量，提高查询效率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 不推荐</span><br><span class="line">SELECT column1, COUNT(column2) as count</span><br><span class="line">FROM table_name</span><br><span class="line">GROUP BY column1</span><br><span class="line">HAVING count &gt; 10;</span><br><span class="line"></span><br><span class="line"># 推荐</span><br><span class="line">SELECT column1, COUNT(column2) as count</span><br><span class="line">FROM table_name</span><br><span class="line">WHERE count &gt; 10</span><br><span class="line">GROUP BY column1;</span><br></pre></td></tr></table></figure><h3 id="使用UNION-ALL代替UNION"><a href="#使用UNION-ALL代替UNION" class="headerlink" title="使用UNION ALL代替UNION"></a>使用UNION ALL代替UNION</h3><p>UNION 操作会对结果集进行去重操作，而 UNION ALL 不会。如果不需要去重，可以使用 UNION ALL 替代 UNION，从而减少排序和比较的开销。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 不推荐</span><br><span class="line">SELECT column1, column2 FROM table1</span><br><span class="line">UNION</span><br><span class="line">SELECT column1, column2 FROM table2;</span><br><span class="line"></span><br><span class="line"># 推荐</span><br><span class="line">SELECT column1, column2 FROM table1</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT column1, column2 FROM table2;</span><br></pre></td></tr></table></figure><h3 id="使用LIMIT子句限制查询结果"><a href="#使用LIMIT子句限制查询结果" class="headerlink" title="使用LIMIT子句限制查询结果"></a>使用LIMIT子句限制查询结果</h3><p>LIMIT 子句允许你限制查询结果的数量。当只需要获取部分查询结果时，通过使用 LIMIT 可以减少数据传输和处理的开销。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 不推荐</span><br><span class="line">SELECT column1, column2</span><br><span class="line">FROM table_name</span><br><span class="line"># 推荐</span><br><span class="line">SELECT column1, column2</span><br><span class="line">FROM table_name</span><br><span class="line">LIMIT 10;</span><br></pre></td></tr></table></figure><h3 id="使用NOT-EXISTS替代NOT-IN"><a href="#使用NOT-EXISTS替代NOT-IN" class="headerlink" title="使用NOT EXISTS替代NOT IN"></a>使用NOT EXISTS替代NOT IN</h3><p>NOT IN子句和 NOT EXISTS 子句都可以用于子查询，判断某个值是否不存在。但是 NOT EXISTS 更高效，因为它只需要判断是否不存在结果，而不需要检索具体的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 不推荐</span><br><span class="line">SELECT column1</span><br><span class="line">FROM table1</span><br><span class="line">WHERE column2 NOT IN (SELECT column3 FROM table2);</span><br><span class="line"></span><br><span class="line"># 推荐</span><br><span class="line">SELECT column1</span><br><span class="line">FROM table1</span><br><span class="line">WHERE NOT EXISTS (SELECT 1 FROM table2 WHERE table1.column2 = table2.column3);</span><br></pre></td></tr></table></figure><h3 id="使用EXISTS替代IN"><a href="#使用EXISTS替代IN" class="headerlink" title="使用EXISTS替代IN"></a>使用EXISTS替代IN</h3><p>IN 子句和 EXISTS 子句都可以用于子查询，判断某个值是否存在。但是 EXISTS 更高效，因为它只需要判断是否存在结果，而不需要检索具体的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 不推荐</span><br><span class="line">SELECT column1</span><br><span class="line">FROM table1</span><br><span class="line">WHERE column2 IN (SELECT column3 FROM table2);</span><br><span class="line"></span><br><span class="line"># 推荐</span><br><span class="line">SELECT column1</span><br><span class="line">FROM table1</span><br><span class="line">WHERE EXISTS (SELECT 1 FROM table2 WHERE table1.column2 = table2.column3);</span><br></pre></td></tr></table></figure><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><p>通过合理选择字段添加索引、使用联合索引、避免过多索引以及定期维护和优化索引，可以最大程度地提高数据库的查询性能，并确保索引的有效性和一致性。</p><ol><li><strong>频繁访问的字段适合添加索引</strong>：通过为频繁使用的字段添加索引，可以加快查询操作的速度。这样可以减少数据库的扫描次数，提高查询效率。</li><li><strong>使用联合索引来覆盖查询</strong>：在某些情况下，单个索引无法满足复杂的查询需求。使用联合索引可以在一个索引中包含多个列，以便更好地支持复杂的查询操作。联合索引能够通过覆盖查询（Covering Index）的方式，直接从索引中获取所需数据，而不必再去查询表的行数据，从而提高查询性能。</li><li><strong>避免过多的索引</strong>：过多的索引会使数据库写操作的性能下降，并且会占用更多的存储空间。每个索引都需要维护和更新，因此过多的索引会增加数据库维护的成本。因此，在创建索引时，需要评估每个索引的必要性，并避免创建不必要的索引。</li><li><strong>维护索引并避免索引失效</strong>：随着数据的插入、更新和删除，索引的数据也会发生变化。为了保证索引的有效性和性能，需要定期维护索引。维护索引可以包括重建索引、重新组织索引等操作。此外，还需要避免使用不符合索引定义的查询，以免触发索引失效。</li></ol><h3 id="避免对索引列使用不等于匹配"><a href="#避免对索引列使用不等于匹配" class="headerlink" title="避免对索引列使用不等于匹配"></a>避免对索引列使用不等于匹配</h3><p>当查询条件中使用<code>!=</code>或<code>&lt;&gt;</code>符号来匹配索引列时，索引将无法使用。这是因为索引通常按照值的顺序进行存储和排序，不等于操作需要对所有可能的值进行比较，无法有效利用索引的有序性进行快速查找。使用等于符号<code>=</code>来匹配索引列时，能使用索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 为name字段创建索引</span><br><span class="line">CREATE INDEX index_users_name ON users(name);</span><br><span class="line"># 索引失效</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM users WHERE name != &#x27;张三&#x27;;</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM users WHERE name &lt;&gt; &#x27;张三&#x27;;</span><br><span class="line"># 可以使用索引</span><br><span class="line">EXPLAIN SELECT SQL_NO_CACHE * FROM users WHERE name = &#x27;张三&#x27;;</span><br></pre></td></tr></table></figure><h3 id="避免对索引列使用IS-NOT-NULL"><a href="#避免对索引列使用IS-NOT-NULL" class="headerlink" title="避免对索引列使用IS NOT NULL"></a>避免对索引列使用IS NOT NULL</h3><p>当查询条件使用<code>IS NOT NULL</code>来匹配索引列时，索引将失效。原因是索引只包含有值的行，而IS NOT NULL操作需要检查所有行，因此无法使用索引加速查询。使用<code>IS NULL</code>来匹配索引列时，能使用索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 为gender字段创建索引</span><br><span class="line">CREATE INDEX index_users_gender ON users(gender);</span><br><span class="line"># 索引失效</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE gender IS NOT NULL;</span><br><span class="line"># 可以使用索引</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE gender IS NULL;</span><br></pre></td></tr></table></figure><h3 id="避免对索引列进行模糊查询like以-开头"><a href="#避免对索引列进行模糊查询like以-开头" class="headerlink" title="避免对索引列进行模糊查询like以%开头"></a>避免对索引列进行模糊查询like以%开头</h3><p>当使用LIKE语句进行模糊查询时，如果通配符%出现在查询模式的起始位置，索引也会失效。因为索引是按照值的顺序存储的，无法利用索引的有序性，必须逐行扫描表中的数据。可以通过使用覆盖索引，只查询索引列来避免索引失效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 为email字段创建索引</span><br><span class="line">CREATE INDEX index_users_email ON users(email);</span><br><span class="line"># 索引失效</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE email like &quot;%user&quot;;</span><br><span class="line"># 索引失效</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE email like &quot;%user%&quot;;</span><br><span class="line"># 可以使用索引</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE email like &quot;user%&quot;;</span><br><span class="line"># 使用覆盖索引避免失效</span><br><span class="line">EXPLAIN SELECT email FROM users WHERE email like &quot;%user%&quot;;</span><br></pre></td></tr></table></figure><h3 id="避免对索引列进行运算操作"><a href="#避免对索引列进行运算操作" class="headerlink" title="避免对索引列进行运算操作"></a>避免对索引列进行运算操作</h3><p>当查询条件对索引列进行运算操作时，索引将失效。运算操作会改变列的值，使得索引无法提供正确的匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 为age字段创建索引</span><br><span class="line">CREATE INDEX index_users_age ON users(age);</span><br><span class="line"># 索引失效</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE age + 1 = 100;</span><br></pre></td></tr></table></figure><h3 id="避免对索引列进行函数操作"><a href="#避免对索引列进行函数操作" class="headerlink" title="避免对索引列进行函数操作"></a>避免对索引列进行函数操作</h3><p>当查询条件对索引列进行函数操作时，索引将失效。函数操作会生成新的值，无法在索引中进行匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 为create_time字段创建索引</span><br><span class="line">CREATE INDEX index_users_create_time ON users(create_time);</span><br><span class="line"># 索引失效</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE year(create_time) = 2019;</span><br></pre></td></tr></table></figure><h3 id="避免使用运算符OR前后存在非索引的列"><a href="#避免使用运算符OR前后存在非索引的列" class="headerlink" title="避免使用运算符OR前后存在非索引的列"></a>避免使用运算符OR前后存在非索引的列</h3><p>如果查询条件中使用了 OR，那么除非每个 OR 条件都能使用索引，否则索引可能会失效。要保证每个OR条件都能使用索引才能保证索引有效。因为OR操作需要对所有的条件进行计算，一旦出现非索引列，就无法使用索引加速查询。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 为name字段创建索引</span><br><span class="line">CREATE INDEX index_users_name ON users(name);</span><br><span class="line"># 索引失效</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE name = &quot;张三&quot; OR age = 20;</span><br><span class="line"># 为age字段创建索引</span><br><span class="line">CREATE INDEX index_users_age ON users(age);</span><br><span class="line"># 可以使用索引</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE name = &quot;张三&quot; OR age = 20;</span><br></pre></td></tr></table></figure><h3 id="避免复合索引违反最左前缀法则"><a href="#避免复合索引违反最左前缀法则" class="headerlink" title="避免复合索引违反最左前缀法则"></a>避免复合索引违反最左前缀法则</h3><p>如果不使用该复合索引的最左边的索引列，则该复合索引会失效，如果跳过复合索引中的某一索引列，则这一索引列后面的索引会失效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个复合索引</span><br><span class="line">CREATE INDEX index_users_name_age_gender ON users(name, age, gender);</span><br><span class="line"># 索引失效</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE age = 20 and gender = &#x27;男&#x27;;</span><br><span class="line"># name索引有效，age和gender失效</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE name = &quot;张三&quot; and gender = &#x27;男&#x27;;</span><br><span class="line"># name、age、gender都有效</span><br><span class="line">EXPLAIN SELECT * FROM users WHERE name = &quot;张三&quot; and age = 20 and gender = &#x27;男&#x27;;</span><br></pre></td></tr></table></figure><h2 id="插入优化"><a href="#插入优化" class="headerlink" title="插入优化"></a>插入优化</h2><h3 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h3><p>假如需要插入多条数据，可以使用多条 INSERT 语句一次性插入多条数据，减少与数据库的交互次数，提高效率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 不推荐</span><br><span class="line">insert into 表名 (列名1, 列名2, ......) values (值1, 值2, ......);</span><br><span class="line">insert into 表名 (列名1, 列名2, ......) values (值1, 值2, ......);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 推荐</span><br><span class="line">insert into 表名(列名1, 列名2, ......) values (值1,值2,......), (值1,值2,......), (值1,值2,......) ......;</span><br></pre></td></tr></table></figure><h3 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h3><p>假如需要插入多条数据，可以将多个插入操作放在一个事务中，可以控制数据的一致性，同时也可以提高插入效率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 不推荐</span><br><span class="line">insert into 表名 (列名1, 列名2, ......) values (值1, 值2, ......);</span><br><span class="line">insert into 表名 (列名1, 列名2, ......) values (值1, 值2, ......);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 推荐</span><br><span class="line">start transaction;</span><br><span class="line">insert into 表名 (列名1, 列名2, ......) values (值1, 值2, ......);</span><br><span class="line">insert into 表名 (列名1, 列名2, ......) values (值1, 值2, ......);</span><br><span class="line">...</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><h3 id="禁用索引"><a href="#禁用索引" class="headerlink" title="禁用索引"></a>禁用索引</h3><p>如果需要插入大量数据，而且这些数据并不需要立即查询，可以在插入前暂时禁用索引，插入完毕后再重新启用索引，可以提高插入效率</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 disable keys; # 禁用索引</span><br><span class="line">insert into 表名(列名1, 列名2, ......) values (值1,值2,......), (值1,值2,......), (值1,值2,......) ......;</span><br><span class="line">alter table 表名 enable keys; # 启用索引</span><br></pre></td></tr></table></figure><h3 id="使用LOAD-DATA-INFILE导入"><a href="#使用LOAD-DATA-INFILE导入" class="headerlink" title="使用LOAD DATA INFILE导入"></a>使用LOAD DATA INFILE导入</h3><p>如果数据源是外部文件，可以使用LOAD DATA INFILE命令可以高效地将外部文件中的数据导入到表中，这种方式比逐行插入更高效，但文件格式需要符合MySQL的要求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LOAD DATA INFILE &#x27;文件路径&#x27; INTO TABLE 表名</span><br><span class="line">  [CHARACTER SET 字符集]</span><br><span class="line">  [FIELDS</span><br><span class="line">    [TERMINATED BY &#x27;分隔符&#x27;]</span><br><span class="line">    [[OPTIONALLY] ENCLOSED BY &#x27;包围符&#x27;]</span><br><span class="line">    [ESCAPED BY &#x27;转义符&#x27;]</span><br><span class="line">  ]</span><br><span class="line">  [LINES</span><br><span class="line">    [STARTING BY &#x27;开始行标志&#x27;]</span><br><span class="line">    [TERMINATED BY &#x27;结束行标志&#x27;]</span><br><span class="line">  ]</span><br><span class="line">  [IGNORE number LINES]</span><br><span class="line">  [(列名1, 列名2, ...)]</span><br></pre></td></tr></table></figure><h2 id="表设计优化"><a href="#表设计优化" class="headerlink" title="表设计优化"></a>表设计优化</h2><h3 id="使用合适的存储引擎"><a href="#使用合适的存储引擎" class="headerlink" title="使用合适的存储引擎"></a>使用合适的存储引擎</h3><p>MySQL支持多种存储引擎，如InnoDB、MyISAM等。根据场景选择合适的存储引擎可以提高性能。</p><ul><li>InnoDB是MySQL的默认存储引擎，它支持事务处理和行级锁定，并具有很好的并发性能。对于大多数情况，使用InnoDB存储引擎是一个明智的选择。</li><li>MyISAM存储引擎适用于更多的读取操作，但不支持事务处理和行级锁定。</li></ul><h3 id="单表不要包含过多字段"><a href="#单表不要包含过多字段" class="headerlink" title="单表不要包含过多字段"></a>单表不要包含过多字段</h3><p>当表的列过多时，会增加查询和写入的复杂度，并且会占用更多的磁盘空间。可以将相关的字段组织在一起，将不常用的字段拆分成其他表，以减少冗余和提高查询效率。</p><h3 id="禁止存储较大二进制数据"><a href="#禁止存储较大二进制数据" class="headerlink" title="禁止存储较大二进制数据"></a>禁止存储较大二进制数据</h3><p>存储较大的二进制数据（如图片、音频等）可能会导致数据库表的膨胀，影响查询和更新的性能。如果需要存储大型文件或二进制数据，建议将其存储在文件系统中，并在数据库中存储相应的路径或引用。</p><h3 id="正确选择合适的数据类型"><a href="#正确选择合适的数据类型" class="headerlink" title="正确选择合适的数据类型"></a>正确选择合适的数据类型</h3><p>选择合适的数据类型可以减少存储空间的占用并提高查询效率</p><ul><li>使用合适大小的整数类型，如TINYINT、SMALLINT等，避免使用较大的整数类型，以节省存储空间。</li><li>使用VARCHAR而不是CHAR，VARCHAR只占用实际使用的存储空间，而CHAR占用固定的存储空间。</li><li>对于小文本字段，使用TEXT或MEDIUMTEXT类型，而不是VARCHAR。</li><li>避免使用ENUM类型，因为它在某些情况下可能会导致数据库膨胀。</li></ul><h3 id="主键使用自增ID"><a href="#主键使用自增ID" class="headerlink" title="主键使用自增ID"></a>主键使用自增ID</h3><p>（1）InnoDB要求每张表都要定义主键，并建议主键采用自增ID（AUTO_INCREMENT）的形式。自增ID保证了主键的唯一性，避免了重复插入数据的情况；由于自增ID在插入数据时会按照顺序递增，插入新数据时会直接在表的末尾添加，不会造成数据的移动和调整（减少了页分裂和页合并），能够提高插入效率</p><ul><li><strong>页分裂现象</strong>：页分裂指当一个表中需要插入新的行时，如果该表已经没有空闲的页可用于存储新行，则数据库系统会自动创建一个新的页，这个过程就是页分裂</li><li><strong>页合并现象</strong>：当一个表中已有的行被删除时，如果该页中已有的记录行数量小于页容量的一半，则数据库系统会将该页与邻近的页合并成一个新的页，这个过程就是页合并</li></ul><p>（2）如果没有定义主键，那么InnoDB内部会生成一个非单调递增的隐藏主键，可能会导致性能下降</p><p>（3）主键一定是聚簇索引，聚簇索引下的数据记录是根据ID排序存储，使用自增ID查询时可以更快地定位数据。</p><h1 id="分区表（partition）"><a href="#分区表（partition）" class="headerlink" title="分区表（partition）"></a>分区表（partition）</h1><h2 id="分区表概括"><a href="#分区表概括" class="headerlink" title="分区表概括"></a>分区表概括</h2><h3 id="分区表含义"><a href="#分区表含义" class="headerlink" title="分区表含义"></a>分区表含义</h3><p>通俗地讲，表分区是将一大表，根据条件分割成若干个小表</p><h3 id="分表与分区的区别"><a href="#分表与分区的区别" class="headerlink" title="分表与分区的区别"></a>分表与分区的区别</h3><p>分表：指的是通过一定规则，将一张表分解成多张不同的表。</p><p>分区：从逻辑上来讲只有一张表（虽然在物理层面上是有多个表文件）。</p><h3 id="判断是否支持分区"><a href="#判断是否支持分区" class="headerlink" title="判断是否支持分区"></a>判断是否支持分区</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 方式一：如果输出 have_partitioning YES 则表示支持分区。</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%partition%&#x27;</span>;</span><br><span class="line"># 方式二：显示所有插件，如果有<span class="keyword">partition</span> <span class="operator">-</span> ACTIVE <span class="operator">-</span> STORAGE ENGINE <span class="operator">-</span> GPL 插件则表明支持分区</span><br><span class="line"><span class="keyword">SHOW</span> PLUGINS;</span><br></pre></td></tr></table></figure><h2 id="Range-partition-范围分区"><a href="#Range-partition-范围分区" class="headerlink" title="Range partition(范围分区)"></a>Range partition(范围分区)</h2><blockquote><p>RANGE 分区，基于一个给定连续区间范围，把数据分配到不同的分区</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> goods (</span><br><span class="line">	id <span class="type">int</span>,</span><br><span class="line">	uname <span class="type">char</span>(<span class="number">10</span>)</span><br><span class="line">	)engine myisam</span><br><span class="line">	<span class="keyword">partition</span> <span class="keyword">by</span> <span class="keyword">range</span>(id) (</span><br><span class="line">	<span class="keyword">partition</span> p1 <span class="keyword">values</span> less than (<span class="number">10</span>),</span><br><span class="line">	<span class="keyword">partition</span> p2 <span class="keyword">values</span> less than (<span class="number">20</span>),</span><br><span class="line">	<span class="keyword">partition</span> p3 <span class="keyword">values</span> less than MAXVALUE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="List-partition-列表分区"><a href="#List-partition-列表分区" class="headerlink" title="List partition(列表分区)"></a>List partition(列表分区)</h2><blockquote><p>LIST 分区，类似 RANGE 分区，区别在 LIST 分区是基于枚举出的值列表分区，RANGE 是局域给定的连续区间范围分区。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 如果试图插入的列值不包含分区值列表中时，那么 <span class="keyword">insert</span> 操作会失败并报错，要重点注意的是，list 分区不存在类似 <span class="keyword">values</span> less than maxvalue 这样包含其他值在内的定义方式，将要匹配的任何值都必须在值列表中找得到。</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span> (</span><br><span class="line">uid <span class="type">int</span>,</span><br><span class="line">pid <span class="type">int</span>,</span><br><span class="line">uname </span><br><span class="line">)engine myisam</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> list(pid) (</span><br><span class="line"><span class="keyword">partition</span> bj <span class="keyword">values</span> <span class="keyword">in</span> (<span class="number">1</span>),</span><br><span class="line"><span class="keyword">partition</span> ah <span class="keyword">values</span> <span class="keyword">in</span> (<span class="number">2</span>),</span><br><span class="line"><span class="keyword">partition</span> xb <span class="keyword">values</span> <span class="keyword">in</span> (<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="Hash-partition-哈希分区"><a href="#Hash-partition-哈希分区" class="headerlink" title="Hash partition(哈希分区)"></a>Hash partition(哈希分区)</h2><blockquote><p>HASH 分区，基于给定的分区个数，把数据分配到不同的分区</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> student_hash(</span><br><span class="line">    id <span class="type">int</span> unsigned <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">    birthday <span class="type">date</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(id,birthday);</span><br><span class="line">) engine<span class="operator">=</span>myisam</span><br><span class="line"><span class="keyword">partition</span> <span class="keyword">by</span> hash (<span class="keyword">month</span>(birthday)) patitions <span class="number">12</span>;</span><br></pre></td></tr></table></figure><h2 id="Key-partition-键值分区"><a href="#Key-partition-键值分区" class="headerlink" title="Key partition(键值分区)"></a>Key partition(键值分区)</h2><blockquote><p>KEY 分区，按照某个字段取余</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table post (</span><br><span class="line">    id int unsigned not null AUTO_INCREMENT,</span><br><span class="line">    title varchar(255),</span><br><span class="line">    PRIMARY KEY (id)</span><br><span class="line">) engine = innodb</span><br><span class="line">partition by key (id) partitions 5;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ipvb.gitee.io">wen</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ipvb.gitee.io/2020/11/15/MySQL-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">https://ipvb.gitee.io/2020/11/15/MySQL-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ipvb.gitee.io" target="_blank">远方の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="./tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="./2020/11/15/MySQL-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/MySQL.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="./2020/12/01/MySQL-11-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/" title="MySQL笔记-数据库高可用性"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2020/12/01/MySQL-11-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/MySQL.png" onerror='onerror=null,src="./img/404.png"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL笔记-数据库高可用性</div></div></a></div><div class="next-post pull-right"><a href="./2020/11/01/MySQL-9-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%A9%E7%90%86%E6%9E%B6%E6%9E%84/" title="MySQL笔记-数据库物理架构"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2020/11/01/MySQL-9-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%89%A9%E7%90%86%E6%9E%B6%E6%9E%84/MySQL.png" onerror='onerror=null,src="./img/404.png"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">MySQL笔记-数据库物理架构</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="./2020/12/15/MySQL-12-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8%E6%8A%80%E5%B7%A7/" title="MySQL笔记-数据库应用技巧"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2020/12/15/MySQL-12-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BA%94%E7%94%A8%E6%8A%80%E5%B7%A7/MySQL.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-15</div><div class="title">MySQL笔记-数据库应用技巧</div></div></a></div><div><a href="./2020/12/01/MySQL-11-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/" title="MySQL笔记-数据库高可用性"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2020/12/01/MySQL-11-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/MySQL.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-01</div><div class="title">MySQL笔记-数据库高可用性</div></div></a></div><div><a href="./2020/07/01/MySQL-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="MySQL笔记-数据库基础知识"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2020/07/01/MySQL-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/MySQL.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-01</div><div class="title">MySQL笔记-数据库基础知识</div></div></a></div><div><a href="./2020/07/15/MySQL-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" title="MySQL笔记-数据库常用操作"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2020/07/15/MySQL-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/MySQL.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-15</div><div class="title">MySQL笔记-数据库常用操作</div></div></a></div><div><a href="./2020/09/01/MySQL-5-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/" title="MySQL笔记-数据库编程相关"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2020/09/01/MySQL-5-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3/MySQL.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-01</div><div class="title">MySQL笔记-数据库编程相关</div></div></a></div><div><a href="./2020/09/15/MySQL-6-%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/" title="MySQL笔记-数据备份和恢复"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2020/09/15/MySQL-6-%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D/MySQL.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-15</div><div class="title">MySQL笔记-数据备份和恢复</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Gitalk</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./img/%E5%A4%B4%E5%83%8F.png" onerror='this.onerror=null,this.src="./img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">wen</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="./archives/"><div class="headline">文章</div><div class="length-num">62</div></a><a href="./tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="./categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wen53231323"><i class="fab fa-github"></i><span>我的仓库</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">暂无</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#SQL%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">SQL性能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8BSQL%E6%89%A7%E8%A1%8C%E4%BF%A1%E6%81%AF%EF%BC%88Profile%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">查看SQL执行信息（Profile）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Profile%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">Profile简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AFProfile"><span class="toc-number">1.1.2.</span> <span class="toc-text">开启Profile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Profile"><span class="toc-number">1.1.3.</span> <span class="toc-text">使用Profile</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%88Status%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">查看状态变量（Status）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">状态变量简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Com%E5%89%8D%E7%BC%80"><span class="toc-number">1.2.2.</span> <span class="toc-text">Com前缀</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8BSQL%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%EF%BC%88localhost-slow-log%EF%BC%89"><span class="toc-number">1.3.</span> <span class="toc-text">查看SQL慢查询日志（localhost-slow.log）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E7%AE%80%E4%BB%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">慢查询简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="toc-number">1.3.2.</span> <span class="toc-text">开启慢查询日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.3.3.</span> <span class="toc-text">慢查询日志的存储位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8BSQL%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%EF%BC%88Explain%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">查看SQL执行计划（Explain）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E7%AE%80%E4%BB%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">执行计划简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">执行计划使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E5%AD%97%E6%AE%B5%E4%BF%A1%E6%81%AF"><span class="toc-number">1.4.3.</span> <span class="toc-text">执行计划字段信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%EF%BC%88index%EF%BC%89"><span class="toc-number">2.</span> <span class="toc-text">索引（index）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.</span> <span class="toc-text">索引是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.2.</span> <span class="toc-text">索引的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">索引的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">2.2.0.2.</span> <span class="toc-text">索引的缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">2.3.</span> <span class="toc-text">索引的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AD%97%E6%AE%B5%E7%89%B9%E6%80%A7%E5%88%86%E7%B1%BB"><span class="toc-number">2.3.1.</span> <span class="toc-text">根据索引的字段特性分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AD%97%E6%AE%B5%E4%B8%AA%E6%95%B0%E5%88%86%E7%B1%BB"><span class="toc-number">2.3.2.</span> <span class="toc-text">根据索引的字段个数分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E7%B4%A2%E5%BC%95%E7%9A%84%E5%AD%98%E5%82%A8%E5%BD%A2%E5%BC%8F%E5%88%86%E7%B1%BB"><span class="toc-number">2.3.3.</span> <span class="toc-text">根据索引的存储形式分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">索引的语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E8%A1%A8%E6%97%B6%E6%8C%87%E5%AE%9A%E7%B4%A2%E5%BC%95"><span class="toc-number">2.4.1.</span> <span class="toc-text">建表时指定索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E8%A1%A8%E5%90%8E%E6%8C%87%E5%AE%9A%E7%B4%A2%E5%BC%95"><span class="toc-number">2.4.2.</span> <span class="toc-text">建表后指定索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95"><span class="toc-number">2.4.3.</span> <span class="toc-text">查看索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95"><span class="toc-number">2.4.4.</span> <span class="toc-text">添加索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="toc-number">2.4.5.</span> <span class="toc-text">删除索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%A6%81%E7%94%A8%E4%B8%8E%E5%BC%80%E5%90%AF"><span class="toc-number">2.4.6.</span> <span class="toc-text">索引的禁用与开启</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.5.</span> <span class="toc-text">索引的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95%EF%BC%88Hash%EF%BC%89"><span class="toc-number">2.5.1.</span> <span class="toc-text">哈希索引（Hash）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%EF%BC%88B-Tree%EF%BC%89"><span class="toc-number">2.5.2.</span> <span class="toc-text">B 树（B Tree）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%EF%BC%88B-Tree%EF%BC%89-1"><span class="toc-number">2.5.3.</span> <span class="toc-text">B + 树（B + Tree）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E4%B8%AD%E7%9A%84-B-%E6%A0%91%EF%BC%88B-Tree%EF%BC%89"><span class="toc-number">2.5.4.</span> <span class="toc-text">MySQL中的 B + 树（B + Tree）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB%E4%B8%AD%E4%B8%80%E9%A2%97B-%E6%A0%91%E5%8F%AF%E4%BB%A5%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91%E8%A1%8C%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="toc-number">2.5.4.1.</span> <span class="toc-text">InnoDB中一颗B+树可以存放多少行数据？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">2.6.</span> <span class="toc-text">聚簇索引与非聚簇索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">2.6.1.</span> <span class="toc-text">聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95"><span class="toc-number">2.6.2.</span> <span class="toc-text">非聚簇索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E4%B8%8E%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95%E5%8C%BA%E5%88%AB"><span class="toc-number">2.6.3.</span> <span class="toc-text">聚簇索引与非聚簇索引区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E5%92%8C%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.7.</span> <span class="toc-text">覆盖索引和回表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E7%9F%A5%E4%BF%A1%E6%81%AF"><span class="toc-number">2.7.1.</span> <span class="toc-text">已知信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">2.7.2.</span> <span class="toc-text">覆盖索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.7.3.</span> <span class="toc-text">回表查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%A4%B1%E6%95%88%E6%83%85%E5%86%B5"><span class="toc-number">2.8.</span> <span class="toc-text">索引的失效情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E8%A1%A8%E5%92%8C%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE"><span class="toc-number">2.8.1.</span> <span class="toc-text">测试表和测试数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%B4%A2%E5%BC%95%E5%88%97%E4%BD%BF%E7%94%A8%E4%B8%8D%E7%AD%89%E4%BA%8E%E5%8C%B9%E9%85%8D"><span class="toc-number">2.8.2.</span> <span class="toc-text">对索引列使用不等于匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%B4%A2%E5%BC%95%E5%88%97%E4%BD%BF%E7%94%A8IS-NOT-NULL"><span class="toc-number">2.8.3.</span> <span class="toc-text">对索引列使用IS NOT NULL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%B4%A2%E5%BC%95%E5%88%97%E8%BF%9B%E8%A1%8C%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2like%E4%BB%A5-%E5%BC%80%E5%A4%B4"><span class="toc-number">2.8.4.</span> <span class="toc-text">对索引列进行模糊查询like以%开头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%B4%A2%E5%BC%95%E5%88%97%E8%BF%9B%E8%A1%8C%E8%BF%90%E7%AE%97%E6%93%8D%E4%BD%9C"><span class="toc-number">2.8.5.</span> <span class="toc-text">对索引列进行运算操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%B4%A2%E5%BC%95%E5%88%97%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C"><span class="toc-number">2.8.6.</span> <span class="toc-text">对索引列进行函数操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6OR%E5%89%8D%E5%90%8E%E5%AD%98%E5%9C%A8%E9%9D%9E%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%97"><span class="toc-number">2.8.7.</span> <span class="toc-text">使用运算符OR前后存在非索引的列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E8%BF%9D%E5%8F%8D%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99"><span class="toc-number">2.8.8.</span> <span class="toc-text">复合索引违反最左前缀法则</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">数据库优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="toc-number">3.1.</span> <span class="toc-text">查询优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8SELECT-%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.1.1.</span> <span class="toc-text">避免使用SELECT * 查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84DISTINCT%E5%8E%BB%E9%87%8D"><span class="toc-number">3.1.2.</span> <span class="toc-text">避免使用不必要的DISTINCT去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84ORDER-BY%E6%8E%92%E5%BA%8F"><span class="toc-number">3.1.3.</span> <span class="toc-text">避免不必要的ORDER BY排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AAJOIN%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.1.4.</span> <span class="toc-text">避免使用多个JOIN联表查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.1.5.</span> <span class="toc-text">避免使用子查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8INNER-JOIN%E4%BB%A3%E6%9B%BFLEFT-JOIN%E6%88%96RIGHT-JOIN"><span class="toc-number">3.1.6.</span> <span class="toc-text">使用INNER JOIN代替LEFT JOIN或RIGHT JOIN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8WHERE%E6%9B%BF%E6%8D%A2HAVING%E5%AD%90%E5%8F%A5"><span class="toc-number">3.1.7.</span> <span class="toc-text">使用WHERE替换HAVING子句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8UNION-ALL%E4%BB%A3%E6%9B%BFUNION"><span class="toc-number">3.1.8.</span> <span class="toc-text">使用UNION ALL代替UNION</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8LIMIT%E5%AD%90%E5%8F%A5%E9%99%90%E5%88%B6%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C"><span class="toc-number">3.1.9.</span> <span class="toc-text">使用LIMIT子句限制查询结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8NOT-EXISTS%E6%9B%BF%E4%BB%A3NOT-IN"><span class="toc-number">3.1.10.</span> <span class="toc-text">使用NOT EXISTS替代NOT IN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8EXISTS%E6%9B%BF%E4%BB%A3IN"><span class="toc-number">3.1.11.</span> <span class="toc-text">使用EXISTS替代IN</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-number">3.2.</span> <span class="toc-text">索引优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%AF%B9%E7%B4%A2%E5%BC%95%E5%88%97%E4%BD%BF%E7%94%A8%E4%B8%8D%E7%AD%89%E4%BA%8E%E5%8C%B9%E9%85%8D"><span class="toc-number">3.2.1.</span> <span class="toc-text">避免对索引列使用不等于匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%AF%B9%E7%B4%A2%E5%BC%95%E5%88%97%E4%BD%BF%E7%94%A8IS-NOT-NULL"><span class="toc-number">3.2.2.</span> <span class="toc-text">避免对索引列使用IS NOT NULL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%AF%B9%E7%B4%A2%E5%BC%95%E5%88%97%E8%BF%9B%E8%A1%8C%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2like%E4%BB%A5-%E5%BC%80%E5%A4%B4"><span class="toc-number">3.2.3.</span> <span class="toc-text">避免对索引列进行模糊查询like以%开头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%AF%B9%E7%B4%A2%E5%BC%95%E5%88%97%E8%BF%9B%E8%A1%8C%E8%BF%90%E7%AE%97%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.4.</span> <span class="toc-text">避免对索引列进行运算操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%AF%B9%E7%B4%A2%E5%BC%95%E5%88%97%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.5.</span> <span class="toc-text">避免对索引列进行函数操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6OR%E5%89%8D%E5%90%8E%E5%AD%98%E5%9C%A8%E9%9D%9E%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%97"><span class="toc-number">3.2.6.</span> <span class="toc-text">避免使用运算符OR前后存在非索引的列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E5%A4%8D%E5%90%88%E7%B4%A2%E5%BC%95%E8%BF%9D%E5%8F%8D%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99"><span class="toc-number">3.2.7.</span> <span class="toc-text">避免复合索引违反最左前缀法则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E4%BC%98%E5%8C%96"><span class="toc-number">3.3.</span> <span class="toc-text">插入优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5"><span class="toc-number">3.3.1.</span> <span class="toc-text">批量插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1"><span class="toc-number">3.3.2.</span> <span class="toc-text">使用事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%81%E7%94%A8%E7%B4%A2%E5%BC%95"><span class="toc-number">3.3.3.</span> <span class="toc-text">禁用索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8LOAD-DATA-INFILE%E5%AF%BC%E5%85%A5"><span class="toc-number">3.3.4.</span> <span class="toc-text">使用LOAD DATA INFILE导入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96"><span class="toc-number">3.4.</span> <span class="toc-text">表设计优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%90%88%E9%80%82%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">3.4.1.</span> <span class="toc-text">使用合适的存储引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%A1%A8%E4%B8%8D%E8%A6%81%E5%8C%85%E5%90%AB%E8%BF%87%E5%A4%9A%E5%AD%97%E6%AE%B5"><span class="toc-number">3.4.2.</span> <span class="toc-text">单表不要包含过多字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E5%AD%98%E5%82%A8%E8%BE%83%E5%A4%A7%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE"><span class="toc-number">3.4.3.</span> <span class="toc-text">禁止存储较大二进制数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.4.</span> <span class="toc-text">正确选择合适的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E9%94%AE%E4%BD%BF%E7%94%A8%E8%87%AA%E5%A2%9EID"><span class="toc-number">3.4.5.</span> <span class="toc-text">主键使用自增ID</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%EF%BC%88partition%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">分区表（partition）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E6%A6%82%E6%8B%AC"><span class="toc-number">4.1.</span> <span class="toc-text">分区表概括</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8%E5%90%AB%E4%B9%89"><span class="toc-number">4.1.1.</span> <span class="toc-text">分区表含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E8%A1%A8%E4%B8%8E%E5%88%86%E5%8C%BA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.2.</span> <span class="toc-text">分表与分区的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%88%86%E5%8C%BA"><span class="toc-number">4.1.3.</span> <span class="toc-text">判断是否支持分区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Range-partition-%E8%8C%83%E5%9B%B4%E5%88%86%E5%8C%BA"><span class="toc-number">4.2.</span> <span class="toc-text">Range partition(范围分区)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List-partition-%E5%88%97%E8%A1%A8%E5%88%86%E5%8C%BA"><span class="toc-number">4.3.</span> <span class="toc-text">List partition(列表分区)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash-partition-%E5%93%88%E5%B8%8C%E5%88%86%E5%8C%BA"><span class="toc-number">4.4.</span> <span class="toc-text">Hash partition(哈希分区)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Key-partition-%E9%94%AE%E5%80%BC%E5%88%86%E5%8C%BA"><span class="toc-number">4.5.</span> <span class="toc-text">Key partition(键值分区)</span></a></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="./2023/01/01/CSS/" title="CSS笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/CSS/CSS.png" onerror='this.onerror=null,this.src="./img/404.png"' alt="CSS笔记"></a><div class="content"><a class="title" href="./2023/01/01/CSS/" title="CSS笔记">CSS笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="./2023/01/01/HTML/" title="HTML笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/HTML/HTML.png" onerror='this.onerror=null,this.src="./img/404.png"' alt="HTML笔记"></a><div class="content"><a class="title" href="./2023/01/01/HTML/" title="HTML笔记">HTML笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="./2023/01/01/JavaScript/" title="JavaScript笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/JavaScript/JavaScript.png" onerror='this.onerror=null,this.src="./img/404.png"' alt="JavaScript笔记"></a><div class="content"><a class="title" href="./2023/01/01/JavaScript/" title="JavaScript笔记">JavaScript笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="./2023/01/01/Linux/" title="Linux笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/Linux/Linux.png" onerror='this.onerror=null,this.src="./img/404.png"' alt="Linux笔记"></a><div class="content"><a class="title" href="./2023/01/01/Linux/" title="Linux笔记">Linux笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="./2023/01/01/JavaWeb/" title="JavaWeb笔记"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="./2023/01/01/JavaWeb/JavaWeb.png" onerror='this.onerror=null,this.src="./img/404.png"' alt="JavaWeb笔记"></a><div class="content"><a class="title" href="./2023/01/01/JavaWeb/" title="JavaWeb笔记">JavaWeb笔记</a><time datetime="2022-12-31T16:00:00.000Z" title="发表于 2023-01-01 00:00:00">2023-01-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By wen</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="./js/utils.js"></script><script src="./js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '701b8bc001a40a760558',
      clientSecret: 'a51b436adc471c3949a8f41be05c2d58cccab10a',
      repo: 'Hexo-Butterfly-Comment',
      owner: 'wen53231323',
      admin: ['wen53231323'],
      id: 'ae7d92daadbc6520b0f2b4a0b9023a90',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'VI32wmbmMoxvlhpTpoDBNeOk-MdYXbMMI',
      appKey: 'oFstfBFkCQIkjuk4ibCpbGqz',
      avatar: 'monsterid',
      serverURLs: 'https://vi32wmbm.api.lncldglobal.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Gitalk' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="./js/search/local-search.js"></script></div></div></body></html>